<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2019-08-26T23:03:48+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">글쓰기 클래스 - 1 과제</title><link href="https://lahuman.github.io/write_class_1_homework/" rel="alternate" type="text/html" title="글쓰기 클래스 - 1 과제" /><published>2019-08-26T00:00:00+09:00</published><updated>2019-08-26T00:00:00+09:00</updated><id>https://lahuman.github.io/write_class_1_homework</id><content type="html" xml:base="https://lahuman.github.io/write_class_1_homework/">&lt;h1 id=&quot;1장-일기-말고-에세이-쓰기&quot;&gt;1장 일기 말고 에세이 쓰기!&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;지난 시간에 배운 내용 정리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;아무 것이나 매일 써라!&lt;/li&gt;
  &lt;li&gt;글쓰기 == 즐겁다
    &lt;ul&gt;
      &lt;li&gt;자신이 즐거운 글을 쓴다.&lt;/li&gt;
      &lt;li&gt;글을 완성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신경 쓰이는 것에 집중 하라
    &lt;ul&gt;
      &lt;li&gt;일상에서 특별한 것을 찾아내는 기술&lt;/li&gt;
      &lt;li&gt;일상을 잘 관찰 하자&lt;/li&gt;
      &lt;li&gt;나만의 유니크한 글을 쓰자
        &lt;ul&gt;
          &lt;li&gt;남이 생각하지 않은 메시지를 쓰자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;에세이란?
    &lt;ul&gt;
      &lt;li&gt;제 3자에게 전달하기 위해 작성&lt;/li&gt;
      &lt;li&gt;모르는 사람도 이해하기 쉽게 자세히 작성&lt;/li&gt;
      &lt;li&gt;감정을 움직이는 글이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;글 쓸때 추가 팁
    &lt;ul&gt;
      &lt;li&gt;감정 V.S 메시지
        &lt;ul&gt;
          &lt;li&gt;둘중 하나는 글에 담자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다른 유명인의 글을 인용&lt;/li&gt;
      &lt;li&gt;첫 문장을 “ 로 시작&lt;/li&gt;
      &lt;li&gt;한(큰) 주제를 관통하게 쓰자&lt;/li&gt;
      &lt;li&gt;타겟을 명확히 하자&lt;/li&gt;
      &lt;li&gt;클라이맥스에서 논리적/상세한 묘사/느리게 등으로 증폭 하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;과제로는-마음에-드는-문장-하나-가져오기-입니다&quot;&gt;과제로는 마음에 드는 문장 하나 가져오기 입니다.&lt;/h2&gt;

&lt;p&gt;개인적으로 준비한 내용은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;There are only two ways to live your life. One is as though nothing is a miracle. The other is as though everything is.

 - Albert Einstein

인생을 살아가는 데는 오직 두가지 방법밖에 없다. 하나는 아무것도 기적이 아닌 것처럼, 다른 하나는 모든 것이 기적인 것처럼 살아가는 것이다.
 - 알베르트 아인슈타인
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;강사님--김은경&quot;&gt;강사님 : &lt;a href=&quot;http://www.yes24.com/SearchCorner/Search?author_yn=y&amp;amp;query=&amp;amp;auth_no=224730&amp;amp;domain=all&quot;&gt;김은경&lt;/a&gt;&lt;/h2&gt;</content><category term="write" /><category term="class" /><summary type="html">인상 깊은 문구 가져오기</summary></entry><entry><title type="html">글쓰기 클래스 - 1</title><link href="https://lahuman.github.io/write_class_1/" rel="alternate" type="text/html" title="글쓰기 클래스 - 1" /><published>2019-08-22T00:00:00+09:00</published><updated>2019-08-22T00:00:00+09:00</updated><id>https://lahuman.github.io/write_class_1</id><content type="html" xml:base="https://lahuman.github.io/write_class_1/">&lt;h1 id=&quot;글쓰기를-배우고-있다&quot;&gt;글쓰기를 배우고 있다.&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;2017년 대학원 논문을 작성할 당시 교수님에게 많이 배웠으나, 내 실력은 여전히 안좋다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;왜-글을-쓰는가&quot;&gt;왜 글을 쓰는가?&lt;/h2&gt;

&lt;p&gt;내가 생각한 것을 다른 사람에게 정확하게 전달 하고 싶다.&lt;/p&gt;

&lt;h2 id=&quot;첫번째-시간에-무엇을-배웠는가&quot;&gt;첫번째 시간에 무엇을 배웠는가?&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;일기와 에세이의 차이점
    &lt;ul&gt;
      &lt;li&gt;일기 : 나만 알고 이해하도록 내용을 작성한다.&lt;/li&gt;
      &lt;li&gt;에세이 : 제 3자가 이해할 수 있도록 내용을 작성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;논리적인 글을 쓰는 방법
    &lt;ul&gt;
      &lt;li&gt;큰 주제를 가진 글을 쓴다.&lt;/li&gt;
      &lt;li&gt;타겟이 명확한 글을 쓴다.&lt;/li&gt;
      &lt;li&gt;클라이맥스는 느리게/감정적으로 티나게 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;첫번째-연슴한-글쓰기&quot;&gt;첫번째 연슴한 글쓰기&lt;/h2&gt;

&lt;p&gt;내가 경험했던 글쓰기가 필요한 내용을 에세이 형식으로 작성 하였으나, 글의 마무리가 어설펐다.&lt;/p&gt;

&lt;h2 id=&quot;총평&quot;&gt;총평&lt;/h2&gt;

&lt;p&gt;재미있는 시간이었다. 다음 시간까지 가장 감명 깊었던 카피라이터를 준비해야 한다.&lt;/p&gt;

&lt;p&gt;무엇이 나에게 좋았는지 작성해보자.&lt;/p&gt;</content><category term="write" /><category term="class" /><summary type="html">회사에서 진행하는 뭉클로 글쓰기를 해보고 있다.</summary></entry><entry><title type="html">package-lock.json은 왜 필요 한가?</title><link href="https://lahuman.github.io/what_is_package-lock_json/" rel="alternate" type="text/html" title="package-lock.json은 왜 필요 한가?" /><published>2019-08-18T00:00:00+09:00</published><updated>2019-08-18T00:00:00+09:00</updated><id>https://lahuman.github.io/what_is_package-lock_json</id><content type="html" xml:base="https://lahuman.github.io/what_is_package-lock_json/">&lt;h1 id=&quot;package-lockjson은-왜-필요-한가&quot;&gt;package-lock.json은 왜 필요 한가?&lt;/h1&gt;

&lt;p&gt;npm install을 이용해서 package를 인스톨하면 자동으로 &lt;strong&gt;package-lock.json&lt;/strong&gt;이라는 파일이 생성된다.&lt;/p&gt;

&lt;p&gt;용도를 몰라서 그냥 두고 있었는데, 가끔씩 이 파일이 형상관리 과정에서 충돌이 일어나 &lt;strong&gt;.gitignore&lt;/strong&gt;에 추가해버렸었다.&lt;/p&gt;

&lt;p&gt;함께 일하시는 분이 package-lock.json은 꼭 필요하다는 이야기를 해주셔서 검색을 해보니 다음과 같은 경우에 사용된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;npm의 버전의 다른 경우&lt;/li&gt;
  &lt;li&gt;의존성을 가진 패키지의 버전이 업데이터 되는 경우&lt;/li&gt;
  &lt;li&gt;의존성을 가진 패키지가 의존하는 패키지의 버전이 업데이트되는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;node_modules의 폴더의 스냅샷을 저장하여, 다른 곳에서 npm install 명령어를 실행시 package-lock.json에 명시된 의존 패키지들을 통해 node_modules를 만들어 낸다. 다만, package.json의 변경은 package-lock.json 보다 우선 된다.&lt;/p&gt;

&lt;p&gt;주요 사항은 &lt;strong&gt;package-lock.json&lt;/strong&gt;은 꼭 형상 관리에 포함 시켜야 한다.&lt;/p&gt;

&lt;h3 id=&quot;그러하다&quot;&gt;그러하다&lt;/h3&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dschci.tistory.com/108&quot;&gt;Npm 거슬리는 pacakge-lock.json?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="npm" /><category term="package" /><summary type="html">결론은 필요 하다! 꼭 형상 관리에 추가 할 것!</summary></entry><entry><title type="html">브라우저의 쿠키와 로컬스토리지 차이</title><link href="https://lahuman.github.io/browser_cookie_localstorage/" rel="alternate" type="text/html" title="브라우저의 쿠키와 로컬스토리지 차이" /><published>2019-08-17T00:00:00+09:00</published><updated>2019-08-17T00:00:00+09:00</updated><id>https://lahuman.github.io/browser_cookie_localstorage</id><content type="html" xml:base="https://lahuman.github.io/browser_cookie_localstorage/">&lt;h1 id=&quot;broswer의-cookie-와-localstorage-의-차이점-정리&quot;&gt;Broswer의 Cookie 와 localstorage 의 차이점 정리&lt;/h1&gt;

&lt;p&gt;쿠키는 오랫동안 사용된 클라이언트에 저장하는 정보이다.&lt;/p&gt;

&lt;p&gt;로컬 스토리지는 웹 스토리지의 하나로 기본적으로 key와 value 형태이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&quot;&gt;웹 스토리지&lt;/a&gt;는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/Window/sessionStorage&quot;&gt;세션 스토리지&lt;/a&gt;와 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Local_storage&quot;&gt;로컬 스토리지&lt;/a&gt;가 존재한다.
세션 스토리지와 로컬 스토리지의 차이는 세션이 종료되는 경우 스토리지 내용의 삭제 유무이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;쿠키와-로컬스토리지와의-가장-큰-차이점&quot;&gt;쿠키와 로컬스토리지와의 가장 큰 차이점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;쿠키는 서버에서 읽을수 있음&lt;/li&gt;
  &lt;li&gt;로컬 스토리지는 클라이언트에서만 읽고 쓸수 있음&lt;/li&gt;
  &lt;li&gt;쿠키는 4Kb 까지만 지원&lt;/li&gt;
  &lt;li&gt;로컬 스토리지는 5Mb 까지 지원&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&quot;&gt;웹 스토리지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/Window/sessionStorage&quot;&gt;세션 스토리지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Local_storage&quot;&gt;로컬 스토리지&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3220660/local-storage-vs-cookies?source=post_page-----2f3732c7d977----------------------&quot;&gt;ocal Storage vs Cookies&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kadamon.tistory.com/8&quot;&gt;쿠키 vs 로컬스토리지 vs 세션스토리지&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="cookie" /><category term="localstorage" /><summary type="html">쿠키는 오래전부터 사용해보았는데 로컬스토리지는 무엇인가??</summary></entry><entry><title type="html">Loop와 함께 async, await 사용하기</title><link href="https://lahuman.github.io/loop_with_async_await/" rel="alternate" type="text/html" title="Loop와 함께 async, await 사용하기" /><published>2019-08-12T00:00:00+09:00</published><updated>2019-08-12T00:00:00+09:00</updated><id>https://lahuman.github.io/loop_with_async_await</id><content type="html" xml:base="https://lahuman.github.io/loop_with_async_await/">&lt;h1 id=&quot;loop와-함께-async-await-사용하기&quot;&gt;Loop와 함께 async, await 사용하기&lt;/h1&gt;

&lt;p&gt;함께 일하는 분이 while 과 함께 async를 사용하면 동작 하지 않는다고 하셔서 확인을 해보았다.&lt;/p&gt;

&lt;p&gt;결론은 동작은 잘된다.&lt;/p&gt;

&lt;p&gt;다만, array를 이용해서 forEach, map 등을 할경우는 동작 하지 않는다.&lt;/p&gt;

&lt;p&gt;그래서 array는 for 문을 이용해서 직렬로 처리 하거나, map으로 모든 오브젝트를 promise로 변환하여 병렬로 처리 하여야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const sleep = (ms) =&amp;gt; {
  return new Promise(resolve =&amp;gt; setTimeout(resolve, ms));
}
const wrapSlept = async () =&amp;gt; { await sleep(2000) };

function delay(item) { return new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; { console.log(item); resolve(); }, 500)); }

const testAwait = async () =&amp;gt; {
  //동작
  let i = 0;
  while (i &amp;lt; 5) {
    console.log('i: ', i);
    i++;
    await wrapSlept(3000);
  }
  console.log(&quot;Done!&quot;);
  
  //동작
  for (var f = 0; f &amp;lt; 5; f++) {
    console.log('f: ', f);
    await wrapSlept(3000);
  }
  console.log(&quot;Done!&quot;);
  
  //동작 안함
  [1, 2, 3].forEach(async (n) =&amp;gt; {
    console.log('n: ', n);
    await wrapSlept(3000);
  });
  console.log(&quot;Done!&quot;);
  
  //직렬 처리
  for (const item of [1,2,3]) {
    await delay(item);
  }
  console.log(&quot;Done!&quot;);

  //병렬
  const promises = [1, 2, 3].map(item =&amp;gt; delay(item));
  await Promise.all(promises);
  console.log(&quot;Done!&quot;);

}

testAwait();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;기억해두자&quot;&gt;기억해두자&lt;/h2&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mygumi.tistory.com/328&quot;&gt;[Async function] async/await 비동기 처리 :: 마이구미&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="async" /><category term="loop" /><summary type="html">루프와 함께 async, await 사용기</summary></entry><entry><title type="html">아이가 짜증내고 화내고 바보 같이 구는 행동을 받아주기 너무 힘들다.</title><link href="https://lahuman.github.io/20190807/" rel="alternate" type="text/html" title="아이가 짜증내고 화내고 바보 같이 구는 행동을 받아주기 너무 힘들다." /><published>2019-08-07T00:00:00+09:00</published><updated>2019-08-07T00:00:00+09:00</updated><id>https://lahuman.github.io/20190807</id><content type="html" xml:base="https://lahuman.github.io/20190807/">&lt;h1 id=&quot;아이의-짜증과-화를-받아주기-힘들다&quot;&gt;아이의 짜증과 화를 받아주기 힘들다.&lt;/h1&gt;

&lt;p&gt;미친 아이처럼 소리 지르고 물건을 던지고 짜증내는 아이를 보고 있으면… 싫다.&lt;/p&gt;

&lt;p&gt;왜 저러는지도 모르겠다.&lt;/p&gt;

&lt;p&gt;내가 아이를 이해하지 못해 아이도 힘들고 나도 힘든거 같다.&lt;/p&gt;

&lt;p&gt;나는 아직 아빠의 자격이 없는지도 모르겠다.&lt;/p&gt;

&lt;p&gt;아이를 사랑으로만 대하려고 노력하지만 순간 순간마다, 나도 아이에게 소리를 지르고 짜증을 내고 만다.&lt;/p&gt;

&lt;p&gt;어떻게 해야할지 모르겠다.&lt;/p&gt;

&lt;p&gt;아이에게 좋게 이야기 하려고 하다가 소리를 지르게 된다.&lt;/p&gt;

&lt;h2 id=&quot;이런-내가-싫다&quot;&gt;이런 내가 싫다.&lt;/h2&gt;

&lt;h2 id=&quot;아이를-키우는-것도-너무-힘들고-싫다&quot;&gt;아이를 키우는 것도 너무 힘들고 싫다.&lt;/h2&gt;

&lt;h2 id=&quot;늘-좋을-수-많은-없겠지만-오늘은-정말-싫고-힘들다&quot;&gt;늘 좋을 수 많은 없겠지만, 오늘은 정말 싫고 힘들다.&lt;/h2&gt;</content><category term="단상" /><summary type="html">아이가 싫어진다.</summary></entry><entry><title type="html">AWS EC2 서버에서 DATE를 강제로 변경하기</title><link href="https://lahuman.github.io/aws_ubuntu_date_change/" rel="alternate" type="text/html" title="AWS EC2 서버에서 DATE를 강제로 변경하기" /><published>2019-08-06T00:00:00+09:00</published><updated>2019-08-06T00:00:00+09:00</updated><id>https://lahuman.github.io/aws_ubuntu_date_change</id><content type="html" xml:base="https://lahuman.github.io/aws_ubuntu_date_change/">&lt;h1 id=&quot;aws-ec2-서버에서-date를-강제로-변경하기&quot;&gt;AWS EC2 서버에서 DATE를 강제로 변경하기&lt;/h1&gt;

&lt;p&gt;AWS의 EC2 서버의 Date를 변경하기 위해서 다음과 같은 명령어를 이용하여 처리 하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; sudo date -s &quot;2019-08-07 15:00:00&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 결과는 현재 시간으로 계속 표출되어 검새을 해보니, 날짜를 자동으로 마춰주는 모듈이 있었다.&lt;/p&gt;

&lt;p&gt;해당 모듈을 잠시 사용하지 않음으로 변경하고 날짜를 변경하면 잘된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; sudo timedatectl set-ntp false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 현재시간과 동기화를 해주려면 다음과 같이 설정하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; sudo timedatectl set-ntp true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;aws-ec2에서는-기본적으로-시간-동기화를-시켜주나보다&quot;&gt;AWS EC2에서는 기본적으로 시간 동기화를 시켜주나보다.&lt;/h3&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/679988/how-to-change-ubuntus-server-date-and-time-via-command-line&quot;&gt;How to change ubuntu’s server date and time via command line?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="ubuntu" /><category term="date" /><summary type="html">데이터를 강제로 변경해도 현재시간으로 변경됨</summary></entry><entry><title type="html">Async Await을 이용하여 처리시 catch를 처리하지 않아 response 무한 대기 현상 해결 방법</title><link href="https://lahuman.github.io/async_await_catch/" rel="alternate" type="text/html" title="Async Await을 이용하여 처리시 catch를 처리하지 않아 response 무한 대기 현상 해결 방법" /><published>2019-08-03T00:00:00+09:00</published><updated>2019-08-03T00:00:00+09:00</updated><id>https://lahuman.github.io/async_await_catch</id><content type="html" xml:base="https://lahuman.github.io/async_await_catch/">&lt;h1 id=&quot;async-await을-이용하여-처리시-catch를-처리하지-않아-response-무한-대기-현상&quot;&gt;Async Await을 이용하여 처리시 catch를 처리하지 않아 response 무한 대기 현상&lt;/h1&gt;

&lt;p&gt;개인적으로 Promise, callback 보다는 async await를 많이 이용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const getSomething = asycn (req, res, next) =&amp;gt; {

    const something = await callPromiseObject();

    res.json(something);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 처리시 기본적으로는 큰 문제가 없지만, callPromiseObject() 를 실행하다 오류가 발생하면 response를 전송하지 못하여 무한 대기 하는 오류가 발생한다.&lt;/p&gt;

&lt;p&gt;해결하는 방법은 몇가지가 있는데, 그중 하나는&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const getSomething = asycn (req, res, next) =&amp;gt; {
    try{
        const something = await callPromiseObject();

        res.json(something);
    }catch(e){
        next(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 try, catch를 이용하는 것이다. 개인적으로 동일한 코드가 계속 반복되어 좋아하는 스타일은 아니다.&lt;/p&gt;

&lt;p&gt;또 다른 방법은 Promise를 이용하거나 callback을 이용하는 방식이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const asyncHandler = require('express-async-handler')
 
express.get('/', asyncHandler(async (req, res, next) =&amp;gt; {
    const bar = await foo.findAll();
    res.send(bar)
}))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 방식으로 처리 하는 것인데, 미들웨어 코드를 보면 간단하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const asyncUtil = fn =&amp;gt;
function asyncUtilWrap(...args) {
  const fnReturn = fn(...args)
  const next = args[args.length-1]
  return Promise.resolve(fnReturn).catch(next)
}

module.exports = asyncUtil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;개인적으로는 미들웨어를 사용하는 방식으로 좀더 쉬운듯 하여 찾아보니 다음과 같은 모듈도 있었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express')
var wrap = require('async-middleware').wrap
 
var app = express()
 
app.use(wrap(function (req, res) {
  return Promise.reject(new Error('boom!'))
}))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/express-async-handler&quot;&gt;express-async-handler&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/async-middleware&quot;&gt;async-middleware&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="async" /><summary type="html">은근 손이 가는 부분임!</summary></entry><entry><title type="html">구조화된 객체 또는 배열을 Distructuring (비구조화, 파괴) 하여 사용하기</title><link href="https://lahuman.github.io/distructuring/" rel="alternate" type="text/html" title="구조화된 객체 또는 배열을 Distructuring (비구조화, 파괴) 하여 사용하기" /><published>2019-07-21T00:00:00+09:00</published><updated>2019-07-21T00:00:00+09:00</updated><id>https://lahuman.github.io/distructuring</id><content type="html" xml:base="https://lahuman.github.io/distructuring/">&lt;h1 id=&quot;구조화된-객체-또는-배열을-distructuring-비구조화-파괴-하여-사용하기&quot;&gt;구조화된 객체 또는 배열을 Distructuring (비구조화, 파괴) 하여 사용하기&lt;/h1&gt;

&lt;p&gt;같이 일하시는 분의 코드를 리뷰 하던 중 처음 보는 문법을 발견했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let [
{
result: { riskLevelCount, riskLevelRanking, riskLevelHistory },
pending: loading,

},
execGetAnalysis,
] = (() =&amp;gt; [{result:{riskLevelCount:[1,2,3], riskLevelRanking: [4,5,6], riskLevelHistory: [7,8,9]}, pending: false}, (a) =&amp;gt; console.log(a) ])() ;

console.log(riskLevelCount); // 결과 : [1,2,3]
console.log(loading) // 결과 : false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;React 를 공부 하면서 Hooks 에서 다음과 같이 사용하는 하는 건,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const [hasInt, setHasInt] = useState(false);

console.log(hasInt) // false;
setHasInt(true);
console.log(hasInt) // true;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그냥 받아들이고 사용하고 있었는데, 다시 보니 이해하지 못하는 문법이있다.&lt;/p&gt;

&lt;p&gt;해당 문법은 ES6에서 제공되는 Distructuring(비구조화, 파괴) 라고 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;디스트럭처링(Destructuring)은 구조화된 배열 또는 객체를 Destructuring(비구조화, 파괴)하여 개별적인 변수에 할당하는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2015년에 올라온 포스트인 &lt;a href=&quot;http://hacks.mozilla.or.kr/2015/09/es6-in-depth-destructuring/&quot;&gt;ES6 In Depth: 디스트럭처링(Destructuring)&lt;/a&gt;을 보면 자세하게 설명 되어 있다.&lt;/p&gt;

&lt;h2 id=&quot;공부하자&quot;&gt;공부하자!!&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-destructuring?fbclid=IwAR0hbOymSK5OI1l1Ezfks-xy1n2FH6kxC5JFcHsQ5oaFguGamme7sOtGdU8&quot;&gt;6.6 Destructuring 디스트럭처링&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://hacks.mozilla.or.kr/2015/09/es6-in-depth-destructuring/&quot;&gt;ES6 In Depth: 디스트럭처링(Destructuring)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="server" /><category term="timezone" /><summary type="html">이게 사용중이었는데도 이해를 못했다.</summary></entry><entry><title type="html">서버 시간을 KST로 변경하기</title><link href="https://lahuman.github.io/server_timezone_kst-copy/" rel="alternate" type="text/html" title="서버 시간을 KST로 변경하기" /><published>2019-07-17T00:00:00+09:00</published><updated>2019-07-17T00:00:00+09:00</updated><id>https://lahuman.github.io/server_timezone_kst copy</id><content type="html" xml:base="https://lahuman.github.io/server_timezone_kst-copy/">&lt;h1 id=&quot;서버시간을-kst로-변경하기&quot;&gt;서버시간을 KST로 변경하기&lt;/h1&gt;

&lt;p&gt;AWS의 ec2 서버를 생성하면 시간대가 UTC로 잡혀 있다.&lt;/p&gt;

&lt;p&gt;이를 KST로 변경 하기 위해서는 다음 명령을 이용하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ubuntu@ip-0-0-0-0:~/timezone$ date
Wed May 15 09:08:49 UTC 2019
ubuntu@ip-0-0-0-0:~/timezone$  cat /etc/localtime
TZif2UTCTZif2�UTC
UTC0
ubuntu@ip-0-0-0-0:~/timezone$ sudo rm /etc/localtime
ubuntu@ip-0-0-0-0:~/timezone$
ubuntu@ip-0-0-0-0:~/timezone$ sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime
ubuntu@ip-0-0-0-0:~/timezone$
ubuntu@ip-0-0-0-0:~/timezone$ date
Wed May 15 18:09:45 KST 2019
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;타임존이 다를 경우 발생하는 가장 큰 문제는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;배치 시간 문제&lt;/li&gt;
  &lt;li&gt;데이터 조회시 서버 시간 사용시 오류&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;서버-셋팅하고-나면-kst로-변경해야겠다&quot;&gt;서버 셋팅하고 나면 KST로 변경해야겠다.&lt;/h2&gt;</content><category term="server" /><category term="timezone" /><summary type="html">서버 시간 변경을 안해서 문제가 발생했다.</summary></entry></feed>

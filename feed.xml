<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2021-08-23T20:28:33+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">Google Cloud 서비스 계정으로 Google API 사용하기</title><link href="https://lahuman.github.io/googleapis/" rel="alternate" type="text/html" title="Google Cloud 서비스 계정으로 Google API 사용하기" /><published>2021-08-19T00:00:00+09:00</published><updated>2021-08-19T00:00:00+09:00</updated><id>https://lahuman.github.io/googleapis</id><content type="html" xml:base="https://lahuman.github.io/googleapis/">&lt;h1 id=&quot;google-cloud-서비스-계정으로-google-api-사용하기&quot;&gt;Google Cloud 서비스 계정으로 Google API 사용하기&lt;/h1&gt;

&lt;p&gt;Google Sheet API를 사용하기 위해서 Google cloud console에서 서비스 계정을 만들어 진행하는 과정을 정리합니다.&lt;/p&gt;

&lt;h2 id=&quot;준비-사항&quot;&gt;준비 사항&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://console.cloud.google.com/&quot;&gt;Google cloud console&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;google-cloud-console-에서-프로젝트--서비스-계정-생성-처리&quot;&gt;&lt;a href=&quot;https://console.cloud.google.com/&quot;&gt;Google cloud console&lt;/a&gt; 에서 프로젝트 &amp;amp; 서비스 계정 생성 처리&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Project&lt;/code&gt; 생성&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LEFT MENU&lt;/code&gt; » &lt;code class=&quot;highlighter-rouge&quot;&gt;APIs &amp;amp; Services&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENABLE APIS AND SERVICES.&lt;/code&gt; 클릭&lt;/li&gt;
  &lt;li&gt;API 항목에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Google Sheets API&lt;/code&gt; 활성화 처리&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LEFT MENU&lt;/code&gt; »  &lt;code class=&quot;highlighter-rouge&quot;&gt;APIs &amp;amp; Services&lt;/code&gt; » &lt;code class=&quot;highlighter-rouge&quot;&gt;Credentials&lt;/code&gt; » &lt;code class=&quot;highlighter-rouge&quot;&gt;Manage service accounts&lt;/code&gt; » &lt;code class=&quot;highlighter-rouge&quot;&gt;Create Service Accounts&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;계정 정보 입력 후 계정 생성 완료(2, 3 단계는 옵션이라 그냥 완료 하면 됩니다.)&lt;/li&gt;
  &lt;li&gt;생성된 계정(email) 정보 클릭 » &lt;code class=&quot;highlighter-rouge&quot;&gt;KEYS&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD KEY&lt;/code&gt; » &lt;code class=&quot;highlighter-rouge&quot;&gt;Create new key&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt; TYPE 선택 하여 파일 다운로드&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;첨부된 파일의 형태는 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;type&quot;: &quot;service_account&quot;,
  &quot;project_id&quot;: &quot;keen-clarity-323809&quot;,
  &quot;private_key_id&quot;: &quot;cd53576f5c47b2b654605c8a7528cabd87bdee93&quot;,
  &quot;private_key&quot;: &quot;-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQClhKfQF6zmI34T\nuetB4vZullnrXI65fkH1/YusnE/uU1rzmWPNarBqhbxzGeSJf0xedVvSW4cNavkG\nDHu3+inlbbieX9xh++2lNGpYwA5BsXPA3xD1lcaWyc71gk6V6kVtHJMFSocLCYZ/\nDCvGfYEcCiZRsrro1M6AuGy6Nug1qld7utCHJY8OwBp/KLyCmpmhXZE5qim8eul/\nLssM2QizCVxegXS3sH6BCUBZOJVVFXvfNveXc23TWvBQJP85/vaJARjVOJeNJbFQ\nObPOdvEo9RYEfmkrIaaFq/natGP/buBYLdPNnS6+x+6fKRyT5rm1q5LUrpyYKadi\nl40HJFNNAgMBAAECggEAHScTQ5SX8GT59NF/PTiTfQDgT5Ma1FMHnSMOMdXKQkjO\nMS+oI2sSLYDmo0NBPHJ+afiztoZGcDeSKt2SAOJ/9Jfxt3tc3qk3vyxPOtiA6lMt\n9x+S5h5+PtrGp/lOjBsaJVCuGHV6+Zew57mmECzUy7KB80vOnem1gXh6NgYruh/A\ntOATcB7BVk7DEDu7mUAM4BPBWb946WeCUr1L4ZD5VM8YdLAydTCGL39/6TKIDAGl\njDEe+x9IK6DTjm0JHsY9orTDzBLzMCRulOLeAIFzZxpnUnihafk/IQ9+l8SH+rkM\nc/008CMOnUpySLx6wwdCvz+TOhucW1a2RfbGYFUExQKBgQDivirN1jvMzzyQIu8U\nzaNsNPVNIMktLSUNzQEnZsMUGXBUfnAszi3OAHY6NYSEJjYMBFThIvuHqhZCUStV\nNPFTzuHx6mg5Oi4QQC8iW/x9mbeQNBsTiY/nZomgnVS8Kko2SKmINxOf1WkGFcyV\nKk+porKTIkW/m7AEsYLzby07wwKBgQC64BkyQib1sxS1hMVhP3l+A+m7OdbWLDDO\nDRJpxHNZW/Svs1egSF2wNqPZFKJ/LHwAPKxNaBCnfQMjxweDY9VzKBIwXl3boJ7m\nvRulzFsBTwRtYG9QKXYLRhvyZRHFs12XV3KISAy5X+kWG7JeZOj4jeAr0N0Qun6F\n9M+THYMTrwKBgAWTv+HIPzhOcKLq+Q598GMc+lunTst5rMumGz0o3euEpKqvYXr4\np0/F2yKbZmMJvZKWGLBg9+biXCHNdU9nOfhhwlT8+wtNTwy/R2mE8bT1LvqxDWlx\nnMSIVSJKPGdUcvba2rCrCiSIT0kDCEEzBTqa8eGEmkqYPcAfzaTHO0mZAoGADGJD\naTA3ErsuWSUWS26AZ5hsycp4cTL2fQEiwj2Rg09ztJ0G5olFJCNK0lzqs9DH2uAq\nburBh8fiCGHtHojkIUB7jBcE00Qeo53OkjsroLeSzIjCd6Z3uyGHQpXuCpLrVdcm\nsN9NcI9pi9yEAntfcPE99MlfjPc+4TOq+c3P3OMCgYB6YFCFBNpPdYqc8EkQ8OUc\nA2MDWRcCW9oKYvu2zvDLjq9zkznUMcW5PaPql1nIEfNW9LNzn/Bc3nSQ1iHaulGZ\nZjaCKdD6pftkMYC73FWIZXIsvmyC8T7TvRvFppdBHjPcSurOJi6ot74MHKhFudm6\nezS2Wh+8ABQ+ucrWUxpMOw==\n-----END PRIVATE KEY-----\n&quot;,
  &quot;client_email&quot;: &quot;sheetapi@keen-clarity-323809.iam.gserviceaccount.com&quot;,
  &quot;client_id&quot;: &quot;114733049967179666126&quot;,
  &quot;auth_uri&quot;: &quot;https://accounts.google.com/o/oauth2/auth&quot;,
  &quot;token_uri&quot;: &quot;https://oauth2.googleapis.com/token&quot;,
  &quot;auth_provider_x509_cert_url&quot;: &quot;https://www.googleapis.com/oauth2/v1/certs&quot;,
  &quot;client_x509_cert_url&quot;: &quot;https://www.googleapis.com/robot/v1/metadata/x509/sheetapi%40keen-clarity-323809.iam.gserviceaccount.com&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;동영상으로-따라-하기&quot;&gt;동영상으로 따라 하기&lt;/h3&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/pb4t5tKXe7E&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;읽거나-쓰려는-sheet에-권한-부여-하기&quot;&gt;읽거나 쓰려는 sheet에 권한 부여 하기&lt;/h3&gt;

&lt;p&gt;Google sheet에서 Share 버튼을 누른 이후, 생성한 서비스 계정에 READ/WRITE 권한을 부여 해야됩니다.&lt;/p&gt;

&lt;h2 id=&quot;sheet-글-읽기&quot;&gt;sheet 글 읽기&lt;/h2&gt;

&lt;p&gt;다음 라이브러리를 설치 해야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install –save googleapis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sheet-읽고-쓰는-예제-코드&quot;&gt;sheet 읽고 쓰는 예제 코드&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import { google, Auth } from 'googleapis';
class SheetApi {
    auth: Auth.GoogleAuth = new google.auth.GoogleAuth({
        keyFile: &quot;credentials.json&quot;, //the key file
        //url to spreadsheets API
        scopes: &quot;https://www.googleapis.com/auth/spreadsheets&quot;,
    });
    
    writeSheet() {
        //Auth client Object
        const authClientObject = await this.auth.getClient();
        //Google sheets instance
        const googleSheetsInstance = google.sheets({ version: &quot;v4&quot;, auth: authClientObject });
        const spreadsheetId = &quot;sheetId&quot;;

        //write data into the google sheets
        await googleSheetsInstance.spreadsheets.values.append({
            auth, //auth object
            spreadsheetId, //spreadsheet id
            range: &quot;Sheet1!A:B&quot;, //sheet name and range of cells
            valueInputOption: &quot;USER_ENTERED&quot;, // The information will be passed according to what the usere passes in as date, number or text
            resource: {
                values: [[&quot;첫번째 A 열 데이터&quot;, &quot;1열 B열&quot;], [&quot;두번째 A 열 데이터&quot;, &quot;2열 B열&quot;]],
            },
        });
    }

    readSheet() {
        //Auth client Object
        const authClientObject = await this.auth.getClient();
        //Google sheets instance
        const googleSheetsInstance = google.sheets({ version: &quot;v4&quot;, auth: authClientObject });
        const spreadsheetId = &quot;sheetId&quot;;

        //Read front the spreadsheet
        const { data: { values } } = await googleSheetsInstance.spreadsheets.values.get({
            auth: this.auth, //auth object
            spreadsheetId, // spreadsheet id
            range: &quot;DATA!A:B&quot;, //range of cells to read from.
        });

        return values;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.section.io/engineering-education/google-sheets-api-in-nodejs/&quot;&gt;Getting Started with Google Sheets API in Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="google" /><category term="sheet" /><summary type="html">Google Cloud 서비스 계정 생성 부터 sheet API를 활용한 조회 처리</summary></entry><entry><title type="html">onPaste contentEditable 을 이용한 이미지 붙여 넣기 처리</title><link href="https://lahuman.github.io/onPaste_contentEditable/" rel="alternate" type="text/html" title="onPaste contentEditable 을 이용한 이미지 붙여 넣기 처리" /><published>2021-08-08T00:00:00+09:00</published><updated>2021-08-08T00:00:00+09:00</updated><id>https://lahuman.github.io/onPaste_contentEditable</id><content type="html" xml:base="https://lahuman.github.io/onPaste_contentEditable/">&lt;h1 id=&quot;onpaste-contenteditable-을-이용한-이미지-붙여-넣기-처리&quot;&gt;onPaste contentEditable 을 이용한 이미지 붙여 넣기 처리&lt;/h1&gt;

&lt;p&gt;페이스북 댓글창에서 클립보드에 저장(Ctrl+C) 된 이미지를 붙여넣기(Ctrl+V)를 하면, 이미지가 업로드 되는 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이를 구현 하기 위해서는 우선 다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/onpaste&quot;&gt;HTMLElement.onpaste&lt;/a&gt; 이벤트에 대하여 알아야합니다.&lt;/p&gt;

&lt;p&gt;간단하게 요약하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;붙여넣기를 처리&lt;/code&gt;할때 호출되는 이벤트 인데요. 붙여넣는 이벤트에서 이미지일 경우 업로드 처리를 하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;구현하기&quot;&gt;구현하기&lt;/h2&gt;

&lt;p&gt;구현은 React.js기반으로 구현 하였습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import React from &quot;react&quot;;
import axios from &quot;axios&quot;;
import MockAdapter from &quot;axios-mock-adapter&quot;;
import &quot;./styles.css&quot;;

// 서버 없이 테스트를 위해서 axios-mock-adapter 사용
const mock = new MockAdapter(axios);
mock.onPost(&quot;/fileupload&quot;).reply(200, {
  seq: 1
});

// 원래 소스는 `&amp;lt;img src=&quot;/download/${seq}&quot; width=&quot;100%&quot;/&amp;gt;`;
const buildImageHtml = (seq) =&amp;gt;
  `&amp;lt;img src=&quot;https://lahuman.github.io/assets/img/logo.png&quot; width=&quot;100%&quot;/&amp;gt;`;

export default function App() {
  const comment = React.useRef();

  const fileUpload = async (blob) =&amp;gt; {
    const formData = new FormData();
    formData.append(&quot;file&quot;, blob);
    const { data: fileInfo } = await axios.post(`/fileupload`, formData);
    return fileInfo;
  };

  const focusMoveWithFile = () =&amp;gt; {
    comment.current.focus();
    if (
      typeof window.getSelection !== &quot;undefined&quot; &amp;amp;&amp;amp;
      typeof document.createRange !== &quot;undefined&quot;
    ) {
      const range = document.createRange();
      range.selectNodeContents(comment.current);
      range.collapse(false);
      const sel = window.getSelection();
      if (!sel) return;
      sel.removeAllRanges();
      sel.addRange(range);
    }
  };

  return (
    &amp;lt;div
      ref={comment}
      contentEditable=&quot;true&quot;
      className=&quot;comment&quot;
      suppressContentEditableWarning
      onPaste={async (event) =&amp;gt; {
        // event.preventDefault(); 이 없을 경우 upload와 상관 없이 이미지가 붙음
        event.preventDefault();
        const item = event.clipboardData.items[0];
        if (item.type.indexOf(&quot;image&quot;) === 0) {
          const blob = item.getAsFile();
          const { seq } = await fileUpload(blob);
          const text = `${comment.current.innerHTML}${buildImageHtml(seq)}`;
          comment.current.innerHTML = text;
          focusMoveWithFile();
        } else {
          // 이미지가 아닐 경우 text로 처리 
          const paste = event.clipboardData.getData(&quot;text&quot;);
          if (paste) {
            const selection = window.getSelection();
            if (!selection) return;
            if (selection &amp;amp;&amp;amp; !selection.rangeCount) return;
            selection?.deleteFromDocument();
            selection?.getRangeAt(0).insertNode(document.createTextNode(paste));
          }
        }
      }}
      placeholder=&quot;글을 작성해주세요 (글 작성 꿀팁 : 여기에 이미지를 Ctrl+C, Ctrl+V로 바로 붙여넣기 할 수 있어요!)&quot;
    /&amp;gt;
  );
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;예제-바로가기&quot;&gt;&lt;a href=&quot;https://codesandbox.io/s/comment-with-image-upload-tewvt?file=/src/App.js:0-2089&quot;&gt;예제 바로가기&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;기능은 생각보다 어렵지 않았고 재미있었다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/onpaste&quot;&gt;HTMLElement.onpaste&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="onpaste" /><category term="contentEditable" /><summary type="html">클립보드의 이미지를 업로드 후 화면 표기 처리</summary></entry><entry><title type="html">WSL의 서버를 host(window)에서 접근 하는 방법</title><link href="https://lahuman.github.io/wls_port_forwarding/" rel="alternate" type="text/html" title="WSL의 서버를 host(window)에서 접근 하는 방법" /><published>2021-07-28T00:00:00+09:00</published><updated>2021-07-28T00:00:00+09:00</updated><id>https://lahuman.github.io/wls_port_forwarding</id><content type="html" xml:base="https://lahuman.github.io/wls_port_forwarding/">&lt;h1 id=&quot;wsl-내에서-웹서버를-띄어서-확인이-안되는-경우-다음과-같이-처리-하여-주세요&quot;&gt;WSL 내에서 웹서버를 띄어서 확인이 안되는 경우 다음과 같이 처리 하여 주세요.&lt;/h1&gt;

&lt;p&gt;port foward를 위해서는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/networking/technologies/netsh/netsh&quot;&gt;Netsh&lt;/a&gt;를 이용할 예정입니다.&lt;/p&gt;

&lt;h2 id=&quot;1-net-tools를-wsl-안에-설치-하기&quot;&gt;1. net-tools를 WSL 안에 설치 하기&lt;/h2&gt;

&lt;p&gt;ubuntu 기준으로 다음의 명령어를 이용해서 설치 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install net-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;powser-shell-실행-파일-생성하기&quot;&gt;powser shell 실행 파일 생성하기&lt;/h2&gt;

&lt;p&gt;Netsh 설정이된 ps1 의 확장자를 가진 파일을 생성합니다.&lt;/p&gt;

&lt;p&gt;다음을 &lt;code class=&quot;highlighter-rouge&quot;&gt;network.ps1&lt;/code&gt; 이라는 파일을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &quot;Administrator&quot;)) {   
  $arguments = &quot;&amp;amp; '&quot; + $myinvocation.mycommand.definition + &quot;'&quot;
  Start-Process powershell -Verb runAs -ArgumentList $arguments
  Break
}

$remoteport = bash.exe -c &quot;ifconfig eth0 | grep 'inet '&quot;
$found = $remoteport -match '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}';

if ($found) {
  $remoteport = $matches[0];
}
else {
  Write-Output &quot;IP address could not be found&quot;;
  exit;
}

$ports = @(3000, 5500, 8080);

Invoke-Expression &quot;netsh interface portproxy reset&quot;;

for ($i = 0; $i -lt $ports.length; $i++) {
  $port = $ports[$i];
  Invoke-Expression &quot;netsh interface portproxy add v4tov4 listenport=$port connectport=$port connectaddress=$remoteport&quot;;
  Invoke-Expression &quot;netsh advfirewall firewall add rule name=$port dir=in action=allow protocol=TCP localport=$port&quot;;
}

Invoke-Expression &quot;netsh interface portproxy show v4tov4&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 중요한 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;$ports = @(3000, 5500, 8080);&lt;/code&gt; 부분입니다.&lt;/p&gt;

&lt;p&gt;forward 할 port를 작성합니다.&lt;/p&gt;

&lt;h2 id=&quot;3-실행하기&quot;&gt;3. 실행하기&lt;/h2&gt;

&lt;p&gt;powser shell에서 실행을 하면 다음과 같은 오류 메시지를 받을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $&amp;gt; .\network.ps1
.\network.ps1 : 이 시스템에서 스크립트를 실행할 수 없으므로 C:\DEV\network.ps1 파일을 로드할 수 없습니다. 자세한
내용은 about_Execution_Policies(https://go.microsoft.com/fwlink/?LinkID=135170)를 참조하십시오.
위치 줄:1 문자:1
+ .\network.ps1
+ ~~~~~~~~~~~~~
    + CategoryInfo          : 보안 오류: (:) [], PSSecurityException
    + FullyQualifiedErrorId : UnauthorizedAccess
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해결을 위해서 powser shell을 &lt;code class=&quot;highlighter-rouge&quot;&gt;관리자&lt;/code&gt; 모드로 실행하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Set-ExecutionPolicy -ExecutionPolicy RemoteSigned&lt;/code&gt; 명령어로 실행 규칙을 변경합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; Set-ExecutionPolicy -ExecutionPolicy RemoteSigned

실행 규칙 변경
실행 정책은 신뢰하지 않는 스크립트로부터 사용자를 보호합니다. 실행 정책을 변경하면 about_Execution_Policies 도움말
항목(https://go.microsoft.com/fwlink/?LinkID=135170)에 설명된 보안 위험에 노출될 수 있습니다. 실행 정책을
변경하시겠습니까?
[Y] 예(Y)  [A] 모두 예(A)  [N] 아니요(N)  [L] 모두 아니요(L)  [S] 일시 중단(S)  [?] 도움말 (기본값은 &quot;N&quot;): Y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 다시 실행하면 다음과 같이 정상 동작을 확인 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; .\network.ps1


확인됨


확인됨


확인됨


ipv4 수신 대기:             ipv4에 연결:

주소            포트        주소            포트
--------------- ----------  --------------- ----------
*               5500        192.168.254.148 5500
*               3000        192.168.254.148 3000
*               8080        192.168.254.148 8080

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-테스트&quot;&gt;4. 테스트&lt;/h2&gt;

&lt;p&gt;WSL에서 5500 포트로 웹을 띄우과 브라우져에서 접속하여 확인하면 잘 동작 하는 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.to/vishnumohanrk/wsl-port-forwarding-2e22&quot;&gt;WSL Port Forwarding&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://oyeahhh.tistory.com/170&quot;&gt;[PowerShell] Error: 이 시스템에서 스크립트를 실행할 수 없으므로 …&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="wsl" /><category term="port" /><category term="forwrding" /><summary type="html">WSL2를 사용하면서 host에서 특정 port 연결</summary></entry><entry><title type="html">면접관으로 몇 일간 면접을 보았다.</title><link href="https://lahuman.github.io/20210728/" rel="alternate" type="text/html" title="면접관으로 몇 일간 면접을 보았다." /><published>2021-07-28T00:00:00+09:00</published><updated>2021-07-28T00:00:00+09:00</updated><id>https://lahuman.github.io/20210728</id><content type="html" xml:base="https://lahuman.github.io/20210728/">&lt;h1 id=&quot;회사에-사람을-뽑기-위해서-인력을-찾고-면접을-보았습니다&quot;&gt;회사에 사람을 뽑기 위해서 인력을 찾고 면접을 보았습니다.&lt;/h1&gt;

&lt;p&gt;면접관으로 자리에 앉아있었지만, 면접보는 사람을 배려하는 시간을 가졌습니다.&lt;/p&gt;

&lt;p&gt;꼭 알맞은 사람을 찾지 못했지만, 많은 생각을 한 시간이었습니다.&lt;/p&gt;

&lt;p&gt;또 부족한 나를 다시 한번 생각하게된 시간이었습니다.&lt;/p&gt;

&lt;h2 id=&quot;나를-되돌아보는-시간이었습니다&quot;&gt;나를 되돌아보는 시간이었습니다.&lt;/h2&gt;</content><category term="단상" /><summary type="html">면접을 보는 사람을 배려하도록 노력하였다.</summary></entry><entry><title type="html">중복 객체 제거 하기</title><link href="https://lahuman.github.io/unique_object_array/" rel="alternate" type="text/html" title="중복 객체 제거 하기" /><published>2021-07-18T00:00:00+09:00</published><updated>2021-07-18T00:00:00+09:00</updated><id>https://lahuman.github.io/unique_object_array</id><content type="html" xml:base="https://lahuman.github.io/unique_object_array/">&lt;h1 id=&quot;중복-제거-하기&quot;&gt;중복 제거 하기&lt;/h1&gt;

&lt;p&gt;단순한 숫자나 문자의 중복 제거는 Set을 이용하면 간단하게 처리 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const list = ['1', '2', '3', '2', 1,2,3, 1,2,3];
// Set 을 이용한 방식
[...new Set(list)]
// filter를 이용한 방식
list.filter((item, index) =&amp;gt; list.indexOf(item) === index);
// 결과
[ '1', '2', '3', 1, 2, 3 ]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만, 객체의 중복제거의 경우는 조금 다른 방식으로 처리 해야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 중복 제거가 안됨
const list = [{a:1, b:2}, {a:2, b:1}, {a:1, b:2}];

list.filter((item, index) =&amp;gt; list.indexOf(item) === index);

// 결과 
[ { a: 1, b: 2 }, { a: 2, b: 1 }, { a: 1, b: 2 } ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;바로, JSON.stringify를 이용하는 방식입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const list = [{a:1, b:2}, {a:2, b:1}, {a:1, b:2}];

const uniqueList = [...new Set(list.map(JSON.stringify))].map(JSON.parse);
// 결과 
[ { a: 1, b: 2 }, { a: 2, b: 1 } ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 방식으로 key 값을 기준으로 unique 객체를 추출한다면 다음과 같은 방식으로도 가능합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// a의 값이 key 인경우
const list = [{a:1, b:2}, {a:2, b:1}, {a:1, b:2}];

list.filter((item, index) =&amp;gt; {
    const key = item.a;
    return index === list.findIndex((e)=&amp;gt; e.a === key);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 방식이 일반적으로 많이 쓰이는 방식 입니다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dongmin-jang.medium.com/javascript-array-%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-es6-b5b9075361f9&quot;&gt;[Javascript] array 중복 제거하는 방법(ES6)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://javascript.plainenglish.io/the-easy-way-to-create-a-unique-array-of-json-objects-in-javascript-5634254b17aa&quot;&gt;The easy way to create a unique array of JSON Objects in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="javascript" /><category term="unique" /><summary type="html">javascript array에서 중복되는 객체 제거하기</summary></entry><entry><title type="html">기술 부채 또는 발전에 대한 단상</title><link href="https://lahuman.github.io/20210716/" rel="alternate" type="text/html" title="기술 부채 또는 발전에 대한 단상" /><published>2021-07-16T00:00:00+09:00</published><updated>2021-07-16T00:00:00+09:00</updated><id>https://lahuman.github.io/20210716</id><content type="html" xml:base="https://lahuman.github.io/20210716/">&lt;h1 id=&quot;기술-부채-또는-발전에-대한-단상&quot;&gt;기술 부채 또는 발전에 대한 단상&lt;/h1&gt;

&lt;p&gt;기술 부채는 어디서올까?&lt;/p&gt;

&lt;p&gt;내 경우는 대부분 미래의 나에게 부담을 주어서 발생한다.&lt;/p&gt;

&lt;p&gt;그리고.. 오늘의(미래의)나는 과거의 나를 욕하면서 뜯어 고치거나, 무시해버린다.&lt;/p&gt;

&lt;p&gt;또 다른 경우는 동료가 나에게 서프라이즈 선물로 준다.&lt;/p&gt;

&lt;p&gt;이 또한 욕을 하면서 뜯어 고치거나, 무시해버린다.&lt;/p&gt;

&lt;p&gt;다만, 내가 발전하는 경우는 뜯고 고치는 작업에서 발생한다.&lt;/p&gt;

&lt;p&gt;나를 돌아보고, 동료와 소통하면서 발전하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;오늘도-부채를-탕감해보자&quot;&gt;오늘도 부채를 탕감해보자!&lt;/h2&gt;</content><category term="단상" /><summary type="html">최신 기술에 대하여 사용법만 인지하고 이해를 못하는 경우 발생하는 문제</summary></entry><entry><title type="html">면접 질문 모음</title><link href="https://lahuman.github.io/20210710/" rel="alternate" type="text/html" title="면접 질문 모음" /><published>2021-07-10T00:00:00+09:00</published><updated>2021-07-10T00:00:00+09:00</updated><id>https://lahuman.github.io/20210710</id><content type="html" xml:base="https://lahuman.github.io/20210710/">&lt;h1 id=&quot;면접-질문들-모음&quot;&gt;면접 질문들 모음&lt;/h1&gt;

&lt;p&gt;최근 5년동안 받아본 면접 질문들을 정리 해보았습니다.&lt;/p&gt;

&lt;iframe width=&quot;768&quot; height=&quot;432&quot; src=&quot;https://miro.com/app/live-embed/o9J_l8V6DoI=/?moveToViewport=-1414,-2127,3847,1803&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;질문에 대답을 잘 못한 것도 있고, 새로운 사실을 알아가기도 합니다.&lt;/p&gt;

&lt;p&gt;면접 또한 많이 배우는 경험이됩니다.&lt;/p&gt;</content><category term="단상" /><summary type="html">지금까지 받아보았던 몇가지 면접 질문들을 정리 했습니다.</summary></entry><entry><title type="html">동시성, 컨커런시, LOCK, 메모리, 모니터링 메트릭스</title><link href="https://lahuman.github.io/20210706/" rel="alternate" type="text/html" title="동시성, 컨커런시, LOCK, 메모리, 모니터링 메트릭스" /><published>2021-07-06T00:00:00+09:00</published><updated>2021-07-06T00:00:00+09:00</updated><id>https://lahuman.github.io/20210706</id><content type="html" xml:base="https://lahuman.github.io/20210706/">&lt;h1 id=&quot;오늘-몇가지-질문을-받았는데-명확하게-이야기-하지-못했다&quot;&gt;오늘 몇가지 질문을 받았는데, 명확하게 이야기 하지 못했다.&lt;/h1&gt;

&lt;h3 id=&quot;첫번째-질문-동시성-컨커런시-lock&quot;&gt;첫번째 질문, 동시성, 컨커런시, LOCK&lt;/h3&gt;

&lt;p&gt;동시성, 컨커런시, LOCK 관련 질문을 많이 받았는데, 사실 크게 신경쓰지 않고 프로그램을 했었다.
왜냐고 묻는다면, 좋은 프레임워크들과 모듈들이 잘 관리 해주니 내가 신경쓸 일은 없었다.&lt;/p&gt;

&lt;p&gt;직접 Thread를 생성하고 프로그램을 짤던 10여년 전에는 synchronized를 이용해서 관리했었지만, 지금은 사실 Singleton 생성할때 말고는 써보지 않았다.&lt;/p&gt;

&lt;p&gt;그리고 가능하면 공유 자원을 최소화 하는 방식으로 개발을 하고 있다.&lt;/p&gt;

&lt;p&gt;병렬성에서 중요한건 실수를 줄일 수 있고 관심에 분리를 하는 환경을 만들어 주어야 한다.&lt;/p&gt;

&lt;p&gt;일일이 동시성과 LOCK을 걸면서 프로그램을 한다면 생각보다 비효율적일꺼 같은데 그리고 어떤 경우에 그런게 필요할까?&lt;/p&gt;

&lt;p&gt;곰곰히 생각해봤는데, 실제 Thread를 관리하고 병렬처리를 하는 프로그램을 만들어야 한다면 필요하겠다.&lt;/p&gt;

&lt;p&gt;내가 경험한 웹에서는 Connection Pool, 상수, Singleton 생성 등을 제외 하면 사용이 극히 제한적이다.&lt;/p&gt;

&lt;p&gt;또 Spring 을 쓴다면 기본적으로 객체에 대한 관리는 framework에서 해주기에 크게 신경을 쓰지 않도록 해준다.&lt;/p&gt;

&lt;p&gt;물론 내가 알지 못하는 부분에서 활발하게 쓰일수 있다. 예제 코드를 좀 찾아봐야겠다.&lt;/p&gt;

&lt;h3 id=&quot;두번째-질문-메모리&quot;&gt;두번째 질문 메모리&lt;/h3&gt;

&lt;p&gt;APP과 OS의 메모리를 실제로 덤프를 뜨거나, 확인한 적이 있는가의 질문이었다.&lt;/p&gt;

&lt;p&gt;잘해야 OOM 발생으로 메모리 스택트레이스 정도 확인해본 경험이 전부다.&lt;/p&gt;

&lt;p&gt;좀더 곰곰히 생각하면 메모리 덤프를 스냅샷으로 파일로 떨구서 본 기억이 있는 정도이다.&lt;/p&gt;

&lt;p&gt;문제가 있는것도 아니고 잘 돌아가는 상황에서 확인할 여유도 이유도 없었다.&lt;/p&gt;

&lt;p&gt;추가로 모니터링 프로그램을 통해서 메모리에 대한 정보를 확인한 경험도 있다.&lt;/p&gt;

&lt;p&gt;이 부분은 질문자와 의견이 많이 달랐는데, 이걸 모르면 안된다고 생각한다고 했다.&lt;/p&gt;

&lt;p&gt;난 조금 다르게 느끼는게 알면 좋겠지만, 몰라도 문제가 되지 않는다.&lt;/p&gt;

&lt;p&gt;그리고 알고 있다면 더 좋은 픔질의 프로그램을 짤 수 있을까?&lt;/p&gt;

&lt;p&gt;어느 영역에서 일하느냐에 따라 다르게 받아 들일 수 있을것이다.&lt;/p&gt;

&lt;h3 id=&quot;모니터링-메트릭스&quot;&gt;모니터링 메트릭스&lt;/h3&gt;

&lt;p&gt;모니터링이 필요한 요소는 무엇이 있을까?&lt;/p&gt;

&lt;p&gt;기본적인 항목으로는 서버의 리소스 &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU, 메모리, 디스크, 네트워크, 프로세스&lt;/code&gt;가 있을꺼라 생각한다.&lt;/p&gt;

&lt;p&gt;사실 이 질문은 잘 이해 못했다. 정확하게 뭘 원하는 건지, 뭘 생각하는건지 모르겠다.&lt;/p&gt;

&lt;p&gt;모니터링 서비스를 만든 적이 없는 사람에게 생각나는데로 이야기 해보라는게 의미 있을까?&lt;/p&gt;

&lt;h3 id=&quot;nodejs-는-싱글쓰레드인가&quot;&gt;NODEJS 는 싱글쓰레드인가?&lt;/h3&gt;

&lt;p&gt;내 대답은 아니오 였다.&lt;/p&gt;

&lt;p&gt;싱글 쓰레드가 아니라 이벤트 루프가 싱글 쓰레드이다.
이벤트 루프가 워커 쓰레드가에게 처리할 것을 전달하고 다음 이벤트를 처리 한다.&lt;/p&gt;

&lt;p&gt;작년에 보았던 자료를 토대로 이야기 했는데, 그럼 동시성 처리는 어떻게 하냐는 질문을 받았다.
대답을 못했는데 &lt;a href=&quot;https://hdaleee.tistory.com/15&quot;&gt;Node.js는 싱글스레드인가요?&lt;/a&gt; 에서 다음과 같은 내용을 찾았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;node.js 자체는 single-thread 방식이 아니다. 자바스크립트를 실행하는 부분에서만 single-thread로 구성되어있고, 이 때의 작업 동시성은 ‘이벤트 루프’를 통해서 구현할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이부분은 질문자도 잘 모르고, 나도 정확히 몰라서 나중에 검색해 본다고 하고 넘어갔다.&lt;/p&gt;

&lt;h3 id=&quot;마지막으로&quot;&gt;마지막으로&lt;/h3&gt;

&lt;p&gt;오늘 질문자와 이야기는 나름 재미있었다.(땀이 나기도 했지만)&lt;/p&gt;

&lt;p&gt;다만, 질문자의 공격성이 아쉬었다.&lt;/p&gt;

&lt;p&gt;본인이 14년 경력이 개발자로 상위 몇%라고 생각되느냐는 질문은 &lt;strong&gt;사실 주관적인 질문이기 때문에 본인의 생각과 달라 질수 있다고 생각된다.&lt;/strong&gt;
(내 자존감을 깍아 내려서 무엇을 하려고 하는지도 모르겠다.)&lt;/p&gt;

&lt;p&gt;물론 질문자가 받아 들이지 못하면 그것도 그것대로 이겠지만, 그런 사람과 일하는건 피곤할 것이다.&lt;/p&gt;

&lt;p&gt;누구나 잘하는 부분과 못하는 부분이 있다. 나는 평범한 사람으로 꽤나 노력하고 있고 열심히 살고 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;누군가에게 부족해 보일 수도 있고, 모자르게 보일수도 있겠지만, 단편적인 부분을 보고 사람을 판단해서는 안된다.&lt;/p&gt;

&lt;p&gt;또한 적어도 사람과 사람 사이의 예의는 지켜야 한다.&lt;/p&gt;</content><category term="단상" /><summary type="html">크게 신경을 쓰지 못했던 부분에 대하여 다시 생각하는 날</summary></entry><entry><title type="html">Raspberry pi 4에 windows 11 설치</title><link href="https://lahuman.github.io/raspberry_windows11/" rel="alternate" type="text/html" title="Raspberry pi 4에 windows 11 설치" /><published>2021-07-05T00:00:00+09:00</published><updated>2021-07-05T00:00:00+09:00</updated><id>https://lahuman.github.io/raspberry_windows11</id><content type="html" xml:base="https://lahuman.github.io/raspberry_windows11/">&lt;h1 id=&quot;raspberry-pi-4에-windows-11을-설치해서-사용해봤습니다&quot;&gt;Raspberry pi 4에 windows 11을 설치해서 사용해봤습니다.&lt;/h1&gt;

&lt;p&gt;집에 있는 삼성 프린터가 네트워크를 지원하지 않아서, 방안을 고심중에 Raspberry PI 4에 windows 11이 설치되고 상당히 쓸만 하다는 글을 읽게 되었습니다.&lt;/p&gt;

&lt;p&gt;설치는 &lt;a href=&quot;https://www.tomshardware.com/how-to/install-windows-11-raspberry-pi&quot;&gt;How to Install Windows 11 on a Raspberry Pi 4&lt;/a&gt; 글을 따라하면 쉽게 가능합니다.&lt;/p&gt;

&lt;p&gt;그리고 장점과 단점으로 구분해서 후기를 정리 하면 다음과 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;생각보다 빠릿(?)하다
    &lt;ul&gt;
      &lt;li&gt;느리다는 느낌이 들지 않습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;부팅이 정말 오래 걸린다.
    &lt;ul&gt;
      &lt;li&gt;Raspberry pi 4G 기준으로 약 5분 정도 걸립니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사운드는 해드셋 잭으로만 나온다.&lt;/li&gt;
  &lt;li&gt;다이소 wifi 모듈 인식이 안된다.
    &lt;ul&gt;
      &lt;li&gt;이게 가장 크리티컬하네요.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;원격 데스크탑(서버) 지원이 안된다.
    &lt;ul&gt;
      &lt;li&gt;프리뷰모드라 그런듯 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;삼성 드라이버 설치가 안된다.
    &lt;ul&gt;
      &lt;li&gt;ARM CPU라 그런지, windows 11이라 그런지, 제가 원한 가장 중요한 기능이 안되네요. :(&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프리뷰 버젼이니 완성도가 떨어져서 안되는게 있을꺼라 생각됩니다.
정식 버젼이 나오면 다시 테스트 해봐야겠네요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.tomshardware.com/how-to/install-windows-11-raspberry-pi&quot;&gt;How to Install Windows 11 on a Raspberry Pi 4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="raspberry" /><category term="windows" /><summary type="html">잠시 사용해본 후기 입니다.</summary></entry><entry><title type="html">서비스 종료일</title><link href="https://lahuman.github.io/20210701/" rel="alternate" type="text/html" title="서비스 종료일" /><published>2021-07-01T00:00:00+09:00</published><updated>2021-07-01T00:00:00+09:00</updated><id>https://lahuman.github.io/20210701</id><content type="html" xml:base="https://lahuman.github.io/20210701/">&lt;h1 id=&quot;2019년에-입사를-해서-지금까지-30여개의-서비스를-만들었습니다&quot;&gt;2019년에 입사를 해서 지금까지 30여개의 서비스를 만들었습니다.&lt;/h1&gt;

&lt;p&gt;회사내의 문제를 발견하고 작게 만들어서 빠르게 실패하고, 다시 만드는 디자인 싱킹과 애자일 기반의 활동을 하였습니다.&lt;/p&gt;

&lt;p&gt;물론 매 2주안에 결과를 내야 하는 스크럼 진행으로 가끔은 너무 지치고 힘들었습니다.&lt;/p&gt;

&lt;p&gt;오늘 회사 합병과 개인 업무 재분배, 팀 이동 등의  이유로 그 동안 만들었던 서비스 중 사용자가 적은 서비스를 종료 하는 날이 왔습니다.&lt;/p&gt;

&lt;p&gt;자식을 잃는 기분이네요.&lt;/p&gt;

&lt;p&gt;더 발전 시킬 수 있는데, 더 잘 만들 수 있는데, 충분히 매력적인 서비스인데…&lt;/p&gt;

&lt;p&gt;아쉽고, 슬픈 하루입니다.&lt;/p&gt;

&lt;h2 id=&quot;잘가-그리고-너희를-만들면서-즐거웠어&quot;&gt;잘가 그리고 너희를 만들면서 즐거웠어.&lt;/h2&gt;

&lt;h2 id=&quot;ps-75-업데이트-상황&quot;&gt;PS. 7/5 업데이트 상황&lt;/h2&gt;

&lt;p&gt;사용자가 적지만, 꼭 필요한 서비스라고 연락이 와서 다시 살리는 서비스도 있었습니다. :)&lt;/p&gt;</content><category term="단상" /><summary type="html">3년간 만들었던 서비스 중 몇개가 종료되는 날입니다.</summary></entry></feed>

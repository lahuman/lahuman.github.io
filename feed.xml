<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2019-05-23T23:42:17+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">NodeJs에서 Parse Error: HPE_HEADER_OVERFLOW 발생</title><link href="https://lahuman.github.io/nodejs_HEP_HEADER_OVERFLOW/" rel="alternate" type="text/html" title="NodeJs에서 Parse Error: HPE_HEADER_OVERFLOW 발생" /><published>2019-05-18T00:00:00+09:00</published><updated>2019-05-18T00:00:00+09:00</updated><id>https://lahuman.github.io/nodejs_HEP_HEADER_OVERFLOW</id><content type="html" xml:base="https://lahuman.github.io/nodejs_HEP_HEADER_OVERFLOW/">&lt;h1 id=&quot;nodejs에서-parse-error-hpe_header_overflow-발생&quot;&gt;NodeJs에서 Parse Error: HPE_HEADER_OVERFLOW 발생&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/x-ray&quot;&gt;x-ray(node moudle)&lt;/a&gt;를 이용해서 크롤링을 개발하고 있던 중, 다음과 같은 오류를 만나게 되었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(node:63533) UnhandledPromiseRejectionWarning: Error: Parse Error
    at Socket.socketOnData (_http_client.js:442:20)
    at Socket.emit (events.js:189:13)
    at addChunk (_stream_readable.js:284:12)
    at readableAddChunk (_stream_readable.js:265:11)
    at Socket.Readable.push (_stream_readable.js:220:10)
    at TCP.onStreamRead (internal/stream_base_commons.js:94:17)
     bytesParsed: 6545,
  code: 'HPE_HEADER_OVERFLOW',
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 오류는 3개의 사이트중 1개의 사이트에서만 발생하였다.&lt;/p&gt;

&lt;p&gt;원인을 파악하기 위해 검색을 하다 다음과 같은 내용을 확인하였다.&lt;/p&gt;

&lt;p&gt;Node.js의 http 80KB의 Header 크기 제한을 가지고 있고 만약 큰 Header 크기가 필요 하다면, 명령을 실행시 특정 argument를 추가 해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;해결책은-다음과-같다&quot;&gt;해결책은 다음과 같다!&lt;/h3&gt;

&lt;p&gt;실행하는 node 명령와 함께 &lt;strong&gt;–max-http-header-size=크기&lt;/strong&gt; argument를 추가 해라&lt;/p&gt;

&lt;p&gt;예제)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; node --max-http-header-size=81000 app.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;에러가 안날때 까지 최대 http header 크기를 키우면 된다.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;근데… 이건 에러나는 사이트가 문제 아닌가? 80KB를 넘는 헤더를 왜 넘기지??&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Azure/azure-cosmos-js/issues/221&quot;&gt;Trying to query documents results in a Parse Error: HPE_HEADER_OVERFLOW #221&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/35328725/hpe-header-overflow-exception-when-make-http-request/35330480#35330480&quot;&gt;HPE_HEADER_OVERFLOW exception when make http.request&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/nodejs/http-parser/blob/678a9e21f11e5ea93e5e17a2302390f88a6a8c46/http_parser.h#L64&quot;&gt;nodejs/http-parser&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/x-ray&quot;&gt;x-ray(node moudle)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="error" /><category term="nodejs" /><summary type="html">처음 보는 에러가 발생하였다.</summary></entry><entry><title type="html">Google Docs Sheets 연동 하기</title><link href="https://lahuman.github.io/google_sheet_api/" rel="alternate" type="text/html" title="Google Docs Sheets 연동 하기" /><published>2019-05-15T00:00:00+09:00</published><updated>2019-05-15T00:00:00+09:00</updated><id>https://lahuman.github.io/google_sheet_api</id><content type="html" xml:base="https://lahuman.github.io/google_sheet_api/">&lt;h1 id=&quot;google-docs-sheets-연동-하기&quot;&gt;google docs Sheets 연동 하기&lt;/h1&gt;

&lt;p&gt;이번에 진행되는 프로젝트에서 데이터를 Google Docs의 Sheets에 넣어 두고 해당 데이터를 활용하여 대시보드를 구현하게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/sheets/guides/concepts?hl=ko&quot;&gt;Google Sheets API 소개&lt;/a&gt;에도 잘 나와 있듯이, API를 활용하여 쉽게 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/sheets/api/quickstart/nodejs&quot;&gt;Node.js Quickstart&lt;/a&gt;에서 제공되는 소스는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const fs = require('fs');
const readline = require('readline');
const {google} = require('googleapis');

// If modifying these scopes, delete token.json.
const SCOPES = ['https://www.googleapis.com/auth/spreadsheets.readonly'];
// The file token.json stores the user's access and refresh tokens, and is
// created automatically when the authorization flow completes for the first
// time.
const TOKEN_PATH = 'token.json';

// Load client secrets from a local file.
fs.readFile('credentials.json', (err, content) =&amp;gt; {
  if (err) return console.log('Error loading client secret file:', err);
  // Authorize a client with credentials, then call the Google Sheets API.
  authorize(JSON.parse(content), listMajors);
});

/**
 * Create an OAuth2 client with the given credentials, and then execute the
 * given callback function.
 * @param {Object} credentials The authorization client credentials.
 * @param {function} callback The callback to call with the authorized client.
 */
function authorize(credentials, callback) {
  const {client_secret, client_id, redirect_uris} = credentials.installed;
  const oAuth2Client = new google.auth.OAuth2(
      client_id, client_secret, redirect_uris[0]);

  // Check if we have previously stored a token.
  fs.readFile(TOKEN_PATH, (err, token) =&amp;gt; {
    if (err) return getNewToken(oAuth2Client, callback);
    oAuth2Client.setCredentials(JSON.parse(token));
    callback(oAuth2Client);
  });
}

/**
 * Get and store new token after prompting for user authorization, and then
 * execute the given callback with the authorized OAuth2 client.
 * @param {google.auth.OAuth2} oAuth2Client The OAuth2 client to get token for.
 * @param {getEventsCallback} callback The callback for the authorized client.
 */
function getNewToken(oAuth2Client, callback) {
  const authUrl = oAuth2Client.generateAuthUrl({
    access_type: 'offline',
    scope: SCOPES,
  });
  console.log('Authorize this app by visiting this url:', authUrl);
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  rl.question('Enter the code from that page here: ', (code) =&amp;gt; {
    rl.close();
    oAuth2Client.getToken(code, (err, token) =&amp;gt; {
      if (err) return console.error('Error while trying to retrieve access token', err);
      oAuth2Client.setCredentials(token);
      // Store the token to disk for later program executions
      fs.writeFile(TOKEN_PATH, JSON.stringify(token), (err) =&amp;gt; {
        if (err) return console.error(err);
        console.log('Token stored to', TOKEN_PATH);
      });
      callback(oAuth2Client);
    });
  });
}

/**
 * Prints the names and majors of students in a sample spreadsheet:
 * @see https://docs.google.com/spreadsheets/d/1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms/edit
 * @param {google.auth.OAuth2} auth The authenticated Google OAuth client.
 */
function listMajors(auth) {
  const sheets = google.sheets({version: 'v4', auth});
  sheets.spreadsheets.values.get({
    spreadsheetId: '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms',
    range: 'Class Data!A2:E',
  }, (err, res) =&amp;gt; {
    if (err) return console.log('The API returned an error: ' + err);
    const rows = res.data.values;
    if (rows.length) {
      console.log('Name, Major:');
      // Print columns A and E, which correspond to indices 0 and 4.
      rows.map((row) =&amp;gt; {
        console.log(`${row[0]}, ${row[4]}`);
      });
    } else {
      console.log('No data found.');
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참 좋은 세상이다!&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/sheets/guides/concepts?hl=ko&quot;&gt;Google Sheets API 소개&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/sheets/api/quickstart/nodejs&quot;&gt;Node.js Quickstart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="sheets" /><category term="google" /><summary type="html">Google Docs Sheets를 이용하면 DB도 필요 없겠다!!</summary></entry><entry><title type="html">express에서 File Upload 구현 하기</title><link href="https://lahuman.github.io/express_fileupload/" rel="alternate" type="text/html" title="express에서 File Upload 구현 하기" /><published>2019-05-12T00:00:00+09:00</published><updated>2019-05-12T00:00:00+09:00</updated><id>https://lahuman.github.io/express_fileupload</id><content type="html" xml:base="https://lahuman.github.io/express_fileupload/">&lt;h1 id=&quot;express에서-file-upload-구현-하기&quot;&gt;express에서 File Upload 구현 하기&lt;/h1&gt;

&lt;p&gt;업로드는 복잡하게 구현 하지 않고 모듈을 사용하면 쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/express-fileupload&quot;&gt;express-fileupload&lt;/a&gt;를 이용하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# express 의 app.js 에서 다음과 같이 사용 
const fileUpload = require('express-fileupload');
const cors = require('cors');
const fs = require('fs');

app.use(cors());
app.use(fileUpload());

app.post('/upload', (req, res, next) =&amp;gt; {
  let uploadFile = req.files.file
  const fileName = req.files.file.name
  uploadFile.mv(
    `${__dirname}/public/files/${fileName}`,
    function (err) {
      if (err) {
        return res.status(500).send(err);
      }

      res.json(JSON.parse(fs.readFileSync(`${__dirname}/public/files/${fileName}`, 'utf8')));
    }
  );
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그게 어렵지 않게 한다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/express-fileupload&quot;&gt;express-fileupload&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="upload" /><category term="express" /><summary type="html">업로드</summary></entry><entry><title type="html">express에서 stream을 이용하여 파일 다운로드 하기</title><link href="https://lahuman.github.io/express_filedownload/" rel="alternate" type="text/html" title="express에서 stream을 이용하여 파일 다운로드 하기" /><published>2019-05-09T00:00:00+09:00</published><updated>2019-05-09T00:00:00+09:00</updated><id>https://lahuman.github.io/express_filedownload</id><content type="html" xml:base="https://lahuman.github.io/express_filedownload/">&lt;h1 id=&quot;express에서-stream을-이용하여-파일-다운로드-하기&quot;&gt;express에서 stream을 이용하여 파일 다운로드 하기&lt;/h1&gt;

&lt;p&gt;파일다운로드를 하기위해서는 스트림을 이용해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const mime = require('mime-types');

// set header for download
let mimeType = mime.lookup('news_20190501.pdf');
res.setHeader('Content-disposition', 'attachment; filename=' + 'news_20190501.pdf');
res.setHeader('Content-type', mimeType);
fs.createReadStream(__basedir + '/public/files/download/pdf/news_20190501.pdf').pipe(res);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 하면 파일을 스트림을 통해서 다운로드할수 있다.&lt;/p&gt;

&lt;h2 id=&quot;같이-일하는-분이-알려주심&quot;&gt;같이 일하는 분이 알려주심!&lt;/h2&gt;</content><category term="download" /><category term="express" /><summary type="html">다운로드!</summary></entry><entry><title type="html">nodejs package.json의 모듈 업데이트 하기!</title><link href="https://lahuman.github.io/node_package.json_update/" rel="alternate" type="text/html" title="nodejs package.json의 모듈 업데이트 하기!" /><published>2019-05-03T00:00:00+09:00</published><updated>2019-05-03T00:00:00+09:00</updated><id>https://lahuman.github.io/node_package.json_update</id><content type="html" xml:base="https://lahuman.github.io/node_package.json_update/">&lt;h1 id=&quot;nodejs-packagejson의-모듈-업데이트-하기&quot;&gt;nodejs package.json의 모듈 업데이트 하기!&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/npm-check-updates&quot;&gt;npm-check-updates&lt;/a&gt;을 이용하여 package.json에 등록된 모듈들을 의존성에 알맞게 최신 버젼으로 업데이트 할 수 있다.&lt;/p&gt;

&lt;p&gt;설치 후 실행은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# global로 npm-check-updates 설치
$&amp;gt; npm i -g npm-check-updates
# 프로젝트(package.json과 동일한) 디렉토리에서 다음 명령어 실행
$&amp;gt; ncu -u
Upgrading /Users/admin/myProject/package.json
[====================] 17/17 100%

 app-root-path     ^2.1.0  →   ^2.2.1
 cookie-parser     ~1.4.3  →   ~1.4.4
 debug             ~2.6.9  →   ~4.1.1
 dotenv            ^7.0.0  →   ^8.0.0
 express          ~4.16.0  →  ~4.16.4
 express-session  ^1.15.6  →  ^1.16.1
 helmet           ^3.16.0  →  ^3.17.0
 http-errors       ~1.6.2  →   ~1.7.2
 morgan            ~1.9.0  →   ~1.9.1
 puppeteer        ^1.13.0  →  ^1.15.0

Run npm install to install new versions.

# 업데이트된 결과를 설치
$&amp;gt; npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자주는 아니더라도, 가끔씩은 모듈을 업데이트 하자!&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/16073603/how-do-i-update-each-dependency-in-package-json-to-the-latest-version&quot;&gt;How do I update each dependency in package.json to the latest version?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/npm-check-updates&quot;&gt;npm-check-updates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="update" /><summary type="html">업데이트는 한번씩 해줘야지!</summary></entry><entry><title type="html">Reactjs] Create-react-app 시작하기</title><link href="https://lahuman.github.io/create_reactjs/" rel="alternate" type="text/html" title="Reactjs] Create-react-app 시작하기" /><published>2019-05-02T00:00:00+09:00</published><updated>2019-05-02T00:00:00+09:00</updated><id>https://lahuman.github.io/create_reactjs</id><content type="html" xml:base="https://lahuman.github.io/create_reactjs/">&lt;h1 id=&quot;reactjs-create-react-app-시작하기&quot;&gt;Reactjs] Create-react-app 시작하기&lt;/h1&gt;

&lt;p&gt;reactjs 시작은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; npx create-react-app my-app
$&amp;gt; cd my-app
$&amp;gt; npm start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 명령어를 실행하여 기본 react 구조와 모듈이 포함된 프로젝트를 생성한다. 생성된 프로젝트의 구조는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my-app
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    └── serviceWorker.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 프로젝트에 router, design 관련 모듈들을 추가 해서 반영하면된다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://facebook.github.io/create-react-app/docs/getting-started&quot;&gt;Getting Started&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="reactjs" /><category term="frontend" /><summary type="html">Reactjs로 UI 개발 시작 하기</summary></entry><entry><title type="html">입사 5개월차 후기</title><link href="https://lahuman.github.io/20190430/" rel="alternate" type="text/html" title="입사 5개월차 후기" /><published>2019-04-30T00:00:00+09:00</published><updated>2019-04-30T00:00:00+09:00</updated><id>https://lahuman.github.io/20190430</id><content type="html" xml:base="https://lahuman.github.io/20190430/">&lt;h1 id=&quot;puppeteer에서-post로-요청&quot;&gt;puppeteer에서 POST로 요청&lt;/h1&gt;

&lt;p&gt;기본적으로 오래된 조직은 하향평준화가 된다고 한다.&lt;/p&gt;

&lt;p&gt;지금 팀은 상향평준화를 위해 많은 노력을 한다.&lt;/p&gt;

&lt;p&gt;코드리뷰, 페어코딩, 쇼미더코딩, CI/CD 구축 이라던지, 외국 컨퍼런스 참가 및 여러 활동을 지원 한다.&lt;/p&gt;

&lt;p&gt;하지만 팀에 적응 못하거나, 힘들어 하는 인력은 교체한다. 입사하고 5개월 동안 4분 정도 다른팀으로 이동하셨고, 다른팀에 가신분들은 새로운 팀에 잘 적응하고 있다.&lt;/p&gt;

&lt;p&gt;팀원들간에 건전한 경쟁을 하고 있으며, 늘 새로운 것을 익히고 업무에 반영해본다.
(팀에 오래 계신 분들일 수록 실력이 좋다.)&lt;/p&gt;

&lt;p&gt;처음 입사하고는 한달간 정신이 없었다. 힘들기도 하고 너무 빠르게 변하는 팀에 적응을 못하였다.&lt;/p&gt;

&lt;p&gt;지난 5개월을 돌이켜 보면 최근 5년 중 가장 많이 발전하고 변화하고 있다.&lt;/p&gt;

&lt;p&gt;R을 이용해 동시 단어출현 분석도 구현해 보고, 형태소 분석기를 설치해 다른 팀원이 사용할수 있게 구성해 보기도 하고, AWS의 LAMBDA, EC2, RDS등 여러 경험을 했다.&lt;/p&gt;

&lt;p&gt;얼마 전 새로운 분들을 모시기 위해 이력서를 받아 코딩 테스트를 진행하였다.
실력 좋은 분들이 많이 지원해 주셨고, 조만간 출근 하시는 분도 계신다.&lt;/p&gt;

&lt;p&gt;많이 기대가 된다.&lt;/p&gt;</content><category term="단상" /><summary type="html">상향 평준화를 위해서...</summary></entry><entry><title type="html">puppeteer에서 POST로 요청 날리기</title><link href="https://lahuman.github.io/puppeteer_post_request/" rel="alternate" type="text/html" title="puppeteer에서 POST로 요청 날리기" /><published>2019-04-25T00:00:00+09:00</published><updated>2019-04-25T00:00:00+09:00</updated><id>https://lahuman.github.io/puppeteer_post_request</id><content type="html" xml:base="https://lahuman.github.io/puppeteer_post_request/">&lt;h1 id=&quot;puppeteer에서-post로-요청-날리기&quot;&gt;puppeteer에서 POST로 요청 날리기&lt;/h1&gt;

&lt;p&gt;puppeteer에서 request를 POST로 요청 하기 위해서는 다음과 같은 설정을 해야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;await page.setRequestInterception(true);
// create a flag to only modify the initial request
let reformatFirstRequest = true;

page.on('request', interceptedRequest =&amp;gt; {
  if (reformatFirstRequest) {
    console.log('first-request');
    reformatFirstRequest = false;
    interceptedRequest.continue({
      method: 'POST',
      postData: JSON.stringify(data),
      headers: { 'Content-Type': 'application/json' }
    });
  } else {
    interceptedRequest.continue();
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;interceptedRequest 를 한번만 하지 않으면 이후 해당 request에 대한 404 오류가 떨어질 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;끗&quot;&gt;끗~&lt;/h4&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/issues/669&quot;&gt;Send POST request to a page and take screenshot #669&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="pupeteer" /><category term="post" /><summary type="html">쉬울꺼라 생각했는데 쉽지 않았음</summary></entry><entry><title type="html">nodejs port forwarding 처리</title><link href="https://lahuman.github.io/nodejs_port_forwarding/" rel="alternate" type="text/html" title="nodejs port forwarding 처리" /><published>2019-04-23T00:00:00+09:00</published><updated>2019-04-23T00:00:00+09:00</updated><id>https://lahuman.github.io/nodejs_port_forwarding</id><content type="html" xml:base="https://lahuman.github.io/nodejs_port_forwarding/">&lt;h1 id=&quot;nodejs-port-forwarding-처리&quot;&gt;nodejs port forwarding 처리&lt;/h1&gt;

&lt;p&gt;https를 설정하고 나니, 기존 80 포트로 요청이 있을 경우, 443으로 redirect 하는 방법을 찾아보았다.&lt;/p&gt;

&lt;p&gt;구글을 확인해보니, 다음과 같이 쉽게 처리 할 수 있었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Redirect from http port 80 to https
var http = require('http');
http.createServer(function (req, res) {
    res.writeHead(301, { &quot;Location&quot;: &quot;https://&quot; + req.headers['host'] + req.url });
    res.end();
}).listen(80);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;구글과-함께면-뭐든-쉽다&quot;&gt;구글과 함께면 뭐든 쉽다.&lt;/h4&gt;

&lt;h2 id=&quot;참조-링크&quot;&gt;참조 링크&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7450940/automatic-https-connection-redirect-with-node-js-express&quot;&gt;Automatic HTTPS connection/redirect with node.js/express&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="port" /><category term="nodejs" /><summary type="html">http로 접근시 https로 이동 시키자!</summary></entry><entry><title type="html">nodejs를 이용하여 web push 몇가지 주요 사항</title><link href="https://lahuman.github.io/web_push_with_nodejs_sometings/" rel="alternate" type="text/html" title="nodejs를 이용하여 web push 몇가지 주요 사항" /><published>2019-04-22T00:00:00+09:00</published><updated>2019-04-22T00:00:00+09:00</updated><id>https://lahuman.github.io/web_push_with_nodejs_sometings</id><content type="html" xml:base="https://lahuman.github.io/web_push_with_nodejs_sometings/">&lt;h1 id=&quot;web-push-구현하기&quot;&gt;web push 구현하기&lt;/h1&gt;

&lt;p&gt;web push를 구현하기 위해서 &lt;a href=&quot;https://www.npmjs.com/package/web-push&quot;&gt;web-push&lt;/a&gt;라는 모듈을 사용해야 한다.&lt;/p&gt;

&lt;p&gt;구현 방법은 &lt;a href=&quot;https://thecodebarbarian.com/sending-web-push-notifications-from-node-js.html&quot;&gt;Sending Web Push Notifications from Node.js&lt;/a&gt;을 참고 하면 된다.
(추후 시간을 내어 코드를 정리해보려고 한다.)&lt;/p&gt;

&lt;p&gt;오늘은 일단 중요한 몇가지 사항을 공유 하려고 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;windows에서는 알람을 활성하 해두어야 알람을 받을 수 있다.&lt;/li&gt;
  &lt;li&gt;실제 서비스는 https만 가능하며, 인증서 또한 공식 인증서를 이용해야 된다.&lt;/li&gt;
  &lt;li&gt;subscription 정보를 잘 관리 하면 계속 상대방이 차단하기 전까지 계속 알람을 보낼 수 있다.&lt;/li&gt;
  &lt;li&gt;동작 원리는 worker를 등록하여 상대방에게 push를 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;일단 오늘은 여기까지!!!&lt;/p&gt;

&lt;h2 id=&quot;참조-링크&quot;&gt;참조 링크&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://thecodebarbarian.com/sending-web-push-notifications-from-node-js.html&quot;&gt;Sending Web Push Notifications from Node.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/web-push&quot;&gt;web-push&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="webpush" /><category term="nodejs" /><summary type="html">web push 모듈을 테스트 하면서 얻은 몇가지 사항 공유</summary></entry></feed>

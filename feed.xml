<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2018-02-13T10:19:59+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">신기한 Elasticsearch의 세계</title><link href="https://lahuman.github.io/20180213-phase/" rel="alternate" type="text/html" title="신기한 Elasticsearch의 세계" /><published>2018-02-13T00:00:00+09:00</published><updated>2018-02-13T00:00:00+09:00</updated><id>https://lahuman.github.io/20180213-phase</id><content type="html" xml:base="https://lahuman.github.io/20180213-phase/">&lt;h1 id=&quot;아주-핫한-elasticsearch를-쓰고-있다&quot;&gt;아주 핫한 Elasticsearch를 쓰고 있다.&lt;/h1&gt;

&lt;p&gt;특정 IP의 range에 대하여 조회를 하려고 할때 사용하는 것은 &lt;strong&gt;wildcard&lt;/strong&gt;를 이용하면 SQL의 LIKE 검색과 같은 효과를 볼수 있다.&lt;/p&gt;

&lt;p&gt;결과에 대하여 기타 작업을 하기 위해서는 추가 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;다음 예제는 /32를 제외하고 가져온 후, 겨로가를 distinct하는 Query이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -XGET 'localhost:9200/iprange/_search?pretty' -H 'Content-Type: application/json' -d'
{
   &quot;query&quot;:{
      &quot;bool&quot;:{
         &quot;must_not&quot;:[
            {
               &quot;wildcard&quot;:{
                  &quot;range&quot;:{
                     &quot;value&quot;:&quot;*/32&quot;
                  }
               }
            }
         ]
      }
   },
   &quot;aggs&quot;:{
      &quot;uniq_gender&quot;:{
         &quot;terms&quot;:{
            &quot;field&quot;:&quot;range&quot;,
            &quot;size&quot;:10000
         }
      }
   }
}
'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://iju707.gitbooks.io/elasticsearch/content/_executing_searches.html&quot;&gt;ES 번역 문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="단상" /><summary type="html">Query를 짜는게 쉽지 않아.</summary></entry><entry><title type="html">신기한 정규식의 세계</title><link href="https://lahuman.github.io/20180212-phase/" rel="alternate" type="text/html" title="신기한 정규식의 세계" /><published>2018-02-12T00:00:00+09:00</published><updated>2018-02-12T00:00:00+09:00</updated><id>https://lahuman.github.io/20180212-phase</id><content type="html" xml:base="https://lahuman.github.io/20180212-phase/">&lt;h1 id=&quot;정규식을-안써본-사람은-있어도-한번만-써본-사람은-없을-듯&quot;&gt;정규식을 안써본 사람은 있어도, 한번만 써본 사람은 없을 듯…&lt;/h1&gt;

&lt;p&gt;어떤 작업의 결과가 특정한 패턴(방화벽 로그 같은)을 지닌다면 해당 패턴을 가지고 결과를 저장하는 프로그램을 보통은 파서 또는 정규화라는 명명을 가진다.&lt;/p&gt;

&lt;p&gt;이때 많이 사용하는 것중 하나가 정규식이다. 정규식의 장점으로는 대부분의 개발 언어를 지원한다.&lt;/p&gt;

&lt;p&gt;정규식은 그룹 묶기, 양의 지정, 매칭 여부 리턴 등 다양한 결과를 받을수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://regex101.com&quot;&gt;정규식 테스트 추천 사이트&lt;/a&gt;에서 테스트를 하면 쉽게 처리 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D&quot;&gt;정규 표현식&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://regex101.com&quot;&gt;정규식 테스트 추천 사이트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="단상" /><summary type="html">정규식 자체도 하나의 언어 같다.</summary></entry><entry><title type="html">이번주 토요일이 시험이다.</title><link href="https://lahuman.github.io/20180208-phase/" rel="alternate" type="text/html" title="이번주 토요일이 시험이다." /><published>2018-02-08T00:00:00+09:00</published><updated>2018-02-08T00:00:00+09:00</updated><id>https://lahuman.github.io/20180208-phase</id><content type="html" xml:base="https://lahuman.github.io/20180208-phase/">&lt;h1 id=&quot;시험은-정말-싫다&quot;&gt;시험은 정말 싫다.&lt;/h1&gt;
&lt;p&gt;내가 아는 것을 명확하게 서술하고 다른 사람에게 설명할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;사실 그게 생각보다 많이 어렵다.&lt;/p&gt;

&lt;p&gt;시험은 특히 서술형 시험은 그래서 어렵다.&lt;/p&gt;

&lt;p&gt;이번 주 토요일은 시험이다. 시험공부를 많이 못하기도 하였고… 집중이 안된다.&lt;/p&gt;

&lt;p&gt;큰일이다.&lt;/p&gt;

&lt;h2 id=&quot;이미-한번-떨어진건-안비밀&quot;&gt;이미 한번 떨어진건 안비밀..&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">시험은 늘 싫다.</summary></entry><entry><title type="html">Python] File Random access</title><link href="https://lahuman.github.io/python_file_seek/" rel="alternate" type="text/html" title="Python] File Random access" /><published>2018-02-06T00:00:00+09:00</published><updated>2018-02-06T00:00:00+09:00</updated><id>https://lahuman.github.io/python_file_seek</id><content type="html" xml:base="https://lahuman.github.io/python_file_seek/">&lt;h1 id=&quot;python-대용량-파일-처리&quot;&gt;Python] 대용량 파일 처리&lt;/h1&gt;

&lt;p&gt;파이썬에서 큰 파일(200MB)에 대하여 3가지 정규식을 기준으로 데이터를 추출 할 경우 다음과 같은 코드를 작성 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;코드-1&quot;&gt;코드 1&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*-coding:utf-8-*-
import re
import time


def get_result(pattern, content):
    return pattern.findall(content)


def append_data(name, pattern, content):
    result = get_result(pattern, content)
    if result:
        dic[name] = result


if name == 'main':
    start = time.time()
    patterns = dict() 
    patterns['patternA'] = re.compile(
        r'SESSION: (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)-:angry:\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)\((.+?)\),\s',
        re.I)
    patterns['patternB'] = re.compile(r&quot;(?:\d\`){4}\w{6}\`\d{4}\`\d{8}\`(?:\d{2}\:){2}\d{2}\`&quot;, re.I)
    patterns['patternC'] = re.compile(r&quot;devname\=\S+\s(?:device_id|devid)\=\S+\s(?:log_id|logid)\=\S+\stype\=\S+\s&quot;,
                                       re.I)

    dic = dict() # RESULT DATA

    with open('log-sample/500000.log', 'r') as log:
        for content in log:
            for name, pattern in patterns.iteritems():
                append_data(name, pattern, content)

    end = time.time() - start  # end에 코드가 구동된 시간 저장

    print (dic[&quot;patternA&quot;][0][0])
    print (&quot; END TIME : [&quot; + str(end) + &quot;]&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과는 각 정규식 별로 다르게 나온다.
1번 정규식은 4초, 2번 정규식은 6초, 3번 정규식은 8초 정도로 3개를 한번에 위의 코드같이 처리 할 경우 &lt;strong&gt;평균 16초&lt;/strong&gt;의 시간이 걸린다.&lt;/p&gt;

&lt;h3 id=&quot;코드-2&quot;&gt;코드 2&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*-coding:utf-8-*-
import re
import time
from multiprocessing import Pool


def get_result(pattern, content):
    return pattern.findall(content)


def append_data(dic, pattern, content):
    result = get_result(pattern, content)
    if result:
        dic.append(result)


def processing(pattern):
    dic = []
    with open('log-sample/500000.log', 'r') as log:
        for content in log:
            append_data(dic, pattern, content)
    print (len(dic))


if name == '__main__':
    start = time.time()
    patterns = [] 
    patterns.append(re.compile(
        r'SESSION: (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)-&amp;gt;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)\((.+?)\),\s',
        re.I))
    patterns.append(re.compile(r&quot;(?:\d\`){4}\w{6}\`\d{4}\`\d{8}\`(?:\d{2}\:){2}\d{2}\`&quot;, re.I))
    patterns.append(re.compile(r&quot;devname\=\S+\s(?:device_id|devid)\=\S+\s(?:log_id|logid)\=\S+\stype\=\S+\s&quot;,
                                       re.I))

    pool = Pool(processes=4)
    pool.map(processing, patterns)

    end = time.time() - start  # end에 코드가 구동된 시간 저장
    print (&quot;END TIME : [&quot; + str(end) + &quot;]&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두번째 코드는 각 패턴별로 multiprocessing을 이용하여 실행하는 코드 이다.&lt;/p&gt;

&lt;p&gt;이 경우 결과시간은 &lt;strong&gt;평균 10초&lt;/strong&gt;의 시간이 걸린다.&lt;/p&gt;

&lt;h3 id=&quot;코드-3&quot;&gt;코드 3&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*-coding:utf-8-*-
import re
import time
import os
from multiprocessing import Pool


def get_result(pattern, content):
    return pattern.findall(content)


def append_data(dic, pattern, content):
    result = get_result(pattern, content)
    if result:
        dic.append(result)


filename = 'log-sample/500000.log'


def processing(args):

    pattern = args[0]
    position = args[1]
    reple_dic = args[2]
    start_offset = args[3]
    end_line = args[4]

    dic = []
    line_cnt = 0
    with open(filename, 'r') as log:
        log.seek(start_offset)
        for content in log:
            append_data(dic, pattern, content)
            line_cnt += 1
            if line_cnt == end_line:
                break;

    # TODO use Dic

    print (len(dic))

def to_list(*args):
    return list(args)

if name == '__main__':
    start = time.time()

    # Read in the file once and build a list of line offsets
    line_offset = []
    offset = 0
    with open(filename, 'r') as file:
        for line in file:
            line_offset.append(offset)
            offset += len(line)

    print &quot;file Line Count : &quot;+ str(len(line_offset))

    patterns = [] 
 
    patterns.append(to_list(re.compile(
        r'SESSION: (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)-&amp;gt;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)\((.+?)\),\s',
        re.I), &quot;0,1,2,3,4&quot;, dict(), 0, 250000))
    patterns.append(to_list(re.compile(
        r'SESSION: (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)-&amp;gt;(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)\((.+?)\),\s',
        re.I), &quot;0,1,2,3,4&quot;, dict(), line_offset[250000], 250000))

    patterns.append(to_list(re.compile(r&quot;(?:\d\`){4}\w{6}\`\d{4}\`\d{8}\`(?:\d{2}\:){2}\d{2}\`&quot;, re.I), &quot;0,1,2,3,4&quot;, dict(), 0, 250000))
    patterns.append(to_list(re.compile(r&quot;(?:\d\`){4}\w{6}\`\d{4}\`\d{8}\`(?:\d{2}\:){2}\d{2}\`&quot;, re.I), &quot;0,1,2,3,4&quot;, dict(), line_offset[250000], 250000))

    patterns.append(to_list(re.compile(r&quot;devname\=\S+\s(?:device_id|devid)\=\S+\s(?:log_id|logid)\=\S+\stype\=\S+\s&quot;, re.I), &quot;0,1,2,3,4&quot;, dict(), 0, 250000))
    patterns.append(to_list(re.compile(r&quot;devname\=\S+\s(?:device_id|devid)\=\S+\s(?:log_id|logid)\=\S+\stype\=\S+\s&quot;, re.I), &quot;0,1,2,3,4&quot;, dict(), line_offset[250000], 250000))

    pool = Pool(processes=8)
    pool.map(processing, patterns)

    end = time.time() - start  # end에 코드가 구동된 시간 저장
    print (&quot;END TIME : [&quot; + str(end) + &quot;]&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파일에 대하여 특정 ROW 부터 처리 하도록 병령 처리를 하면 3번 코드와 같은 형식으로 나온다.&lt;/p&gt;

&lt;p&gt;이 경우 실행시간은 &lt;strong&gt;평균 5초&lt;/strong&gt; 가 된다.&lt;/p&gt;

&lt;p&gt;큰 파일에 대한 처리는 결국 file.seek를 이용하여 파일을 쪼개어 병렬로 처리 하는게 가장 빠른 방식 같다.&lt;/p&gt;

&lt;h2 id=&quot;참고-문서&quot;&gt;참고 문서&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/620367/how-to-jump-to-a-particular-line-in-a-huge-text-file&quot;&gt;File Line Offset save&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.regexprn.com/2008/11/read-random-line-in-large-file-in.html&quot;&gt;File random line Read&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://python.omics.wiki/multiprocessing_map/multiprocessing_partial_function_multiple_arguments&quot;&gt;Pool.map - Multiple arguments&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/15489091/python-converting-args-to-list&quot;&gt;Python converting args to list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><summary type="html">대용량 파일 처리시 병령 &amp; 랜덤 접근을 이용한 빠른 처리</summary></entry><entry><title type="html">게을러 지고 있다.</title><link href="https://lahuman.github.io/20180205-phase/" rel="alternate" type="text/html" title="게을러 지고 있다." /><published>2018-02-05T00:00:00+09:00</published><updated>2018-02-05T00:00:00+09:00</updated><id>https://lahuman.github.io/20180205-phase</id><content type="html" xml:base="https://lahuman.github.io/20180205-phase/">&lt;h1 id=&quot;게으르다-게으르다-게으르다&quot;&gt;게으르다 게으르다 게으르다.&lt;/h1&gt;

&lt;p&gt;아묵것도 하고 싶지 않다. 한 1년만 어디에 짱박혀서 아무것도 안하고 쉬고 싶다.&lt;/p&gt;

&lt;p&gt;갑자기 팽팽하던 실이 끊어진듯, 모든게 의미 없게 느껴진다.&lt;/p&gt;

&lt;h2 id=&quot;잠잠하던-지랄병이-도졌나&quot;&gt;잠잠하던 지랄병이 도졌나.&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">해야 할 일이 있는데 하기가 싫다.</summary></entry><entry><title type="html">Linux에서 디스크의 사용량(%) 기준으로 체크 하는 명령어</title><link href="https://lahuman.github.io/linux_disk_check/" rel="alternate" type="text/html" title="Linux에서 디스크의 사용량(%) 기준으로 체크 하는 명령어" /><published>2018-02-02T00:00:00+09:00</published><updated>2018-02-02T00:00:00+09:00</updated><id>https://lahuman.github.io/linux_disk_check</id><content type="html" xml:base="https://lahuman.github.io/linux_disk_check/">&lt;h1 id=&quot;linux에서-디스크의-사용량-기준으로-체크-하는-명령어&quot;&gt;Linux에서 디스크의 사용량(%) 기준으로 체크 하는 명령어&lt;/h1&gt;

&lt;p&gt;df 명령어로 사용중인 디스크 양을 체크 하는 명령어를 간단하게 작성하였다.&lt;/p&gt;

&lt;p&gt;t 옵션의 의미는 File System Type이며 ext4 파일 시스템일 경우 결과를 출력 하도록 하였다.&lt;/p&gt;

&lt;p&gt;결과에서는 해더와 % 기호를 제외하고 표출한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;df -ht ext4 | awk '{ if (NR!=1) {print $1, substr($5, 1, length($5)-1)} }'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/dev/sda1 52
/dev/sdb1 37
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="linux" /><summary type="html">df + awk 명령어로 처리</summary></entry><entry><title type="html">JPA에서 Entity에서 Enum을 사용할 경우 getInt 에러 발생시</title><link href="https://lahuman.github.io/jpa_enum_getInt_error/" rel="alternate" type="text/html" title="JPA에서 Entity에서 Enum을 사용할 경우 getInt 에러 발생시" /><published>2018-02-01T00:00:00+09:00</published><updated>2018-02-01T00:00:00+09:00</updated><id>https://lahuman.github.io/jpa_enum_getInt_error</id><content type="html" xml:base="https://lahuman.github.io/jpa_enum_getInt_error/">&lt;h1 id=&quot;jpa에서-entity에서-enum을-사용할-경우-getint-에러-발생시&quot;&gt;JPA에서 Entity에서 Enum을 사용할 경우 getInt 에러 발생시&lt;/h1&gt;

&lt;p&gt;JPA Entity에서 Enum 타입을 사용할 경우 다음 어노테이션을 처리해야 String 타입으로 받을수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Entity
@Getter
@Setter
public class Person{
    @Enumerated(EnumType.STRING) // 없을 경우 INT 형식으로 Return
    private Yn useYn;
}

public enum Yn {
    Y,N
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="JPA" /><category term="ENUM" /><summary type="html">Enum의 실제 데이터는 INT 다.</summary></entry><entry><title type="html">삼성 안드로이드 기기에서 블루투스 키보드 연결시 UI에 레이아웃 표출 안함 설정</title><link href="https://lahuman.github.io/android_samsung_keboard_layout_remove/" rel="alternate" type="text/html" title="삼성 안드로이드 기기에서 블루투스 키보드 연결시 UI에 레이아웃 표출 안함 설정" /><published>2018-01-31T00:00:00+09:00</published><updated>2018-01-31T00:00:00+09:00</updated><id>https://lahuman.github.io/android_samsung_keboard_layout_remove</id><content type="html" xml:base="https://lahuman.github.io/android_samsung_keboard_layout_remove/">&lt;h1 id=&quot;삼성-안드로이드-기기에서-블루투스-키보드-연결시-ui에-레이아웃-표출-안함-설정&quot;&gt;삼성 안드로이드 기기에서 블루투스 키보드 연결시 UI에 레이아웃 표출 안함 설정&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;설정 아이콘 클릭&lt;/li&gt;
  &lt;li&gt;언어 및 입력 방식 선택&lt;/li&gt;
  &lt;li&gt;기본 키보드 선택&lt;/li&gt;
  &lt;li&gt;가상 키보드 선택 안함&lt;/li&gt;
&lt;/ol&gt;

&lt;figure&gt;
	&lt;img src=&quot;http://imgur.com/gN2rp0C&quot; /&gt;
	&lt;figcaption&gt;가상 키보드 표기 안함 처리&lt;/figcaption&gt;
&lt;/figure&gt;</content><author><name></name></author><category term="단상" /><summary type="html">찾지 못해서 그냥 쓰다가 오늘 찾았다.</summary></entry><entry><title type="html">밤새 물이 새는 소리에 잠을 설쳤다.</title><link href="https://lahuman.github.io/20180129-phase/" rel="alternate" type="text/html" title="밤새 물이 새는 소리에 잠을 설쳤다." /><published>2018-01-29T00:00:00+09:00</published><updated>2018-01-29T00:00:00+09:00</updated><id>https://lahuman.github.io/20180129-phase</id><content type="html" xml:base="https://lahuman.github.io/20180129-phase/">&lt;h1 id=&quot;밤새도록-벽에서-물새는-소리가-들린다&quot;&gt;밤새도록 벽에서 물새는 소리가 들린다.&lt;/h1&gt;

&lt;p&gt;밤 11시경 자려고 누었는데 똑똑 물방울 떨어지는 소리가 벽에서 들려왔다.&lt;/p&gt;

&lt;p&gt;불을 켜고 물소리를 따라 가보니, 싱크대 선반에서 물이 떨어지고 있었다.&lt;/p&gt;

&lt;p&gt;아파트 관리실에 전화하고 30분 정도 기다리니, 9층에서 물이 샌거라고 알려주셨다.&lt;/p&gt;

&lt;p&gt;보상 받을 것이 있으면 직접 올라가서 보상 받으시라고…&lt;/p&gt;

&lt;p&gt;아파트 관리소에서 보험을 들어 두면 안되나? 9층에 직접 가서 이야기 하는것도 불편하고…&lt;/p&gt;

&lt;h2 id=&quot;아파트가-다-좋지는-않네&quot;&gt;아파트가 다 좋지는 않네&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">9층에서 동파로 물이 샌다.</summary></entry><entry><title type="html">LZW encoding algorithm</title><link href="https://lahuman.github.io/LZW_encoding_algorithm/" rel="alternate" type="text/html" title="LZW encoding algorithm" /><published>2018-01-26T00:00:00+09:00</published><updated>2018-01-26T00:00:00+09:00</updated><id>https://lahuman.github.io/LZW_encoding_algorithm</id><content type="html" xml:base="https://lahuman.github.io/LZW_encoding_algorithm/">&lt;h1 id=&quot;lzw-encoding-algorithm&quot;&gt;LZW encoding algorithm&lt;/h1&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;//www.youtube.com/embed/rZ-JRCPv_O8&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;lzw-encoding-algorithm-1&quot;&gt;LZW encoding algorithm&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. at the start, the dictionary contains all possible individual charactrs. and P is empty
2. C = next character in the charstream
3. si the string P+C present in the dictionary?
  a) if it is, 
      P = P + C (extend P with C);

  b)if not,
      i. output the code word which denotes P to the codestream;
      ii. add the string P+C to the dictionary
      iii. P=C(P now contanis only the character C)


1. At the start the dictionary contains all possible charstream.
2. cW = the first code word.
3. output the string.cW to the charstream.
4. pW = cW
5. cW = next code word.
6. is the String.cW present in the dictionary?
    if it is, 
        a) ouput the string.cW to the charstream;
        b) P := string.pW;
        c) C := the first character of the string.cW
        d) add the string P+C to the dictionary;

    if not, 
        a) P = string.pW;
        b) C = the first character of the string.pW;
        c) ouput the string P+C to the charstream and add it to the dictionary (now it corresponds to the cW)
7. Are there more code words in the codestream?
    a) if yes, go back to step  4;
    b) if not, End
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;lzw-인코딩-알고리즘&quot;&gt;LZW 인코딩 알고리즘&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 처음에는 사전에 가능한 모든 개인 문자가 들어 있습니다. P는 비어 있습니다.
2. C = charstream의 다음 문자
3. 사전에 P + C 문자열이 있습니까?
  a) 그렇다면,
      P = P + C (C와 P 연장);

  b) 그렇지 않다면,
      i. P를 코드 워드에 출력하고;
      ii. 사전에 문자열 P + C를 추가합니다.
      iii. P = C (이제 P는 문자 C 만 사용)


1. 처음에는 사전에 가능한 모든 charstream이 들어 있습니다.
2. cW = 첫 번째 코드 워드.
3. string.cW를 charstream으로 출력하십시오.
4. pW = cW
5. cW = 다음 코드 워드.
6. 사전에 String.cW가 있습니까?
    그렇다면,
        a) string.cW를 charstream에 출력한다.
        b) P : = string.pW;
        c) C : = string.cW의 첫 번째 문자
        d) P + C 문자열을 사전에 추가합니다.

    그렇지 않다면,
        a) P = 문자열 .pW;
        b) C = 문자열의 첫 번째 문자 .pW;
        c) 문자열 P + C를 charstream에 놓고 사전에 추가합니다 (이제는 cW에 해당함)
7. 코드 스트림에 더 많은 코드 단어가 있습니까?
    a) 그렇다면 4 단계로 되돌아갑니다.
    b) 그렇지 않다면, 끝
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="단상" /><summary type="html">그림으로 쉽게 설명 되어있다.</summary></entry></feed>
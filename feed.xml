<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2017-12-14T10:43:35+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">Python 에서 멀티 스레드를 사용하기 보다 멀티 프로세스를 사용하자.</title><link href="https://lahuman.github.io/20171214-python_thread_process/" rel="alternate" type="text/html" title="Python 에서 멀티 스레드를 사용하기 보다 멀티 프로세스를 사용하자." /><published>2017-12-13T00:00:00+09:00</published><updated>2017-12-13T00:00:00+09:00</updated><id>https://lahuman.github.io/20171214-python_thread_process</id><content type="html" xml:base="https://lahuman.github.io/20171214-python_thread_process/">&lt;h1 id=&quot;파이선의-스레드에는-약간의-제약이-있다&quot;&gt;파이선의 스레드에는 약간의 제약이 있다.&lt;/h1&gt;

&lt;p&gt;파이썬은 내부적으로 전역 인터프리터 록(Global Interpreter Lock, GIL)을 사용한다. 이것은 시스템 하나에서 스레드 하나만 실행되도록 제한한다.&lt;/p&gt;

&lt;p&gt;따라서 파이썬 쓰래드는 여러개의 코어를 활용하지 못하고 하나의 코어에서만 실행된다.&lt;/p&gt;

&lt;p&gt;대신에 여러개의 코어를 활용할 수 있는 multiprocessing 모듈을 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단 프로세스 객체를 생성하고 실행하는 코드는 반드시 __main__ 만 실행하는 코드 안에 적어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;자-지금까지-한거-고치자&quot;&gt;자 지금까지 한거 고치자..&lt;/h2&gt;</content><author><name></name></author><category term="Python" /><category term="Thread" /><summary type="html">Global Interpreter Lock, GIL 로 인한 제한</summary></entry><entry><title type="html">졸리나 넘나</title><link href="https://lahuman.github.io/20171213-phase/" rel="alternate" type="text/html" title="졸리나 넘나" /><published>2017-12-13T00:00:00+09:00</published><updated>2017-12-13T00:00:00+09:00</updated><id>https://lahuman.github.io/20171213-phase</id><content type="html" xml:base="https://lahuman.github.io/20171213-phase/">&lt;h1 id=&quot;새벽-3시까지-뒤척거리며-잠을-잘-못잤다&quot;&gt;새벽 3시까지 뒤척거리며 잠을 잘 못잤다.&lt;/h1&gt;

&lt;p&gt;논문도 써야 하고 회사 일도 이번달까지 Prototype 작성해야 하고…&lt;/p&gt;

&lt;p&gt;뭔가 할 일이 많다.&lt;/p&gt;

&lt;h2 id=&quot;졸리다-넘나&quot;&gt;졸리다 넘나..&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">잠을 잘 못잠</summary></entry><entry><title type="html">tor, phantomJS를 Ubuntu에 설치</title><link href="https://lahuman.github.io/tor_phantomjs_install_on_ubuntu/" rel="alternate" type="text/html" title="tor, phantomJS를 Ubuntu에 설치" /><published>2017-12-12T00:00:00+09:00</published><updated>2017-12-12T00:00:00+09:00</updated><id>https://lahuman.github.io/tor_phantomjs_install_on_ubuntu</id><content type="html" xml:base="https://lahuman.github.io/tor_phantomjs_install_on_ubuntu/">&lt;h1 id=&quot;tor-phantomjs를-ubuntu에-설치&quot;&gt;tor, phantomJS를 Ubuntu에 설치&lt;/h1&gt;

&lt;h2 id=&quot;tor-설치--서비스-기동&quot;&gt;tor 설치 &amp;amp; 서비스 기동&lt;/h2&gt;

&lt;p&gt;tor 설치는 간단하게 apt-get을 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tor 설치
sudo apt-get install tor
# tor service 기동
sudo service tor start
# 기동 확인 9050 포트가 LISTEN되는지 확인
netstat -anop | grep 9050
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;phantomjs-설치&quot;&gt;phantomJS 설치&lt;/h2&gt;
&lt;p&gt;phantomJS는 pip로 설치가 되지 않는다.&lt;/p&gt;

&lt;p&gt;우선 시스템에서 필요한 프로그램을 다음과 같이 설치 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 먼저 시스템을 최신 상태로 업데이트 한다.
sudo apt-get update
sudo apt-get install build-essential chrpath libssl-dev libxft-dev

# PhantomJS 관련 필수 프로그램 설치
sudo apt-get install libfreetype6 libfreetype6-dev
sudo apt-get install libfontconfig1 libfontconfig1-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후, PhantomJS를 설치 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 특정 버젼 다운로드 &amp;amp; 압축 해제
cd ~
export PHANTOM_JS=&quot;phantomjs-2.1.1-linux-x86_64&quot;
wget https://bitbucket.org/ariya/phantomjs/downloads/$PHANTOM_JS.tar.bz2
sudo tar xvjf $PHANTOM_JS.tar.bz2

# /usr/local/share 이하로 옮기고 실행 가능하도록 symlink 설정
sudo mv $PHANTOM_JS /usr/local/share
sudo ln -sf /usr/local/share/$PHANTOM_JS/bin/phantomjs /usr/local/bin

# 확인
phantomjs --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/julionc/7476620&quot;&gt;How to install PhantomJS on Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="tor" /><category term="phantomJS" /><summary type="html">apt-get 과 함께면 참 쉽다!</summary></entry><entry><title type="html">Selenium 과 PhantomJS를 사용하는 환경에서 Close는 중요 하다.</title><link href="https://lahuman.github.io/20171208-phase/" rel="alternate" type="text/html" title="Selenium 과 PhantomJS를 사용하는 환경에서 Close는 중요 하다." /><published>2017-12-08T00:00:00+09:00</published><updated>2017-12-08T00:00:00+09:00</updated><id>https://lahuman.github.io/20171208-phase</id><content type="html" xml:base="https://lahuman.github.io/20171208-phase/">&lt;h1 id=&quot;selenium-과-phantomjs를-사용하는-환경에서-webdriverclose는-중요-하다&quot;&gt;Selenium 과 PhantomJS를 사용하는 환경에서 webdriver.close()는 중요 하다.&lt;/h1&gt;

&lt;p&gt;오류가 발생하면서 종료 되었을때도 PhantomJS 프로세스는 종료 되지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 꼭 finally 처리로 닫아 줘야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver = webdriver.PhantomJS()
try:
  driver.get(URL)
  # doing something
finally:
  driver.close()
  try:
    # 오류가 발생해도 넘어가기
    driver.quit()
  except Exception:
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;시작했다고-늘-함께-하진-않는구나&quot;&gt;시작했다고 늘 함께 하진 않는구나…&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">Python에서 만난 OOM</summary></entry><entry><title type="html">Python 에서 DB Pool 사용하기</title><link href="https://lahuman.github.io/python_use_db_pool/" rel="alternate" type="text/html" title="Python 에서 DB Pool 사용하기" /><published>2017-12-07T00:00:00+09:00</published><updated>2017-12-07T00:00:00+09:00</updated><id>https://lahuman.github.io/python_use_db_pool</id><content type="html" xml:base="https://lahuman.github.io/python_use_db_pool/">&lt;h1 id=&quot;python-에서-db-pool-사용하기&quot;&gt;Python 에서 DB Pool 사용하기&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터베이스와 애플리케이션을 효율적으로 연결하는 커넥션 플 라이브러리는 애플리케이션에서 필수 요소 입니다.
일반적인 프로그램에서 데이터베이스에 연결(Connection 객체를 얻는 작업)은 많은 시간이 소요 됩니다.
따라서 Connection을 미리 생성시켜 저장소에 저장 했다가 프로그램에서 요청이 있으면 저장소에서 꺼내 제공하면 시간과 리소스를 절약 할 수 있습니다. 이러한 기법을 Connection Pool이라 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Python 에서 사용할수 있는 MariaDB Connection Pool은 몇가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Oracle Mysql Pool(mysql 5.5 이상 설치시 사용 가능)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/LuciferJack/python-mysql-pool&quot;&gt;python-mysql-pool&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이중 Oracle 에서 제공되는 Pool을 테스트 진행시 Pool 개수 이상을 요구 시, 대기 없이 다음과 같은 오류가 발생한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql.connector.errors.PoolError: Failed getting connection; pool exhausted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;때문에 SQLAlchemy는 Python에 대한 SQL 툴킷과 객체 관계 매퍼를 사용하여 구현 하였다.&lt;/p&gt;

&lt;p&gt;우선 JAVA 7의 try-with-resources과 같은 기능이 Python의 &lt;strong&gt;with&lt;/strong&gt; 로 있다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;strong&gt;with&lt;/strong&gt; 를 이용해서 처리 할수 있는 DB에 대한 connection을 얻고 닫는 것을 다음처럼 자동화 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# _Session
with _Session(config['MARIADB']['MARIADB_CONNECT_INFO']) as s:
    onion_count = s.query(OnionsInfo).count()
return onion_count

#Connection
with Connector(config['MARIADB']['MARIADB_CONNECT_INFO']) as con:
    onion_count = con.execute(&quot;select count(*) from onions_info&quot;).fetchall()[0]
return onion_count
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;session 의 경우 SQLAlchemy와 곂치기 때문에 _를 이용함&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;with 절을 이용해 with 절이 시작 할때 &lt;strong&gt;enter&lt;/strong&gt; 가 호출 되고, 종료 될때 &lt;strong&gt;exit&lt;/strong&gt; 가 호출 되어 connection을 시작 하고 종료 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class _Session(Singleton):
    session = None

    def __init__(self, connect_info=None):
        global engine
        if engine is None:
            engine = sqlalchemy.create_engine(
                connect_info, pool_size=5,
                max_overflow=5, pool_recycle=500)
            Session.configure(bind=engine)

    def __enter__(self):
        self.session = Session()
        print &quot;enter = &quot; + str(self.session)
        return self.session

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            self.session.rollback()
            print &quot;rollback()&quot; + str(self.session)
        else:
            self.session.commit()

        print &quot;close() : &quot; + str(self.session)
        self.session.close_all()


class Connector(Singleton):
    con = None

    def __init__(self, connect_info=None):
        global engine
        if engine is None:
            engine = sqlalchemy.create_engine(
                connect_info, pool_size=5,
                max_overflow=5, pool_recycle=500)

    def __enter__(self):
        self.conn = engine.connect()
        return self.conn

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.conn.close();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.haruair.com/blog/1682&quot;&gt;SQLAlchemy 시작하기 – Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://preshing.com/20110920/the-python-with-statement-by-example/&quot;&gt;The Python “with” Statement by Example&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="SQLAlchemy" /><category term="db pool" /><summary type="html">SQLAlchemy의 DB Pool 이용</summary></entry><entry><title type="html">Python을 이용하여 원격 서버에 로그 전송</title><link href="https://lahuman.github.io/syslog_write_python/" rel="alternate" type="text/html" title="Python을 이용하여 원격 서버에 로그 전송  " /><published>2017-12-02T00:00:00+09:00</published><updated>2017-12-02T00:00:00+09:00</updated><id>https://lahuman.github.io/syslog_write_python</id><content type="html" xml:base="https://lahuman.github.io/syslog_write_python/">&lt;h1 id=&quot;원격지-로그-전송&quot;&gt;원격지 로그 전송&lt;/h1&gt;

&lt;p&gt;Python으로 특정 원격지 서버에 로그 전송이 가능하다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 rsyslog에서 해당 통신이 가능하도록 설정을 변경 해야 한다.
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim /etc/rsyslog.conf

# UDP 514 포트로 통신 가능하도록 다음 2 LINE 주석 제거
$ModLoad imudp
$UDPServerRun 514

# 로그타입과 저장 위치 설정
local3.*        /var/log/my-logfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 rsyslog에 대한 서비스를 재기동 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service rsyslog restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 Python 소스는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import logging
import logging.handlers

logger = logging.getLogger('myLogger')
logger.setLevel(logging.INFO)

#add handler to the logger
handler = logging.handlers.SysLogHandler(address = ('SERVER_IP',514), facility=logging.handlers.SysLogHandler.LOG_LOCAL3)

#add formatter to the handler
formatter = logging.Formatter('Python: { &quot;loggerName&quot;:&quot;%(name)s&quot;, &quot;asciTime&quot;:&quot;%(asctime)s&quot;, &quot;pathName&quot;:&quot;%(pathname)s&quot;, &quot;logRecordCreationTime&quot;:&quot;%(created)f&quot;, &quot;functionName&quot;:&quot;%(funcName)s&quot;, &quot;levelNo&quot;:&quot;%(levelno)s&quot;, &quot;lineNo&quot;:&quot;%(lineno)d&quot;, &quot;time&quot;:&quot;%(msecs)d&quot;, &quot;levelName&quot;:&quot;%(levelname)s&quot;, &quot;message&quot;:&quot;%(message)s&quot;}')

handler.formatter = formatter
logger.addHandler(handler)

logger.info(&quot;Test Message&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 소스를 실행하면 /var/log/my-logfile 파일에 로그가 쌓이는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3968669/how-to-configure-logging-to-syslog-in-python&quot;&gt;How to configure logging to syslog in Python?&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="python" /><category term="log" /><summary type="html">원격 서버로 로그 전송</summary></entry><entry><title type="html">Elasticdump 를 이용한 데이터 백업과 리스토어</title><link href="https://lahuman.github.io/elastic_dump/" rel="alternate" type="text/html" title="Elasticdump 를 이용한 데이터 백업과 리스토어 " /><published>2017-12-01T00:00:00+09:00</published><updated>2017-12-01T00:00:00+09:00</updated><id>https://lahuman.github.io/elastic_dump</id><content type="html" xml:base="https://lahuman.github.io/elastic_dump/">&lt;h1 id=&quot;elasticdump를-이용한-데이터-백업과-리스토어&quot;&gt;Elasticdump를 이용한 데이터 백업과 리스토어&lt;/h1&gt;

&lt;p&gt;elasticsearch의 데이터를 다른 곳으로 이관 하는 작업을 해야 한다.
&lt;br /&gt;
이때 사용 가능한 프로그램이 &lt;a href=&quot;https://github.com/taskrabbit/elasticsearch-dump&quot;&gt;elasticdump&lt;/a&gt; 이다.
&lt;br /&gt;
elasticdump는 현재 3.3.1 버젼으로 Elasticsearch 5.x 버젼을 지원하고 있다.
&lt;br /&gt;
지금 사용하는 elasticsearch 버젼이 2.x여서 해당 버젼을 지원하는 elsticdump 2.4.2를 설치 해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;설치&quot;&gt;설치&lt;/h2&gt;

&lt;p&gt;설치는 가이드에 나온 것과 같이 npm 을 설치 하고 elasticdump 모듈을 설치 해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# npm은 설치 되어 있다고 가정 한다.
npm install elasticdump

# git 에서 코드 download
git clone https://github.com/taskrabbit/elasticsearch-dump.git
cd elasticsearch-dump
# v2.4.2 으로 변경
git checkout tags/v2.4.2
# 버전 확인
./bin/elasticdump --version
2.4.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-백업&quot;&gt;데이터 백업&lt;/h2&gt;

&lt;p&gt;백업되는 데이터 타입은 크게 3가지로 나누어 진다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;analyzer&lt;/li&gt;
  &lt;li&gt;mapping&lt;/li&gt;
  &lt;li&gt;data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본적으로 데이터를 넣기 위해서는 최소한의 데이터 맵핑이 있어야 한다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;elasticdump 는 Elasticsearch to Ealsticsearch 를 지원하며, File 로 저장 리스토어도 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Copy an index from production to staging with analyzer and mapping:
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=http://staging.es.com:9200/my_index \
  --type=analyzer
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=http://staging.es.com:9200/my_index \
  --type=mapping
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=http://staging.es.com:9200/my_index \
  --type=data

# Backup index data to a file:
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=/data/my_index_mapping.json \
  --type=mapping
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=/data/my_index.json \
  --type=data

# Backup and index to a gzip using stdout:
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=$ \
  | gzip &amp;gt; /data/my_index.json.gz

# Backup the results of a query to a file
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=query.json \
  --searchBody '{&quot;query&quot;:{&quot;term&quot;:{&quot;username&quot;: &quot;admin&quot;}}}'

# Copy a single shard data:
elasticdump \
  --input=http://es.com:9200/api \
  --output=http://es.com:9200/api2 \
  --params='{&quot;preference&quot; : &quot;_shards:0&quot;}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;searchBody를 이용하면 원하는 목록 가져올 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;20171207-테스트-결과-추가&quot;&gt;2017.12.07 테스트 결과 추가&lt;/h2&gt;

&lt;h2 id=&quot;원본데이터를-파일로-저장&quot;&gt;원본데이터를 파일로 저장&lt;/h2&gt;

&lt;h3 id=&quot;1-원본-데이터-매핑-저장&quot;&gt;1. 원본 데이터 매핑 저장&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=http://10.10.10.202:9200 \
--input-index=elastic_data/elastic_data \
--output=elastic_data_mapping.json \
--type=mapping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-원본-데이터-백업&quot;&gt;2. 원본 데이터 백업&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;sample로 searchBody를 이용하여 1분 동안의 데이터만 가져오도록 함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=http://10.10.10.202:9200 \
--input-index=elastic_data/elastic_data \
--output=elastic_data.json \
--type=data \
--searchBody '{
  &quot;query&quot;:{
      &quot;range&quot;:{
      &quot;log_dttm&quot;:{
          &quot;gte&quot;:&quot;2017-11-01T00:00:00&quot;,
            &quot;lte&quot;:&quot;2017-11-01T00:00:59&quot;
        }
        }
    }
}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;파일로-저장된-데이터를-서버에-저장&quot;&gt;파일로 저장된 데이터를 서버에 저장&lt;/h2&gt;

&lt;h3 id=&quot;1-인덱스-추가--데이터-형식-저장&quot;&gt;1. 인덱스 추가 &amp;amp; 데이터 형식 저장&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=elastic_data_mapping.json \
--output=http://10.10.10.180:9201/elastic_data \
--type=mapping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-데이터-import-처리&quot;&gt;2. 데이터 import 처리&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이미 등록된 데이터를 다시 등록 할 경우 _version 의 값이 +1 처리 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=elastic_data.json \
--output=http://10.10.10.180:9201/elastic_data \
--type=data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/taskrabbit/elasticsearch-dump&quot;&gt;elasticdump&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="elasticsearch" /><category term="elasticdump" /><summary type="html">Elasticsearch 백업 &amp; 리스토어</summary></entry><entry><title type="html">내부 서비스만 가능한 PORT를 원격지 호출 가능하도록 변경</title><link href="https://lahuman.github.io/delegate_port_forward/" rel="alternate" type="text/html" title="내부 서비스만 가능한 PORT를 원격지 호출 가능하도록 변경" /><published>2017-11-30T00:00:00+09:00</published><updated>2017-11-30T00:00:00+09:00</updated><id>https://lahuman.github.io/delegate_port_forward</id><content type="html" xml:base="https://lahuman.github.io/delegate_port_forward/">&lt;h1 id=&quot;tor-proxy-포트-9050을-원격에서-접속-하는-방법&quot;&gt;Tor Proxy 포트 9050을 원격에서 접속 하는 방법&lt;/h1&gt;

&lt;p&gt;netstat 로 특정 포트를 확인 하면 2개의 IP:PORT가 표출 되는데, 첫번째 IP가 127.0.0.1 일 경우, 오직 로컬(localhost-loopback interface)에서만 접근 이 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo netstat -ntlup | grep 9050
tcp        0      0 127.0.0.1:9050          0.0.0.0:*               LISTEN      683/tor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tor에서 제공되는 Proxy 9050 port는 socks5 protocol로 로컬에서만 서비스 된다.
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;delegate-설정&quot;&gt;DeleGate 설정&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://delegate.hpcc.jp/delegate/&quot;&gt;일본&lt;/a&gt;에서 제작된 것으로 보이며, 2014년 10월에 9.9.13으로 마지막 UPDATE 된 프로그램이다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;기초 사용법은 &lt;a href=&quot;http://www.delegate.org/delegate/tutorial/&quot;&gt;Delegate 사이트&lt;/a&gt;에 잘 나와있다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;설치는 &lt;a href=&quot;ftp://delegate.hpcc.jp/pub/DeleGate/bin/&quot;&gt;BINARY 형식을 다운&lt;/a&gt;받아 압축을 풀면 추가 설치할 필요는 없다.
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# download 9.9.13
$ wget ftp://delegate.hpcc.jp/pub/DeleGate/bin/linux/latest/linux2.6-dg9_9_13.tar.gz
# 압축 해제
$ tar xvzf linux2.6-dg9_9_13.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행은 설치된 디렉터리의 bin/dg9_9_13 을 실행 하면된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 설치된 디렉터리로 이동
$ cd DGROOT/bin/
# 메일 정보를 작성하지 않을 경우 다음의 오류 발생
# ERROR! ADMIN=&quot;your_mail_address&quot; must be specified.
$ vim dg9_9_13.conf
# ADMIN 찾아 주석 제거후, 메일 주소 작성
ADMIN=Email.address
# 저장 후 종료
# 실행 -P제공PORT SERVER=서버타입(HTTP,FTP,SSH ETC..) SOCKS=포워딩대상정보
./dg9_9_13 -P8890 SERVER=socks5 SOCKS=localhost:9050
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처리된 결과를 확인하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tcp        0      0 0.0.0.0:8890            0.0.0.0:*               LISTEN      6069/./dg9_9_13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;외부에서 8890 포트로 Proxy요청을 보내면 tor proxy를 사용 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://superuser.com/questions/423563/convert-http-requests-to-socks5&quot;&gt;Convert HTTP requests to SOCKS5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.delegate.org/delegate/&quot;&gt;DeleGate Support Site&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="delegate" /><category term="port forward" /><summary type="html">Port forward 프로그램</summary></entry><entry><title type="html">Python 에서 Mysql DB Pool 선택시 유의사항</title><link href="https://lahuman.github.io/python_connection_pool/" rel="alternate" type="text/html" title="Python 에서 Mysql DB Pool 선택시 유의사항" /><published>2017-11-29T00:00:00+09:00</published><updated>2017-11-29T00:00:00+09:00</updated><id>https://lahuman.github.io/python_connection_pool</id><content type="html" xml:base="https://lahuman.github.io/python_connection_pool/">&lt;h1 id=&quot;python에서-mysql-db-pool을-테스트-해보았다&quot;&gt;Python에서 Mysql DB Pool을 테스트 해보았다.&lt;/h1&gt;

&lt;p&gt;우선 테스트를 위해서 알아야할 기초 지식은 Porcess와 Thread 이다.
&lt;br /&gt;
기본적으로 Tomcat 서버는 하나의 Porcess에서 여러개의 Request를 thread 기반으로 처리 한다. 
&lt;br /&gt;
단순하게 하나의 Porcess에서 DB Pool을 사용한다고 생각 하면된다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;테스트는 다음 2개을 해보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/connector/python/&quot;&gt;mysql-connector-python&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;처음에는 mysql-connector-python 이 내가 정확하게 원하는 기능만을 담고 있어서 사용하기 위한 테스트를 진행 하였다.
&lt;br /&gt;
하지만 mysql-connector-python의 경우 pool 갯수 이상의 connection을 요구 할 경우 다음과 같은 오류가 발생 한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql.connector.errors.PoolError: Failed getting connection&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; pool exhausted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 검색을 통하여 SQLAlchemy 을 사용하면 되는 것을 확인하고 테스트 결과 원하는 처리가 되었다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://m.blog.naver.com/PostView.nhn?blogId=parkjy76&amp;amp;logNo=220794146424&amp;amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F&quot;&gt;connection pool&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="python" /><category term="mysql" /><summary type="html">Mysql connector Pool은 이상하다.</summary></entry><entry><title type="html">오늘은 맥 개발 환경 설정을 해보았다.</title><link href="https://lahuman.github.io/20171127-phase/" rel="alternate" type="text/html" title="오늘은 맥 개발 환경 설정을 해보았다." /><published>2017-11-27T00:00:00+09:00</published><updated>2017-11-27T00:00:00+09:00</updated><id>https://lahuman.github.io/20171127-phase</id><content type="html" xml:base="https://lahuman.github.io/20171127-phase/">&lt;h1 id=&quot;개인-성향은-아무것도-안깔고-쓰다가-필요하면-하나씩-깔아-보는-건데&quot;&gt;개인 성향은 아무것도 안깔고 쓰다가 필요하면 하나씩 깔아 보는 건데…&lt;/h1&gt;

&lt;p&gt;맥을 개발용으로 처음 쓰려고 하니, 뭐 부터 시작해야 하는지 몰라 일단 인터넷에서 검색한 개발 환경을 따라가 보았다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다른건 모르겠고, vim 화면이 이뻐졌다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;일단 열심히 써보자!&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://subicura.com/2017/11/22/mac-os-development-environment-setup.html&quot;&gt;본격 macOS에 개발 환경 구축하기&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="단상" /><summary type="html">새로운 프로그램을 잔뜩 깔아 버림</summary></entry></feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.4.0">Jekyll</generator>
<link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" />
<link href="https://lahuman.github.io/" rel="alternate" type="text/html" />
<updated>2017-03-13T10:22:01+09:00</updated>
<id>https://lahuman.github.io/</id>
<subtitle>열심히 사는 아저씨</subtitle>
<entry>
<title>[2016.03.13] 육아 - 아이와 함께 자라기</title>
<link href="https://lahuman.github.io/20160313-phase/" rel="alternate" type="text/html" title="[2016.03.13] 육아 - 아이와 함께 자라기" />
<published>2017-03-13T00:00:00+09:00</published>
<updated>2017-03-13T00:00:00+09:00</updated>
<id>https://lahuman.github.io/20160313-phase</id>
<content type="html" xml:base="https://lahuman.github.io/20160313-phase/">&lt;h1 id=&quot;section&quot;&gt;아이와 함께 자라기&lt;/h1&gt;

&lt;p&gt;육아를 시작 하면서 많은 것을 포기한다고 생각하고, 아이와 놀아준다는 것은 쉽지 않다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;관점을 조금만 바꾸면 아이와 함께 생각하고, 아이와 함께 노는 것은 즐거워 질수 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;나는 아직 어른이 아니다. 아이와 함께 고민하고 성장 하도록 노력하자.&lt;br /&gt;&lt;/p&gt;

</content>
<category term="육아" />
<summary>육아</summary>
</entry>
<entry>
<title>[JAVASCRIPT] - 주소창의 parameter 제거</title>
<link href="https://lahuman.github.io/javascript-remove-url-parameter/" rel="alternate" type="text/html" title="[JAVASCRIPT] - 주소창의 parameter 제거" />
<published>2017-03-09T00:00:00+09:00</published>
<updated>2017-03-09T00:00:00+09:00</updated>
<id>https://lahuman.github.io/javascript-remove-url-parameter</id>
<content type="html" xml:base="https://lahuman.github.io/javascript-remove-url-parameter/">&lt;h1 id=&quot;javascript----parameter-&quot;&gt;[JAVASCRIPT] - 주소창의 parameter 제거&lt;/h1&gt;

&lt;p&gt;보통은 주소창에 parameter 값이 다음과 같이 표출된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;https://lahuman.github.io/posts/?lang=ko&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이때 해당 주소에서 parameter 값만 제거 하고 싶을 경우 다음의 스크립트를 이용하면 간단히 처리 할 수 있다.&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}
history.replaceState({}, null, location.pathname);
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;parameter가 제거된 값은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;https://lahuman.github.io/posts/&lt;/code&gt;&lt;/p&gt;

</content>
<category term="javascript" />
<category term="parameter" />
<summary>주소창의 parameter 제거</summary>
</entry>
<entry>
<title>[2016.03.08] 기초 - 병렬 처리 용어 설명</title>
<link href="https://lahuman.github.io/20160308-phase/" rel="alternate" type="text/html" title="[2016.03.08] 기초 - 병렬 처리 용어 설명" />
<published>2017-03-08T00:00:00+09:00</published>
<updated>2017-03-08T00:00:00+09:00</updated>
<id>https://lahuman.github.io/20160308-phase</id>
<content type="html" xml:base="https://lahuman.github.io/20160308-phase/">&lt;h1 id=&quot;section&quot;&gt;병렬 처리 용어 설명&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;다중 프로그래밍(Multi Programming)
    &lt;ul&gt;
      &lt;li&gt;배치 처리 방식에서 CPU 처리시간을 낭비하지 않고 사용하기 위해 한 프로그램이 입출력을 시작하여 끝나기를 기다리는 동안, 계산 수행이 필요한 다른 프로그램을 실행하는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다중 프로세싱(Multi Processing)
    &lt;ul&gt;
      &lt;li&gt;두 개 이상의 프로세서로 구성되어 동시에 여러 개의 작업을 처리할 수 있는 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;선점(Preemption)
    &lt;ul&gt;
      &lt;li&gt;클라이언트를 서비스하는 도중 일시 중지시키고 다른 클라이언트를 서비스하는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명령어 수준 병렬(ILP) 구조
    &lt;ul&gt;
      &lt;li&gt;하나의 프로그램을 구성하는 명령을 병렬 실행할 수 있도록 하는 프로세서 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 메모리 구조
    &lt;ul&gt;
      &lt;li&gt;모든 처리 노드들이 전체 주소 공간을 공유하며 직접 접근할 수 있는 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분산 메모리 구조
    &lt;ul&gt;
      &lt;li&gt;각 처리노드가 독자적인 주소 공간을 가지며, 다른 노드의 기억 장치에 접근하기 위해서는 정해진 절차와 방법에 따라야 하는 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
<category term="용어설명" />
<summary>용어설명</summary>
</entry>
<entry>
<title>Redis 설치 및 Cluster 구성</title>
<link href="https://lahuman.github.io/redis-cluster-install/" rel="alternate" type="text/html" title="Redis 설치 및 Cluster 구성" />
<published>2017-03-06T00:00:00+09:00</published>
<updated>2017-03-06T00:00:00+09:00</updated>
<id>https://lahuman.github.io/redis-cluster-install</id>
<content type="html" xml:base="https://lahuman.github.io/redis-cluster-install/">&lt;h1 id=&quot;redis---cluster-&quot;&gt;Redis 설치 및 Cluster 구성&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 계정을 생성 한다.&lt;/h2&gt;

&lt;p&gt;{% highlight bash %}
$&amp;gt; adduser redis
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;open-file---limit--&quot;&gt;2. open file 갯수에 대한 Limit 을 변경한다.&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; vi /etc/security/limits.conf&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis soft nofile 65535
redis hard nofile 65535
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;3. 메모리 스와핑을 최소로 사용하도록 설정을 한다.&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; sysctl -w vm.swappiness=1&lt;/p&gt;

&lt;p&gt;이후 재기동 이후 반영을 위해&lt;/p&gt;

&lt;p&gt;$&amp;gt;vi /etc/sysctl.conf 
    vm.swappiness=1&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;4. 메모리를 다 사용해도 충분한 메모리가 있는 것처럼 처리 한다.&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; sysctl -w vm.overcommit_memory=1&lt;/p&gt;

&lt;p&gt;이후 재기동 이후 반영을 위해&lt;/p&gt;

&lt;p&gt;$&amp;gt; vi /etc/sysctl.conf
    vm.overcommit_memory=1 추가&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;5. 네트워크 연결 개수를 설정 한다.&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; sysctl -w net.core.somaxconn=65535&lt;/p&gt;

&lt;p&gt;이후 재기동 이후 반영을 위해&lt;/p&gt;

&lt;p&gt;$&amp;gt; vi /etc/rc.local
    sysctl -w net.core.somaxconn=65535&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;system-hang----thp----&quot;&gt;6. System Hang 을 막기 위해 THP 사용 안하도록 설정 한다.&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled&lt;/p&gt;

&lt;p&gt;이후 재기동 이후 반영을 위해&lt;/p&gt;

&lt;p&gt;$&amp;gt; vi /etc/rc.local
    echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;redis----redis--&quot;&gt;7. Redis 설치 - redis 계정으로 진행&lt;/h2&gt;
&lt;p&gt;{% highlight bash %}
# Source Download
$&amp;gt; wget http://download.redis.io/releases/redis-3.2.6.tar.gz
# 압축 헤제
$&amp;gt; tar xvzf redis-3.2.6.tar.gz
# 해제된 디렉토리 이동
$&amp;gt; cd redis-3.2.6
# 설치 진행
$&amp;gt; make&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;에러 발생시 다음 진행&lt;/h1&gt;
&lt;p&gt;$&amp;gt; yum install gcc-c++
$&amp;gt; make distclean
$&amp;gt; make&lt;/p&gt;

&lt;h1 id=&quot;usrlocalbin----root--&quot;&gt;/usr/local/bin에 실행 파일 복사됨, root 권한 필요&lt;/h1&gt;
&lt;p&gt;$&amp;gt; make install
{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&quot;cluster-&quot;&gt;8. Cluster 구성&lt;/h2&gt;

&lt;h3 id=&quot;conf-file-&quot;&gt;8.1 Conf File 수정&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; vi redis conf
    #원격 서버에서 접속 가능하게 설정하려면 no로 지정
    protected-mode no
    tcp-keepalive 60
    loglevel notice
    logfile “/var/log/redis/redis_5543.log”&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;daemonize yes
#포트 지정
port 5543
#bind 127.0.0.1를 주석 처리
# bind 127.0.0.1 
#비밀번호 지정
requirepass &amp;lt;password&amp;gt;
masterauth &amp;lt;password&amp;gt;
#yes로 설정시 클러스터 모드, no로 설정시 standalone 모드로 시작
cluster-enabled yes 
#클러스터의 상태를 기록하는 바이너리 파일 경로
cluster-config-file nodes_5543.conf 
#레디스 노드가 다운되었는지 판단하는 시간 단위는 millisecond.
cluster-node-timeout 3000 
#다운 시도 횟수 
cluster-slave-validity-factor 2 
#위치 지정
pidfile /var/run/redis/redis_5543.pid 
dbfilename dump-5543.rdb
# appendonly 는 변경시 해당 명령을 저장해 두었다가, 복구시 저장된 명령을 순서대로 실행하는 옵션
appendonly yes  {% endhighlight %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;8.2 인스턴스 시작&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt;  $REDIS_BIN/redis-server $REDIS_NODE_CONF/redis-${port}.conf&lt;/p&gt;

&lt;p&gt;#7000 ~ 7002 까지 인스턴스 실행 예
$&amp;gt; $REDIS_BIN/redis-server $REDIS_NODE_CONF/redis-7000.conf
$&amp;gt; $REDIS_BIN/redis-server $REDIS_NODE_CONF/redis-7001.conf
$&amp;gt; $REDIS_BIN/redis-server $REDIS_NODE_CONF/redis-7002.conf
{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;8.3 인스턴스별 슬롯 할당&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7000 -a &lt;password&gt; cluster addslots {0..5460}
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7001 -a &lt;password&gt; cluster addslots {5461..10922}
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7002 -a &lt;password&gt; cluster addslots {10923..16383}
{% endhighlight %}&lt;/password&gt;&lt;/password&gt;&lt;/password&gt;&lt;/p&gt;

&lt;h3 id=&quot;epoch-&quot;&gt;8.4 epoch 설정&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7000 -a &lt;password&gt; cluster set-config-epoch 1
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7001 -a &lt;password&gt; cluster set-config-epoch 2
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7002 -a &lt;password&gt; cluster set-config-epoch 3
{% endhighlight %}&lt;/password&gt;&lt;/password&gt;&lt;/password&gt;&lt;/p&gt;

&lt;h3 id=&quot;meet-nodes&quot;&gt;8.5 meet nodes&lt;/h3&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7000 -a &lt;password&gt; cluster meet 124.66.185.75 7001
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7002 -a &lt;password&gt; cluster meet 124.66.185.75 7001
{% endhighlight %}&lt;/password&gt;&lt;/password&gt;&lt;/p&gt;

&lt;h3 id=&quot;salve-&quot;&gt;8.6 salve 추가&lt;/h3&gt;

&lt;h4 id=&quot;meet-slave-to-master&quot;&gt;8.6.1 meet slave to master&lt;/h4&gt;
&lt;p&gt;{% highlight bash %}
$&amp;gt; redis-cli -c -h 124.66.185.75 -p 7002 -a &lt;password&gt; cluster meet 124.66.185.71 6000
{% endhighlight %}&lt;/password&gt;&lt;/p&gt;

&lt;h4 id=&quot;regist-slave-to-master&quot;&gt;8.6.2 regist slave to master&lt;/h4&gt;
&lt;p&gt;{% highlight bash %}
#node-id 는 70002의 노드 ID 이어야 한다.
$&amp;gt; redis-cli -c -h 124.66.185.71 -p 6000 -a &lt;password&gt; cluster replicate &lt;node-id&gt;
{% endhighlight %}&lt;/node-id&gt;&lt;/password&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;참고 자료&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.redisgate.com/redis/cluster/cluster_cmd_intro.php&quot;&gt;http://www.redisgate.com/redis/cluster/cluster_cmd_intro.php&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://knight76.tistory.com/entry/redis-AOF-appendonlyfile&quot;&gt;http://knight76.tistory.com/entry/redis-AOF-appendonlyfile&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://knight76.tistory.com/entry/redis-%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A0%A8-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%A4%EB%B2%84%EC%BB%A4%EB%B0%8B-THP&quot;&gt;http://knight76.tistory.com/entry/redis-%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A0%A8-%ED%99%95%EC%9D%B8%ED%95%98%EB%8A%94-%EC%BD%94%EB%93%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%A4%EB%B2%84%EC%BB%A4%EB%B0%8B-THP&lt;/a&gt; &lt;br /&gt;&lt;/p&gt;

</content>
<category term="Redis" />
<category term="install" />
<category term="cluster" />
<summary>레디스 설치 클러스터 구성</summary>
</entry>
<entry>
<title>[2016.03.06] 짧은 생각 - TDD</title>
<link href="https://lahuman.github.io/20160306-phase/" rel="alternate" type="text/html" title="[2016.03.06] 짧은 생각 - TDD" />
<published>2017-03-06T00:00:00+09:00</published>
<updated>2017-03-06T00:00:00+09:00</updated>
<id>https://lahuman.github.io/20160306-phase</id>
<content type="html" xml:base="https://lahuman.github.io/20160306-phase/">&lt;h1 id=&quot;tdd---test-driven-development&quot;&gt;TDD - Test Driven Development&lt;/h1&gt;

&lt;p&gt;테스트 주도 개발은 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스 중 하나이다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;개발 순서는 다음과 같다.&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;새로운 함수를 정의하는 자동화된 테스트 케이스를 작성&lt;/li&gt;
  &lt;li&gt;케이스를 통과하기 위한 최소한의 양의 코드를 생성&lt;/li&gt;
  &lt;li&gt;새 코드를 표준에 맞도록 리팩토링&lt;/li&gt;
  &lt;li&gt;변경 사항 발생시 2~3 번을 반복&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TDD를 활용한 개발을 해본적이 없다. 빨리 빨리라는 암시 때문인지 늘 만들기 바쁘고, 개발이 완료 하고 운영시에는 불안함을 감출수 없었다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞으론 TDD를 활용하기 위해 노력 해보자!&lt;/p&gt;

</content>
<category term="단상" />
<summary>단상</summary>
</entry>
<entry>
<title>[2016.03.03] 짧은 생각 - 개발 방법론</title>
<link href="https://lahuman.github.io/20160303-phase/" rel="alternate" type="text/html" title="[2016.03.03] 짧은 생각 - 개발 방법론" />
<published>2017-03-03T00:00:00+09:00</published>
<updated>2017-03-03T00:00:00+09:00</updated>
<id>https://lahuman.github.io/20160303-phase</id>
<content type="html" xml:base="https://lahuman.github.io/20160303-phase/">&lt;h1 id=&quot;section&quot;&gt;개발 방법론&lt;/h1&gt;

&lt;p&gt;많은 개발 방법론이 있지만, SI프로젝트에서 가장 많이 쓰이는 건 Waterfall Model(폭포수 개발 방법론)으로 불리는 방법을 사용한다. &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;순서는 다음과 같다.&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;요구사항 분석&lt;/li&gt;
  &lt;li&gt;시스템&amp;amp;소프트웨어 아키텍처 설계&lt;/li&gt;
  &lt;li&gt;구현과 유닛 테스트&lt;/li&gt;
  &lt;li&gt;통합과 시스템 테스트&lt;/li&gt;
  &lt;li&gt;운영&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;해당 개발 방법론의 단점은 변경에 수행이 어렵다고 하지만, 실제 프로젝트에서의 변경은 매번 발생한다. &lt;br /&gt;
또한 변경에 따른 &lt;kbd&gt;재설계&lt;/kbd&gt;를 하는 게 아니라 구현 단계에서 땜빵을 한다.&lt;br /&gt;
이는 곧 기술 부채로 이어지고 운영시점이 되면 걷잡을수 없을 정도가 되고 만다.&lt;/p&gt;

&lt;p&gt;CBD(Component Based Development)방법론을 따르는 프로젝트에서도 일해 보았지만 Waterfall Model과 다른건 산출물뿐이었다.&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;일정에 쫓기게 되어 급하게 개발 하고 늘 후회하였다.&lt;/p&gt;
&lt;/blockquote&gt;
</content>
<category term="단상" />
<summary>단상</summary>
</entry>
<entry>
<title>[2016.03.01] 짧은 생각 - 소프트웨어 공학</title>
<link href="https://lahuman.github.io/20160301-phase/" rel="alternate" type="text/html" title="[2016.03.01] 짧은 생각 - 소프트웨어 공학" />
<published>2017-03-01T00:00:00+09:00</published>
<updated>2017-03-01T00:00:00+09:00</updated>
<id>https://lahuman.github.io/20160301-phase</id>
<content type="html" xml:base="https://lahuman.github.io/20160301-phase/">&lt;h1 id=&quot;section&quot;&gt;소프트웨어 공학 이란&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 공학은 소프트웨어 생산의 모든 관점을 다루는 공학 분야이다.&lt;/li&gt;
  &lt;li&gt;소프트웨어는 프로그램과 관련 문서 및 실행에 필요한 데이터를 포함한다.&lt;/li&gt;
  &lt;li&gt;좋은 소프트웨어 제품이 되기 위해서는 유지보수성, 신뢰성(dependability), 보안성, 효율성 및 수용성(acceptability)이 보장되어야 한다.&lt;/li&gt;
  &lt;li&gt;소프트웨어 프로세스는 소프트웨어 개발과 관련한 모든 활동을 포함하며 기본적으로 명세, 개발, 검증(validation)과 진화 (evolution)로 이루어진다.&lt;/li&gt;
  &lt;li&gt;시스템의 유형에 따라 개발에 사용되는 도구와 기술이 달라질 수 있다.&lt;/li&gt;
  &lt;li&gt;소프트웨어공학의 기본 개념은 모든 유형의 소프트웨어 시스템에 적용될 수 있다.&lt;/li&gt;
  &lt;li&gt;소프트웨어 엔지니어는 기술적 책무 외에도 윤리적 책임의식을 가져야 한다.&lt;/li&gt;
&lt;/ul&gt;

</content>
<category term="단상" />
<summary>단상</summary>
</entry>
<entry>
<title>[2016.02.28] 짧은 생각 - 보스와 리더</title>
<link href="https://lahuman.github.io/20160228-phase/" rel="alternate" type="text/html" title="[2016.02.28] 짧은 생각 - 보스와 리더" />
<published>2017-02-24T00:00:00+09:00</published>
<updated>2017-02-24T00:00:00+09:00</updated>
<id>https://lahuman.github.io/20160228-phase</id>
<content type="html" xml:base="https://lahuman.github.io/20160228-phase/">&lt;h1 id=&quot;section&quot;&gt;보스와 리더&lt;/h1&gt;

&lt;p&gt;{% capture images %}
	https://lahuman.github.io/assets/img/phase/leader-boss.jpg
{% endcapture %}
{% include gallery images=images caption=”BOSS &amp;amp; Leader” cols=1 %}&lt;/p&gt;

&lt;p&gt;업무를 하면서 많은 보스 스타일의 관리자를 보았다. 
그들은 기본적으로 작업자에 대한 불신을 깔고 일을 진행하기에, 모든 일정을 최대한 짧게 잡는다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;결과적으로 외부에서 보기에는 프로젝트가 성공적으로 보이지만, 내부적으로는 기술 부채와 관리자에 대한 불평 불만을 가진 팀원의 퇴사로 이어진다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이후 해당 프로젝트는 2년 후 재개발을 하거나, 리뉴얼이란 이름으로 다시 시작 한다.&lt;br /&gt;
하지만, 그 프로젝트에서도 처음과 같은 실수를 반복한다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;추가적으로 업무를 하면서 리더는 본적이 없다. 다만, 협업하는 동료가 아닐까 생각한다.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;인간의 욕심은 끝이 없고 같은 실수를 반복한다&lt;/h3&gt;
</content>
<category term="단상" />
<summary>단상</summary>
</entry>
<entry>
<title>[2016.02.24] 짧은 생각 - 책</title>
<link href="https://lahuman.github.io/20160224-phase/" rel="alternate" type="text/html" title="[2016.02.24] 짧은 생각 - 책" />
<published>2017-02-24T00:00:00+09:00</published>
<updated>2017-02-24T00:00:00+09:00</updated>
<id>https://lahuman.github.io/20160224-phase</id>
<content type="html" xml:base="https://lahuman.github.io/20160224-phase/">&lt;h1 id=&quot;section&quot;&gt;책&lt;/h1&gt;

&lt;p&gt;책을 읽는 것은 정말 중요 하다. 어떤 사람은 다독을 권장 하기도 하고, 정독을 권장 하기도 한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;꼭 공부나 무언가를 배우기 위한 책도 좋지만, 주변을 환기 시키고 생각에 잠기게 하는 좋은 책도 있다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음은 윤동주 시인의 &lt;kbd&gt;서시&lt;/kbd&gt; 이다.&lt;/p&gt;

&lt;p&gt;{% highlight text %}&lt;/p&gt;

&lt;序詩&gt;
              
죽는 날까지 하늘을 우러러
한 점 부끄러움이 없기를
잎새에 이는 바람에도 
나는 괴로워했다.
별을 노래하는 마음으로
모든 죽어 가는 것을 사랑해야지
그리고 나한테 주워진 길을
걸어가야겠다

오늘밤도 별이 바람에 스치운다

{% endhighlight %}


### 하루에 한 소절을 읽어도 좋다. 죽는 날까지 멈추지 말고 계속 책을 읽자.&lt;br /&gt;
&lt;/序詩&gt;
</content>
<category term="단상" />
<summary>단상</summary>
</entry>
<entry>
<title>Spring MVC에서 ResponsBody로 String을 전달시 한글 깨짐 현상 해결</title>
<link href="https://lahuman.github.io/korean-utf-8-String/" rel="alternate" type="text/html" title="Spring MVC에서 ResponsBody로 String을 전달시 한글 깨짐 현상 해결" />
<published>2017-02-21T00:00:00+09:00</published>
<updated>2017-02-21T00:00:00+09:00</updated>
<id>https://lahuman.github.io/korean-utf-8-String</id>
<content type="html" xml:base="https://lahuman.github.io/korean-utf-8-String/">&lt;h1 id=&quot;spring-mvc--responsbody-string------&quot;&gt;Spring MVC 에서 ResponsBody로 String 을 전달시 한글 깨짐 현상 해결&lt;/h1&gt;

&lt;p&gt;Controller에서 단순한 문자열(String)을 ResponseBody로 전달할 경우, 깨지는 현상이 발생할 수 있습니다. 
코드는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;{% highlight java %}
@RequestMapping(value=”/preview/{id}”, method=RequestMethod.GET)
public @ResponseBody String getContent(@PathVariable(“id”) long id) {
    return service.getContent(id);
}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;한글이 깨지는 원인은 브라우저에서 해당 요청에 대한 응답의 헤더 값을 보면 다음과 같이 표현되어 있습니다.&lt;/p&gt;

&lt;p&gt;{% highlight css %}
Content-Type:application/json;charset=ISO-8859-1
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;위의 문제를 해결하기 위해서는 다음과 같이 spring servlet xml 설정을 추가해야 합니다.
{% highlight xml %}&lt;/p&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;!-- @ResponseBody Content-Type:application/json;charset=UTF-8  --&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                &lt;list&gt;
                    &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;위와 같이 설정을 한 후 응답의 해더 값을 확인하면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;{% highlight css %}
Content-Type:application/json;charset=UTF-8
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;이후 Content 값을 확인하면, 한글이 깨지지 않고 제대로 표출되는 것을 확인할 수 있습니다.&lt;/p&gt;
</content>
<category term="한글" />
<category term="Spring MVC" />
<category term="String" />
<summary>Spring MVC 한글 처리</summary>
</entry>
</feed>

<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.3">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2024-01-25T13:40:39+00:00</updated><id>https://lahuman.github.io/feed.xml</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">함께 일하고 싶은 동료, 그리고 함께 하면 피곤한 동료</title><link href="https://lahuman.github.io/20240125/" rel="alternate" type="text/html" title="함께 일하고 싶은 동료, 그리고 함께 하면 피곤한 동료" /><published>2024-01-25T00:00:00+00:00</published><updated>2024-01-25T00:00:00+00:00</updated><id>https://lahuman.github.io/20240125</id><content type="html" xml:base="https://lahuman.github.io/20240125/">&lt;h1 id=&quot;결국-사람인데&quot;&gt;결국 사람인데…&lt;/h1&gt;

&lt;p&gt;함께 일울 하면 힘이 되는 사람이 있고,&lt;/p&gt;

&lt;p&gt;함께 일을 하면 기운 빠지게 만드는 사람이 있습니다.&lt;/p&gt;

&lt;p&gt;서로 맞지 않는다고 생각하는데 어떻게 계속 함께 일하게 되네요.&lt;/p&gt;

&lt;p&gt;늘 사람이 가장 어렵고 힘드네요.&lt;/p&gt;</content><author><name></name></author><category term="phase" /><summary type="html">함께 하기 싫은 사람과 함께 해야 할 때도 있다</summary></entry><entry><title type="html">kotlin + Spring</title><link href="https://lahuman.github.io/spring_kotlin/" rel="alternate" type="text/html" title="kotlin + Spring" /><published>2024-01-25T00:00:00+00:00</published><updated>2024-01-25T00:00:00+00:00</updated><id>https://lahuman.github.io/spring_kotlin</id><content type="html" xml:base="https://lahuman.github.io/spring_kotlin/">&lt;h1 id=&quot;이번에는-코프링이다&quot;&gt;이번에는 코프링이다!&lt;/h1&gt;

&lt;p&gt;이번 프로젝트는 kotlin + spring으로 결정했습니다.&lt;/p&gt;

&lt;p&gt;익숙한 nodejs를 선택하지 않은 이유는 2가지가 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;새로운 걸 할때가 되었다.&lt;/li&gt;
  &lt;li&gt;동료중에 코틀린 좀 치는 분이 계시다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;자바 + Spring은 경험했었지만, 코틀린은 처음이라 기대 반 걱정반입니다.&lt;/p&gt;

&lt;h2 id=&quot;코틀린으로-시작해보자&quot;&gt;코틀린으로 시작해보자&lt;/h2&gt;

&lt;p&gt;기본 문법은 가법게 책과 동영상으로 익히고 바로 spring을 접해보기로 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-기본-설정-프로젝트-생성하기&quot;&gt;spring 기본 설정 프로젝트 생성하기&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://start.spring.io/&quot;&gt;Spring initializer&lt;/a&gt; 를 통해서 프로젝트를 생성하거나, 아래와 같은 curl 명령어를 이용해서 파일을 다운 받을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mkdir blog &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;blog
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl https://start.spring.io/starter.zip &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;kotlin &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gradle-project-kotlin &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;web,mustache,jpa,h2,devtools &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;packageName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;com.example.blog &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Blog &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; blog.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래는 주요 설정을 설명 합니다.&lt;/p&gt;

&lt;h3 id=&quot;buildgradlekts&quot;&gt;build.gradle.kts&lt;/h3&gt;

&lt;p&gt;JSR 305 어노테이션 + Spring null 가능성 어노테이션에 대한 Kotlin 지원은 컴파일 시 null 관련 문제를 처리할 수 있는 이점과 함께 Kotlin 개발자에게 전체 Spring Framework API에 대한 null 안전성을 제공합니다.&lt;/p&gt;

&lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KotlinCompile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;kotlinOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;freeCompilerArgs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-Xjsr305=strict&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;jpa-지연-로딩-처리를-위한-설정&quot;&gt;JPA 지연 로딩 처리를 위한 설정&lt;/h3&gt;

&lt;p&gt;지연 가져오기가 예상대로 작동하도록 하려면 &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28525&quot;&gt;KT-28525&lt;/a&gt;에 설명된 대로 엔티티를 열어야 합니다. 이를 위해 Kotlin &lt;code class=&quot;highlighter-rouge&quot;&gt;allopen&lt;/code&gt; 플러그인을 사용하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;plugins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;kotlin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;plugin.allopen&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;1.8.0&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;allOpen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jakarta.persistence.Entity&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jakarta.persistence.Embeddable&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;annotation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jakarta.persistence.MappedSuperclass&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;controller&quot;&gt;controller&lt;/h2&gt;

&lt;p&gt;Hello World를 화면에 출력하는 단순한 REST API 입니다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@RestController&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;@RequestMapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/api/hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;@GetMapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;단순하게 Controller만 생성해보았습니다.&lt;/p&gt;

&lt;p&gt;이후 jpa 연계 부터 많은 작업을 해야 하는데, 새롭게 배우는 내용들을 작성해보려고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="kotlin" /><category term="spring" /><summary type="html">그래 너로 정했다! 코프링~</summary></entry><entry><title type="html">생성형 AI(Generative AI)의 이해</title><link href="https://lahuman.github.io/generative_ai/" rel="alternate" type="text/html" title="생성형 AI(Generative AI)의 이해" /><published>2024-01-18T00:00:00+00:00</published><updated>2024-01-18T00:00:00+00:00</updated><id>https://lahuman.github.io/generative_ai</id><content type="html" xml:base="https://lahuman.github.io/generative_ai/">&lt;h1 id=&quot;생성형-aigenerative-ai란&quot;&gt;생성형 AI(Generative AI)란?&lt;/h1&gt;

&lt;p&gt;인공지능(AI) 분야에서 주목받는 최신 발전 중 하나는 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성형 AI(Generative AI)&lt;/code&gt;의 등장입니다. 생성형 AI는 &lt;code class=&quot;highlighter-rouge&quot;&gt;기계가 인간의 창작물과 매우 유사한 텍스트, 이미지, 심지어 음악을 생성할 수 있는 기술&lt;/code&gt;을 지칭합니다. 이 기술의 복잡성과 다양성은 업계에서 큰 관심을 받고 있는데, 이를 통해 새로운 창작물을 만들어내는 가능성이 열린 것입니다.&lt;/p&gt;

&lt;p&gt;생성형 AI는 간단하면서도 강력한 원리에 기반하고 있습니다. 주어진 입력이나 컨텍스트에 따라 의미 있는 결과물을 창출할 수 있는 능력을 가지고 있습니다. 이러한 AI가 주목받는 이유 중 하나는 인간과 유사한 대화를 이어가면서 다양한 주제에 걸쳐 일관된 콘텐츠를 생성할 수 있다는 점입니다. 대표적인 예로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;챗봇&lt;/code&gt; 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenAI의 GPT(Generative Pre-trained Transformer) 모델&lt;/code&gt;이 있습니다. 특히 GPT-3 및 그 후속 모델은 다양한 주제에 대한 이해와 일관된 텍스트 생성 능력을 입증하여 많은 주목을 받았습니다.&lt;/p&gt;

&lt;p&gt;생성형 AI로 개발된 응용 프로그램은 알파고와는 달리 &lt;code class=&quot;highlighter-rouge&quot;&gt;광범위한 분야에서 유용성&lt;/code&gt;을 보여주고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;fmfoundation-model&quot;&gt;FM(Foundation Model)&lt;/h2&gt;

&lt;p&gt;FM(Foundation Model)은 다양한 생성형 AI 애플리케이션의 기초를 제공합니다. 이는 광범위한 데이터 세트에 대한 사전 훈련된 모델로, 개발자와 연구원이 신속하게 구축할 수 있는 출발점을 제공합니다. FM은 특정 작업에 맞게 미세 조정하거나 다양한 애플리케이션에서 그대로 활용할 수 있는 기초 역할을 합니다.&lt;/p&gt;

&lt;h2 id=&quot;amazon-bedrock-생성형-ai로-가는-관문&quot;&gt;&lt;a href=&quot;https://aws.amazon.com/ko/bedrock/&quot;&gt;Amazon Bedrock&lt;/a&gt;: 생성형 AI로 가는 관문&lt;/h2&gt;

&lt;p&gt;Amazon Bedrock은 AI21 Labs, Anthropic, Cohere, Meta, Stability AI 및 Amazon과 같은 선도적인 AI 회사들의 고성능 파운데이션 모델(FM)을 하나의 API로 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;완전히 관리되는 서비스&lt;/code&gt;(SaaS 형태)입니다. 생성형 AI 애플리케이션을 구축하는 데 필요한 다양한 기능 세트를 활용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;개인 정보 보호 및 보안을 유지&lt;/code&gt;하면서 개발을 간소화할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;amazon-bedrock-security-and-privacy&quot;&gt;&lt;a href=&quot;https://aws.amazon.com/ko/bedrock/security-compliance/&quot;&gt;Amazon Bedrock Security and Privacy&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;애플리케이션의-보안-유지&quot;&gt;애플리케이션의 보안 유지&lt;/h4&gt;

&lt;p&gt;Amazon bedrock을 사용하면 생성형 AI 애플리케이션의 기본 모델을 사용자 정의하는 데 사용하여 데이터를 완벽하게 제어할 수 있습니다. 데이터는 전송 중 및 미사용 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;암호화&lt;/code&gt;됩니다. 또한, &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS 키 관리 서비스(AWS KMS)를 사용하여 암호화 키를 생성, 관리 및 제어&lt;/code&gt;할 수 있습니다. ID 기반 정책은 데이터를 더욱 효과적으로 제어하여 사용자와 역할이 어떤 리소스에서, 어떤 조건에서, 어떤 작업을 수행할 수 있는지 관리할 수 있도록 도와줍니다&lt;/p&gt;

&lt;h4 id=&quot;포괄적인-데이터-보호-및-개인정보-보호로-구축&quot;&gt;포괄적인 데이터 보호 및 개인정보 보호로 구축&lt;/h4&gt;

&lt;p&gt;아마존 bedrock은 데이터를 사용자가 제어할 수 있도록 도와줍니다. 기본 모델을 조정할 때는 해당 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;비공개 사본을 기반&lt;/code&gt;으로 합니다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;사용자의 데이터는 모델 제공업체와 공유되지 않으며 기본 모델을 개선하는 데 사용되지 않습니다.&lt;/code&gt; AWS PrivateLink를 사용하면 VPC를 인터넷 트래픽에 노출하지 않고도 Amazon 가상 프라이빗 클라우드(VPC)에서 Amazon bedrock으로 프라이빗 연결을 설정할 수 있습니다. 마지막으로, bedrock은 ISO, SOC, CSA STAR 레벨 2를 포함한 일반적인 규정 준수 표준의 적용 범위를 벗어나지 않으며, HIPAA를 준수하고, 고객이 GDPR을 준수하면서 bedrock을 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;검색-증강-세대rag&quot;&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/sagemaker/latest/dg/jumpstart-foundation-models-customize-rag.html&quot;&gt;검색 증강 세대(RAG)&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;파운데이션 모델은 오프라인에서 학습되어 새로운 데이터에 적응하지 못하고, 도메인별 작업에는 부적합합니다.&lt;/li&gt;
  &lt;li&gt;검색 증강 세대(RAG)는 파운데이션 모델에 추가적인 데이터를 제공하여 프롬프트를 개선할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;RAG는 문서와 쿼리를 임베딩하여 관련성 검색을 수행하고, 지식 라이브러리에서 유사한 문서의 컨텍스트를 프롬프트에 삽입합니다.&lt;/li&gt;
  &lt;li&gt;RAG 모델 아키텍처와 지식 집약적 NLP 작업에 대한 자세한 내용은 &lt;a href=&quot;https://arxiv.org/abs/2005.11401&quot;&gt;이 문서&lt;/a&gt;를 참고하세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.aws.amazon.com/ko_kr/sagemaker/latest/dg/images/jumpstart/jumpstart-fm-rag.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/bedrock/&quot;&gt;Amazon Bedrock&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://amarpreet-s.medium.com/generative-ai-with-aws-bedrock-4e1a2770db0c&quot;&gt;Generative AI with AWS Bedrock&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/korea/knowledge-bases-now-delivers-fully-managed-rag-experience-in-amazon-bedrock/&quot;&gt;Amazon Bedrock Knowledge Bases 정식 출시 – 완전관리형 RAG 경험 제공&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/korea/preview-connect-foundation-models-to-your-company-data-sources-with-agents-for-amazon-bedrock/&quot;&gt;Amazon Bedrock 지식 기반 미리보기 – 파운데이션 모델을 위한 에이전트 기반 기업 데이터 소스 연결 기능&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/tech/bedrock-claude-kendra-rag/&quot;&gt;Amazon Bedrock의 Claude와 Amazon Kendra로 향상된 RAG 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/sagemaker/latest/dg/jumpstart-foundation-models-customize-rag.html&quot;&gt;검색 증강 세대(RAG)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="generative" /><category term="ai" /><summary type="html">대표적인 예로 AWS BEDROCK 까지 알아보자</summary></entry><entry><title type="html">docker 에서 실행중인 컨테이너를 이미지로 전환 처리</title><link href="https://lahuman.github.io/docker-commit/" rel="alternate" type="text/html" title="docker 에서 실행중인 컨테이너를 이미지로 전환 처리" /><published>2023-12-30T00:00:00+00:00</published><updated>2023-12-30T00:00:00+00:00</updated><id>https://lahuman.github.io/docker-commit</id><content type="html" xml:base="https://lahuman.github.io/docker-commit/">&lt;h1 id=&quot;컨테이너의-변경-사항으로-새-이미지-만들기&quot;&gt;컨테이너의 변경 사항으로 새 이미지 만들기&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;사건의 발달은 6000번 포트로 서비스를 오픈했을때, chrome에서 접근하지 못하는 문제가 발생했습니다. 
원인으로 &lt;a href=&quot;https://gajy.tistory.com/65?fbclid=IwAR1cvnSRDTgkYb8QXX3INHOEQ6az519k2QCN6d6LLp-8kiT-Q64DDLJgKXY&quot;&gt;6000번 포트의 비밀 (ERR_UNSAFE_PORT)&lt;/a&gt;를 보면 보안상의 이유로 막았다고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;문제는 이미 설정한 컨테이너를 지우고 다시 작업하기 귀찮은 상황이었습니다. 
그래서 찾은게 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/commit/&quot;&gt;docker commit&lt;/a&gt;라는 명령입니다.&lt;/p&gt;

&lt;p&gt;해당 명령어를 이용해서 실행중인 컨테이너를 새 이미지로 만들 수 있습니다. 
저는 아래와 같이 사용 하였습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 6000번 포트를 연동하고 있는 컨테이너
$ docker ps
CONTAINER ID   IMAGE                        COMMAND               CREATED        STATUS       PORTS                                                                                                                           NAMES
4d4f0a0acbae   ssh_alpine                    &quot;/usr/sbin/sshd -D&quot;   8 hours ago    Up 8 hours   0.0.0.0:6000-6001-&amp;gt;6000-6001/tcp, :::6000-6001-&amp;gt;6000-6001/tcp   dqserver

# 컨테이너를 이미지로 생성
$ docker commit dqserver dqserver_image

# 기존 이미지 중지 및 삭제
$ docker stop dqserver
$ docker rm dqserver

# 포트를 변경해서 신규 이미지 생성
$ docker run -it -d -p 6002:6002 -p 6001:6001  --name dqserver dqserver_image
$ docker ps
CONTAINER ID   IMAGE                        COMMAND               CREATED        STATUS       PORTS                                                                                                                           NAMES
4d4f0a0acbae   dqserver_image                    &quot;/usr/sbin/sshd -D&quot;   8 hours ago    Up 8 hours   0.0.0.0:6001-6002-&amp;gt;6001-6002/tcp, :::6001-6002-&amp;gt;6001-6002/tcp   dqserver
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 이미지가 커밋되는 동안 커밋되는 컨테이너와 해당 프로세스는 일시 중지됩니다. 이렇게 하면 커밋을 생성하는 과정에서 데이터 손상이 발생할 가능성이 줄어듭기 때문입니다. 동작을 원하지 않는 경우 –pause 옵션을 false로 설정하세요.&lt;/p&gt;

&lt;p&gt;추가적인 설명은 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/commit/&quot;&gt;docker commit&lt;/a&gt;를 확인하세요!&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/commit/&quot;&gt;docker commit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gajy.tistory.com/65?fbclid=IwAR1cvnSRDTgkYb8QXX3INHOEQ6az519k2QCN6d6LLp-8kiT-Q64DDLJgKXY&quot;&gt;6000번 포트의 비밀 (ERR_UNSAFE_PORT)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="docker" /><category term="container" /><summary type="html">외부 연결 포트를 변경하는지 등의 처리를 할때 용의</summary></entry><entry><title type="html">목적이 없는 일은 마치 방향타 없는 배와 같다</title><link href="https://lahuman.github.io/20231203/" rel="alternate" type="text/html" title="목적이 없는 일은 마치 방향타 없는 배와 같다" /><published>2023-12-03T00:00:00+00:00</published><updated>2023-12-03T00:00:00+00:00</updated><id>https://lahuman.github.io/20231203</id><content type="html" xml:base="https://lahuman.github.io/20231203/">&lt;h1 id=&quot;프로젝트나-팀을-이끄는-데-있어-목적이-명확해야-합니다&quot;&gt;프로젝트나 팀을 이끄는 데 있어 목적이 명확해야 합니다.&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;목적이 없는 일은 마치 방향타 없는 배&lt;/code&gt;와 같습니다. 
목표를 설정하고 그에 맞는 방향으로 나아가는 것이 중요합니다. 
“목적은 A인데 A로 가는 길이 아닌 B로 가는 길을 가져오라”는 말은 목표에 집중하되, 유연하게 상황에 대처하고 새로운 아이디어를 통해 목표를 달성할 수 있다는 의미입니다.&lt;/p&gt;

&lt;p&gt;프로젝트나 팀을 이끄는 것은 개발만큼이나 어려운 일입니다. 
팀을 이끄는 데 있어서 팀원과 동료들과의 원활한 커뮤니케이션과 협력이 매우 중요합니다. 목표를 공유하고 이해시키며, 팀원들이 각자의 강점을 발휘하도록 도움을 주는 것이 필요합니다.&lt;/p&gt;

&lt;p&gt;어릴 때는 팀장의 역할이 미비하다고 생각되었지만, 지금은 팀장이 다양한 일을 처리해야 한다는 것을 깨닫게 되었습니다. 팀장은 팀원들을 이끄는 리더로서의 역할뿐만 아니라, 프로젝트의 방향을 설정하고 조절하며 문제 발생 시 해결책을 찾는 등 다양한 역할을 수행해야 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 팀장은 팀원들을 동기부여하고 긍정적인 분위기를 조성하는 역할도 중요합니다. 팀원들이 목표를 공유하고 그에 대한 열정을 가질 수 있도록 지원하면, 프로젝트나 팀의 성공에 더 큰 기여를 할 수 있을 것입니다.&lt;/p&gt;</content><author><name></name></author><category term="propose" /><category term="단상" /><summary type="html">목표는 A인데, A로 가기 위해서 B가 필요하다고?</summary></entry><entry><title type="html">2023년도 주요 프로젝트 내용과 프로젝트의 성과</title><link href="https://lahuman.github.io/2023_project/" rel="alternate" type="text/html" title="2023년도 주요 프로젝트 내용과 프로젝트의 성과" /><published>2023-11-27T00:00:00+00:00</published><updated>2023-11-27T00:00:00+00:00</updated><id>https://lahuman.github.io/2023_project</id><content type="html" xml:base="https://lahuman.github.io/2023_project/">&lt;h1 id=&quot;2023년도-수행했던-주요-프로젝트-내용과-프로젝트의-성과&quot;&gt;2023년도 수행했던 주요 프로젝트 내용과 프로젝트의 성과&lt;/h1&gt;

&lt;p&gt;입사 후 진행 한 22년 4월 부터 진행된 O모O모의 개발 총괄을 맡았습니다. 
O모O모는 2022년 11월에 서비스를 시작하였고, 초기 매타버스 기반(유니티-외주)에서 웹 기반(내재화)의 커뮤니티로 변화를 꾀하며  &lt;code class=&quot;highlighter-rouge&quot;&gt;2023년 5월에 10만 회원을 돌파&lt;/code&gt; 후, 23년 11월 기준 약 &lt;code class=&quot;highlighter-rouge&quot;&gt;25만명의 회원이 사용하는 서비스&lt;/code&gt;로 성장했습니다.&lt;/p&gt;

&lt;p&gt;회사에서 처음으로 클라우드 기반의 개발로 진행하였고, 외부에서 입사한 동료들과의 함께 하는 첫  프로젝트였습니다.&lt;/p&gt;

&lt;p&gt;초기 프로젝트를 진행할 때, 이전 회사인 GSSHOP에서 진행하였던 애자일 방식의 개발을 도입하였습니다.
저의 경우는 팀원으로만 참여하였던 애자일 방식에서 처음으로 스크럼에 마스터가 되어서 진행하였습니다.&lt;/p&gt;

&lt;p&gt;진행 방식으로는 매일 아침 스크럼 미팅을 하고, 매 2주간 스프린트를 진행하였습니다. 
스프린트가 종료 되면 회고를 하고 그라운드 룰을 함께 만들어가며 동료들과 진행하였습니다.&lt;/p&gt;

&lt;p&gt;JIRA와 Confluence, Slack 기반으로 업무, 지식공유, 소통을 하였습니다. 
다들 처음에는 어색해하였지만, 2번의 스프린트(4주)가 지나자 익숙해지며 좋은 결과를 만들어 갈 수 있었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고 내용 : &lt;a href=&quot;https://lahuman.github.io/going_scrum/&quot;&gt;합시다, 스크럼&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;NODEJS를 처음 사용하는 동료를 위해서 코드 리뷰를 통한 성장을 지원하고, 제가 가진 지식을 기반으로 추가적인 학습 시간과 학습 내용을 공유 하는 시간을 매 스프린트 회고마다 가졌습니다.&lt;/p&gt;

&lt;p&gt;Backend 개발시 유지보수를 고려해서 typescript 기반의 프레임워크인 Nestjs로 진행하고 필요한 Boilerplate code를 제공하였습니다.
마찬가지로 관리자 페이지 역시 Reactjs + MUI로 구성을 개발 할 수 있도록 Boilerplate code를 작성하였습니다.&lt;/p&gt;

&lt;p&gt;또한 프로젝트 막바지에는 클라우드 엔지니어와 함께 AWS 기반의 CI/CD를 code commit 기반으로 구성하고, 
 개발서버에서 운영서버까지의 소스코드의 파이프라인에 대하여 함께 논의하며 구축하였습니다.&lt;/p&gt;

&lt;p&gt;결론적으로 O모O모의 성과는 좋았고, 이는 저 혼자의 힘으로 해낼 수 없는 일이었습니다.
저를 믿고 따라준 동료들과 함께여서 좋은 성과를 내었다고 2023년을 회고합니다.&lt;/p&gt;</content><author><name></name></author><category term="O모O모" /><category term="role" /><category term="scrum" /><summary type="html">2023년도 회고 &amp; 경험</summary></entry><entry><title type="html">지금 기분이 태도가 되지 않게</title><link href="https://lahuman.github.io/20231117/" rel="alternate" type="text/html" title="지금 기분이 태도가 되지 않게" /><published>2023-11-17T00:00:00+00:00</published><updated>2023-11-17T00:00:00+00:00</updated><id>https://lahuman.github.io/20231117</id><content type="html" xml:base="https://lahuman.github.io/20231117/">&lt;h1 id=&quot;기분이-태도가-되지-않게&quot;&gt;&lt;a href=&quot;https://www.yes24.com/Product/Goods/90872322&quot;&gt;기분이 태도가 되지 않게&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;책을 읽고 반성하는 하루 입니다.&lt;/p&gt;

&lt;p&gt;년중 행사처럼 쓰는 말이지만, 불평 불만을 줄이도록 노력해야겠습니다.&lt;/p&gt;

&lt;p&gt;특히 통제할 수 없는 불평 불만은 하지 않도록 조심해야겠습니다.&lt;/p&gt;

&lt;p&gt;책은 명상을 하듯이 조금씩 곱씹으면 읽기 좋습니다.&lt;/p&gt;</content><author><name></name></author><category term="독서" /><summary type="html">도서 후기</summary></entry><entry><title type="html">내가 생각하는 개발자란?</title><link href="https://lahuman.github.io/what_is_developer/" rel="alternate" type="text/html" title="내가 생각하는 개발자란?" /><published>2023-10-20T00:00:00+00:00</published><updated>2023-10-20T00:00:00+00:00</updated><id>https://lahuman.github.io/what_is_developer</id><content type="html" xml:base="https://lahuman.github.io/what_is_developer/">&lt;h1 id=&quot;문제를-해결하는-사람&quot;&gt;문제를 해결하는 사람&lt;/h1&gt;

&lt;p&gt;신입 개발자 때 목표는,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;코딩을 잘한다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;10년쯤 지났을 때 목표는,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;좋은 품질의 코드를 작성한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;지금의 내 목표는,&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;가치 있는 코드&lt;/code&gt;(기술)로 문제를 해결한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;나에게-가치-있는-코드란&quot;&gt;나에게 가치 있는 코드란?&lt;/h1&gt;

&lt;h2 id=&quot;최소한의-코드-품질을-유지하면서-더-큰-가치를-만들-수-있는-요구-사항을-찾아-구현하고-주어진-일정을-지킨다&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;최소한의 코드 품질을 유지&lt;/code&gt;하면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;더 큰 가치를 만들 수 있는 요구 사항을 찾아 구현&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;주어진 일정을 지킨다&lt;/code&gt;&lt;/h2&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;good-cheap-fast-triangle&quot;&gt;Good, Cheap, Fast Triangle&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/good_cheap_fast_triangle.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;서비스의 가치&lt;/code&gt;를 높이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;품질을 유지&lt;/code&gt;하면서, 시기와 상황에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;적절한 균형점&lt;/code&gt;을 잡아는 노력 필요&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;최소한의-코드-품질을-유지&quot;&gt;최소한의 코드 품질을 유지&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;적절한 코드 품질을 지키는 것은 늘 어렵다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하지만, 최소한의 코드 품질을 지키기 위한 노력은 필요하다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;명확하고 간결한 코드(읽기 쉬운 코드)&lt;/li&gt;
  &lt;li&gt;코드 스타일 가이드 준수&lt;/li&gt;
  &lt;li&gt;단위 테스트&lt;/li&gt;
  &lt;li&gt;모듈화(추상화)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;더-큰-가치를-만들-수-있는-요구-사항을-찾아-구현&quot;&gt;더 큰 가치를 만들 수 있는 요구 사항을 찾아 구현&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;협업 그리고 이해&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;고객의 피드백 수집&lt;/li&gt;
  &lt;li&gt;지속적인 개선&lt;/li&gt;
  &lt;li&gt;실험과 반복&lt;/li&gt;
  &lt;li&gt;아이디어 공유 및 브레인스토밍&lt;/li&gt;
  &lt;li&gt;동료 및 피드백 수신&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;주어진-일정을-지킨다&quot;&gt;주어진 일정을 지킨다&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;모든건 일정 안에서 이루어져야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;우선 순위 설정&lt;/li&gt;
  &lt;li&gt;MVP(Minimum Viable Product) 구축&lt;/li&gt;
  &lt;li&gt;일정 관리 / 일일 계획&lt;/li&gt;
  &lt;li&gt;시간 관리 / 일정 조정&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;또한-개발은-코드만이-아니다&quot;&gt;또한 개발은 코드만이 아니다.&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;개발자의 진정한 역할은 코드만 만드는 게 아니라, &lt;code class=&quot;highlighter-rouge&quot;&gt;문제의 본질&lt;/code&gt;을 찾고 동료들과 함께 해결하는 전반적인 일입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;코드는 우리(개발자)가 문제를 해결하는 도구 중 하나 입니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;어떤 문제를 해결&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;어떤 가치를 창출&lt;/code&gt;하며 &lt;code class=&quot;highlighter-rouge&quot;&gt;어떤 일을 할지 결정&lt;/code&gt; 해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;늘 생각하고 있던 내용인데, 아래 내용을 읽고 얼마 제 생각을 정리 하며 작성하게 되었습니다. 위에 내용도 포함이 되어 있고 더 상세하게 잘 정리 되어 있는 내용입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@teo/collaboration&quot;&gt;협업을 잘하는 개발자가 되어보자 - 프로그래머가 아니라 문제 해결사가 되자!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="developer" /><summary type="html">중요한건 코드보다 문제 해결!</summary></entry><entry><title type="html">채팅 서비스 만들기 설계 정리</title><link href="https://lahuman.github.io/chatting_service/" rel="alternate" type="text/html" title="채팅 서비스 만들기 설계 정리" /><published>2023-10-15T00:00:00+00:00</published><updated>2023-10-15T00:00:00+00:00</updated><id>https://lahuman.github.io/chatting_service</id><content type="html" xml:base="https://lahuman.github.io/chatting_service/">&lt;h1 id=&quot;상품을-기준으로-사용자간-채팅을-할-수-있도록-설계-합니다&quot;&gt;상품을 기준으로 사용자간 채팅을 할 수 있도록 설계 합니다.&lt;/h1&gt;

&lt;h2 id=&quot;설계&quot;&gt;설계&lt;/h2&gt;

&lt;p&gt;상품을 확인하고, 판매자에게 채팅을 요청 했을때 아래와 같은 동작을 합니다.&lt;/p&gt;

&lt;div class=&quot;mermaid&quot;&gt; 
sequenceDiagram;
    actor 구매자;
    구매자-&amp;gt;&amp;gt;+서버: 상품 구매 채팅;
    activate 서버;
    Note right of 서버: 상품 판매 여부 및 사용자 검수;
    actor 판매자;
    서버-&amp;gt;&amp;gt;+판매자: 채팅 메시지 전달;
    deactivate 서버;
    서버-&amp;gt;&amp;gt;-구매자: 채팅 메시지 전달;
&lt;/div&gt;

&lt;p&gt;상품에 대한 검수를 아래과 같이 처리 하고 나면, 채팅을 전달합니다.&lt;/p&gt;

&lt;div class=&quot;mermaid&quot;&gt; 
graph TD;
    A[상품 판매 채팅 검수] --&amp;gt; B{채팅방 존재};
    B --&amp;gt;|Y| H;
    B --&amp;gt;|N| D{상품 &amp;amp; 판매자 &amp;amp; 구매자 확인};
    D --&amp;gt; |Y| F(채팅방 생성);
    D --&amp;gt; |N| E[오류 메시지 전달];
    F --&amp;gt; H(채팅 전달);
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;채팅방이 존재 하지 않고, 상품이 판매 완료인 경우 새로운 채팅방을 생성할 수 없습니다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;테이블-구조&quot;&gt;테이블 구조&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/chatting_erd.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;채팅방명은 &lt;code class=&quot;highlighter-rouge&quot;&gt;상품ID-판매자ID-구매자ID&lt;/code&gt;로 유일한 값을 가지게 됩니다.&lt;/p&gt;

&lt;p&gt;또한 마지막 판매자 구매자의 마지막 읽은 채팅ID를 가지고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;샘플을-모두-적성하였으나-코드가-너무-번잡-스러워서-정리후-올릴-예정입니다&quot;&gt;샘플을 모두 적성하였으나, 코드가 너무 번잡 스러워서 정리후 올릴 예정입니다!&lt;/h2&gt;</content><author><name></name></author><category term="chatting" /><summary type="html">당근 마켓 클론 채팅 생성</summary></entry><entry><title type="html">일하기 싫다.</title><link href="https://lahuman.github.io/20231012/" rel="alternate" type="text/html" title="일하기 싫다." /><published>2023-10-12T00:00:00+00:00</published><updated>2023-10-12T00:00:00+00:00</updated><id>https://lahuman.github.io/20231012</id><content type="html" xml:base="https://lahuman.github.io/20231012/">&lt;h1 id=&quot;이해-관계자와의-소통이-쉽지-않네요&quot;&gt;이해 관계자와의 소통이 쉽지 않네요.&lt;/h1&gt;

&lt;p&gt;주말에는 개인 개발이나 신나게 해야겠습니다.&lt;/p&gt;

&lt;p&gt;힘들땐 개발만큰 재미난게 없네요.&lt;/p&gt;

&lt;p&gt;주말이나 연휴동안 개인 프로젝트 개발만 신나게 했습니다.&lt;/p&gt;</content><author><name></name></author><category term="PM" /><summary type="html">개발이 싫은게 아니라, 지금 하는 업무가 싫다.</summary></entry></feed>
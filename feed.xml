<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2019-03-09T14:28:36+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">nodejs에서 sleep 구현하기</title><link href="https://lahuman.github.io/nodejs_sleep_inside_for/" rel="alternate" type="text/html" title="nodejs에서 sleep 구현하기" /><published>2019-03-09T00:00:00+09:00</published><updated>2019-03-09T00:00:00+09:00</updated><id>https://lahuman.github.io/nodejs_sleep_inside_for</id><content type="html" xml:base="https://lahuman.github.io/nodejs_sleep_inside_for/">&lt;h1 id=&quot;nodejs에서-sleep-구현하기&quot;&gt;nodejs에서 sleep 구현하기&lt;/h1&gt;

&lt;p&gt;nodejs에서 for문에 비동기 처리가 들어 있으면 해당 비동기 처리가 종료 되는 것을 기다려 주지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 Sleep 같은 처리를 하려면 많은 신경을 써야 한다.&lt;/p&gt;

&lt;p&gt;참고 자료를 기반으로 처리해보니 잘된다.&lt;/p&gt;

&lt;p&gt;내가 하려는데도 문제 없이 반영되는지 월요일에 확인해봐야겠다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const init = async () =&amp;gt; {
    for (let i=0; i&amp;lt;5; i++){
        console.log(1);
        await sleep(1000);
        console.log(2);
    }
 }
 const sleep = (ms) =&amp;gt; {
     return new Promise(resolve=&amp;gt;{
         setTimeout(resolve,ms)
     })
 }

init();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;쉬운게없다&quot;&gt;쉬운게없다&lt;/h2&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14249506/how-can-i-wait-in-node-js-javascript-l-need-to-pause-for-a-period-of-time&quot;&gt;How Can I Wait In Node.js (Javascript), l need to pause for a period of time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="sleep" /><summary type="html">nodejs는 for 문이 기본적으로 비동기로 동작하니 주의 할 것!</summary></entry><entry><title type="html">인증서버 구축기 - 3</title><link href="https://lahuman.github.io/auth_server_3/" rel="alternate" type="text/html" title="인증서버 구축기 - 3" /><published>2019-03-04T00:00:00+09:00</published><updated>2019-03-04T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_3</id><content type="html" xml:base="https://lahuman.github.io/auth_server_3/">&lt;h1 id=&quot;로그인-성공시-jwt를-이용하여-token-전송&quot;&gt;로그인 성공시 JWT를 이용하여 Token 전송&lt;/h1&gt;

&lt;h2 id=&quot;jwt&quot;&gt;&lt;a href=&quot;https://jwt.io&quot;&gt;JWT&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;jwt-설명-내용&quot;&gt;JWT 설명 내용&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSON Web Token(JWT)는 JSON 객체로 당사자간에 안전하게 정보를 전송할수 있는 작고 독립적인 방법을 정의하는 공개 표준(&lt;a href=&quot;https://tools.ietf.org/html/rfc7519&quot;&gt;RFC 7519&lt;/a&gt;)입니다. 이 정보는 디지털 서명되기 때문에 검증되고 신뢰할 수 있습니다. JWT는 RSA/ECDSA를 이용한 공개키/개인키 또는 암호화(HMAC 알고리즘)를 이용하여 서명할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;jwt-사용-예시&quot;&gt;JWT 사용 예시&lt;/h3&gt;

&lt;h4 id=&quot;로그인-후속-처리&quot;&gt;로그인 후속 처리&lt;/h4&gt;

&lt;p&gt;가장 많이 사용되는 방법으로 사용자가 로그인 하면 후속 요청에 JWT가 포함되어 사용자가 해당 토큰으로 허용되는 경로, 서비스 및 리소스 액세스 할 수 있게 한다. 또한 JWT를 이용한 SSO(Single Sign On)은 오버헤드가 적고 다른 도메인에서 쉽게 사용할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;정보-교환&quot;&gt;정보 교환&lt;/h4&gt;

&lt;p&gt;JSON 웹 토큰은 당사자간에 정보를 안전하게 전송하는 좋은 방법이다. JWT는 서명을 할 수 있기 때문에 발신자에 대한 확인과 내용의 변조 여부를 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;json-구조&quot;&gt;JSON 구조&lt;/h3&gt;

&lt;p&gt;JSON은 dots(.)을 기준으로 3가지로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Header&lt;/li&gt;
  &lt;li&gt;Payload&lt;/li&gt;
  &lt;li&gt;Signature&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 형태로 되어 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aaaaaa.zzzzzz.yyyyyy
______.______.______
Header.Payload.Signature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Header는 타입과 알고리즘 두가지 정보를 가지고 있다.&lt;/p&gt;

&lt;p&gt;Payload는 클레임(claim)이라고 명칭되는 name/value 한쌍으로 이루어 져 있다.&lt;/p&gt;

&lt;p&gt;클레임은 세 분류로 나눈다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;등록된(registred) 클레임 : iss(발급자), exp(만료시간), sub(주제), aud(잠재고객) 등이다.&lt;/li&gt;
  &lt;li&gt;공개(public) 클레임 : 자유롭게 정의할수 있다. 충돌을 방지하기 위해 URI 형식을 권장한다.&lt;/li&gt;
  &lt;li&gt;비공개(private) 클레임: 보통 클라이언트와 서버간 협의하에 사용되는 클레임 이름이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;JWT의 등록된 클레임 이름의 길이는 3자이다. 또한 서명된 토큰의 경우 변조되지 않도록 보호는 되지만 모든 사람이 읽을 수 있다. 암호화되지 않은 JWT의 페이로드 또는 헤더 요소에 비밀 정보를 넣으면 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Signature는 Header와 Payload의 인코딩 값을 합친후 주어진 비밀키로 해쉬를 생성 한다.&lt;/p&gt;

&lt;h2 id=&quot;jwt-구현-하기&quot;&gt;JWT 구현 하기&lt;/h2&gt;

&lt;p&gt;기존 프로젝트 코드에서 jsonwebtoken을 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; npm install --save jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 router/index.js파일에서 해당 모듈을 이용해서 로그인 성공시 Token을 전달하고, isAdmin 토큰을 검증하고 ROLE_TEST1을 가지고 있을 경우만 통과 하도록 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...모듈 추가...
const jwt = require('jsonwebtoken');

...로그인 성공시...
const token = jwt.sign(userInfo, secretKey, { expiresIn: '5m' });
res.json({ status: 'success', token });

...isAdmin...
const isAdmin = (req, res, next) =&amp;gt; {
  try {
    const decoded = jwt.verify(req.header('X-token'), secretKey);
    if (decoded.role.includes(roleAdmin)) {
      next();
    }
    else {
      res.json({ status: 403, message: 'Login failed' });
    }
  }
  catch (error) {
    res.json({ status: 500, message: `token Error: ${error.message}` });
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음시간에는 사용자 암호에 대한 해쉬알고리즘을 이용한 암호화 처리를 진행하자.&lt;/p&gt;

&lt;h3 id=&quot;금방끝나네&quot;&gt;금방끝나네!&lt;/h3&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io&quot;&gt;JWT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="auth" /><summary type="html">JWT를 이용하여 로그인 성공시 Token 전송</summary></entry><entry><title type="html">인증서버 구축기 - 2</title><link href="https://lahuman.github.io/auth_server_2/" rel="alternate" type="text/html" title="인증서버 구축기 - 2 " /><published>2019-03-02T00:00:00+09:00</published><updated>2019-03-02T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_2</id><content type="html" xml:base="https://lahuman.github.io/auth_server_2/">&lt;h1 id=&quot;간단하게-dbms-구현과-로그인-처리&quot;&gt;간단하게 DBMS 구현과 로그인 처리&lt;/h1&gt;

&lt;p&gt;인증서버 구현에 대한 설계만 하고 손도 안되고 생각만 하고 있었다.&lt;/p&gt;

&lt;p&gt;DBMS는 다음 그림과 같은 형태로 구현했다.&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;/assets/img/post_img/auth_erd.png&quot;&gt;&lt;img src=&quot;/assets/img/post_img/auth_erd.png&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;AUTH server ERD&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이번 시간에는 Login API를 구현하고 테스트까지 진행한다.&lt;/p&gt;

&lt;h2 id=&quot;모델-구현&quot;&gt;모델 구현&lt;/h2&gt;

&lt;p&gt;모델을 구현하기 위하여 &lt;a href=&quot;https://github.com/sequelize/express-example&quot;&gt;Sequelize Express Example&lt;/a&gt;를 참조 하였다.&lt;/p&gt;

&lt;p&gt;DBMS를 참고 하여 각 모델을 다음과 같이 작성 하였다.&lt;/p&gt;

&lt;h3 id=&quot;users&quot;&gt;Users&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var User = sequelize.define('Users', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    user_id: { type: DataTypes.STRING(50), allowNull: false, unique: true },
    password: { type: DataTypes.STRING(100), allowNull: false },
    description: { type: DataTypes.STRING(1000), allowNull: true }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: true
  });


  User.associate = (models) =&amp;gt; {
    models.Users.belongsToMany(models.Roles, { through: 'UserRoles', foreignKey: 'u_id' });
  };

  return User;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;roles&quot;&gt;Roles&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var Roles = sequelize.define('Roles', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    role_name: { type: DataTypes.STRING(20), allowNull: false, unique: true },
    description: { type: DataTypes.STRING(1000), allowNull: true }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: true
  });

  Roles.associate = (models) =&amp;gt; {
    models.Roles.belongsToMany(models.Users, { through: 'UserRoles', foreignKey: 'r_id' });
  };

  return Roles;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;userroles&quot;&gt;UserRoles&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var UserRole = sequelize.define('UserRoles', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    r_id: {
      type: DataTypes.INTEGER
    },
    u_id: {
      type: DataTypes.INTEGER
    }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true
  });
  return UserRole;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가적으로 LoginHistory를 구현하였고 최근 10분간 로그인이 5회 실패시 잠시 후 시도하도록 했다.&lt;/p&gt;

&lt;h3 id=&quot;loginhistorys&quot;&gt;LoginHistorys&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
module.exports = (sequelize, DataTypes) =&amp;gt; {
    var LoginHistory = sequelize.define('LoginHistorys', {
      id: {
        type: DataTypes.INTEGER,
        autoIncrement: true,
        primaryKey: true
      },
      user_id: { type: DataTypes.STRING(50), allowNull: false },
      login_success: { type: DataTypes.STRING(1), allowNull: false, defaultValue:'Y' }
    }, {
      freezeTableName: true,
      underscored: true,
      timestamps: true,
      paranoid: true
    });
  
    return LoginHistory;
  };
  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;로그인-구현&quot;&gt;로그인 구현&lt;/h2&gt;

&lt;p&gt;로그인은 간단하게 routers/index.js 에 구현하였다. 추가로 다른 기능이 생긴다면 디렉토리를 추가하여 처리 할 예정이다.&lt;/p&gt;

&lt;h3 id=&quot;login-process&quot;&gt;Login Process&lt;/h3&gt;

&lt;p&gt;10분동안 5회 이상의 로그인 실패가 있을 경우 잠시후 시도하라는 메시지가 표출되며, 로그인 실패/성공은 LoginHistory에 저장된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.post('/login', (req, res, next) =&amp;gt; {
  const loginInfo = req.body;
  if (!Object.prototype.hasOwnProperty.call(loginInfo, 'user_id')
    || !Object.prototype.hasOwnProperty.call(loginInfo, 'password')) {
    res.json({ status: 'error', message: 'Invalid Prameter' });
  }
  else {
    models.LoginHistorys.count({ where: { user_id: loginInfo.user_id, login_success: 'N', created_at: { [models.Sequelize.Op.gt]: moment().subtract(20, 'minutes').toDate() } } }).then((c) =&amp;gt; {
      if (c &amp;gt; 5) {
        res.json({ status: 'error', message: 'Login failed several times. Please try again in 10 minutes.' });
      }
      else {
        models.Users.findOne({
          where: { user_id: loginInfo.user_id, password: loginInfo.password },
          include: [models.Roles]
        }).then((u) =&amp;gt; {
          if (u) {
            const userInfo = {
              user_id: u.user_id,
              password: u.password,
              desc: u.description,
              role: u.Roles.map(r =&amp;gt; r.role_name)
            };
            res.json({ status: 'success', userInfo });
            loginInfo.login_success = 'Y';
          }
          else {
            res.json({ status: 'error', message: 'check ID or PW' });
            loginInfo.login_success = 'N';
          }
          models.LoginHistorys.create(loginInfo);
        });
      }
    });
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;todo-진행-예정&quot;&gt;TODO 진행 예정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io/&quot;&gt;JWT&lt;/a&gt;를 이용하여 로그인 성공시 전송되는 내용을 토큰 처리&lt;/li&gt;
  &lt;li&gt;토큰 validate API 제공&lt;/li&gt;
  &lt;li&gt;사용자 PASSWORD hash 암호화 처리(&lt;a href=&quot;https://epthffh.tistory.com/entry/SHA256-%EC%9D%B8%EC%BD%94%EB%94%A9-%EC%86%8C%EC%8A%A4&quot;&gt;SHA-256&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;나머지도-하나씩-처리-하자&quot;&gt;나머지도 하나씩 처리 하자!&lt;/h3&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;</content><category term="node" /><category term="auth" /><summary type="html">로그인 처리와 HISTORY 기록</summary></entry><entry><title type="html">상상 하기</title><link href="https://lahuman.github.io/20190302/" rel="alternate" type="text/html" title="상상 하기" /><published>2019-03-02T00:00:00+09:00</published><updated>2019-03-02T00:00:00+09:00</updated><id>https://lahuman.github.io/20190302</id><content type="html" xml:base="https://lahuman.github.io/20190302/">&lt;h1 id=&quot;상상력은-정말-끊없다&quot;&gt;상상력은 정말 끊없다.&lt;/h1&gt;

&lt;p&gt;나는 소설책(무협지, 판타지, 만화 등)을 좋아한다. 현실 세계에 있을 수는 없지만 작가의 시점에서 주인공을 따라 새로운 세상을 함께 여행하는 일은 정말 즐겁다.&lt;/p&gt;

&lt;p&gt;가끔 작가가 만든 틀에서 벗어나 내 마음 가는대로 이야기를 상상하기도 한다.&lt;/p&gt;

&lt;p&gt;그러다 재미있는 상상을 했다.&lt;/p&gt;

&lt;h2 id=&quot;상상의-세계&quot;&gt;상상의 세계&lt;/h2&gt;

&lt;h3 id=&quot;법칙&quot;&gt;법칙&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;사람들이 생각하는 세상은 다른 차원의 세상이 된다.&lt;/li&gt;
  &lt;li&gt;사람들의 상상은 다른 차원의 세계를 구성하는 힘이 된다.&lt;/li&gt;
  &lt;li&gt;많은 사람들이 함께 상상 할 수록 더욱 강력하고 튼튼한 세상이 만들어 진다.&lt;/li&gt;
  &lt;li&gt;튼튼하지 못한 세상은 사람들에게서 잊혀지고, 곧 멸망하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;법칙을-넘어서&quot;&gt;법칙을 넘어서&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;상상의 세계는 기본적으로 사람들의 상상이 기본이 되지만, 많은 사람들이 특정 인물에 대하여 상상을 하게 되면 그 상상의 인물은 다른 사람의 가튼 상상으로 연결된다. 연결된 상상은 자아를 가지게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;많은 사람들이 함께 상상하는 세상은 튼튼함을 넘어 자아를 가지게 된다. 자아를 가진 상상의 세계는 연결된 사람들에게 이야기를 전할 수도 있다. 이러한 상상의 세계는 현재 세상의 종교가 된다.&lt;/p&gt;

&lt;h3 id=&quot;멸망하는-상상의-세계&quot;&gt;멸망하는 상상의 세계&lt;/h3&gt;

&lt;p&gt;사람들이 상상의 세상을 잊게 되면 해당 상상의 세계는 점점 작아지고 결국 멸망하게 된다. 멸망을 한 상상의 세계는 회색빛으로 변하고 시간과 공간이 멈춰진다. 상상의 세계의 멸망이 끝을 나타내지는 않는다. 누군가가 다시 상상을 하면 상상하는 부분부터 조금씩 다시 시작 되게 된다.&lt;/p&gt;

&lt;h3 id=&quot;이런-저런-잡생각을-해본다&quot;&gt;이런 저런 잡생각을 해본다&lt;/h3&gt;

&lt;h2 id=&quot;기타&quot;&gt;기타&lt;/h2&gt;

&lt;p&gt;요즘 논증의 탄생이라는 책을 보고 있다. 논문을 쓰면서 교수님이 지도해주신 많은 내용과 동일한 내용을 담고 있었다.&lt;/p&gt;

&lt;p&gt;글(논문)쓰기를 하면서 내 주장을 어떻게 표현 해야 하는지 남의 글을 어떻게 인용해야 하는지에 알려준다.&lt;/p&gt;

&lt;p&gt;그 책을 보고 있으니 내가 상상하는 세상을 글로 써보고 싶다.&lt;/p&gt;</content><category term="단상" /><summary type="html">많은 상상을 해보고 있음</summary></entry><entry><title type="html">AWS ec2 key 생성 &amp;amp; 로그인</title><link href="https://lahuman.github.io/aws_login_user_key/" rel="alternate" type="text/html" title="AWS ec2 key 생성 &amp; 로그인" /><published>2019-02-28T00:00:00+09:00</published><updated>2019-02-28T00:00:00+09:00</updated><id>https://lahuman.github.io/aws_login_user_key</id><content type="html" xml:base="https://lahuman.github.io/aws_login_user_key/">&lt;h1 id=&quot;aws에서-ec2-로그인-계정-생성-처리-방법&quot;&gt;AWS에서 EC2 로그인 계정 생성 처리 방법&lt;/h1&gt;

&lt;p&gt;현재 설정은 AWS에서 EC2 인스턴스(ubunt 기반)를 생성 후 접속은 pem 파일을 이용하도록 되어있다.&lt;/p&gt;

&lt;p&gt;하나의 pem 파일을 이용하는 것은 보안에도 좋지 않고, 초기 계정은 Root 권한을 가질 수 있는 계정이기에 위험하다. 따라서 EC2에 접근 가능한 추가 계정을 생성하는 것을 알아보자.&lt;/p&gt;

&lt;p&gt;AWS의 EC2 서버에서 먼저 계정을 생성 한다. 현재 계정은 root 권한을 가진 ubuntu(기본)이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 계정 생성
$&amp;gt; sudo useradd lahuman
# 생성된 계정으로 계정 변경
$&amp;gt; sudo su - lahuman
# .ssh 디렉토리 생성 &amp;amp; authorized_keys 파일 생성
$&amp;gt; mkdir .ssh
$&amp;gt; chmod 700 .ssh
$&amp;gt; cd .ssh
$&amp;gt; touch authorized_keys
$&amp;gt; chmod 600 authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;계정 생성이 완료 되었으면 &lt;kbd&gt;EC2&lt;/kbd&gt; &amp;gt; &lt;kbd&gt;네트워크 및 보안&lt;/kbd&gt; &amp;gt; &lt;kbd&gt;키 페어&lt;/kbd&gt; 메뉴로 이동을 하여 &lt;kbd&gt;키 페어 생성&lt;/kbd&gt; 버튼을 클릭한다.&lt;/p&gt;

&lt;p&gt;키 페어 명을 넣고 생성을 하면 &lt;kbd&gt;pem 파일&lt;/kbd&gt;이 자동으로 down 된다. 이 pem 파일은 무척 중요하다!&lt;/p&gt;

&lt;p&gt;이 pem 파일을 EC2 서버의 아까 생성한 계정 밑으로 복사 한다.&lt;/p&gt;

&lt;p&gt;이후 다음 명령어를 이용하여 public Key를 생성하고 해당 키 값을 authorized_keys에 저장한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# upload 된 pem 의 권한을 600 으로 수정한다.
$&amp;gt; chmod 500 lahuman.pem
# public key 생성
$&amp;gt; ssh-keygen -y
Enter file in which the key is (/home/lahuman/.ssh/id_rsa): /home/lahuman/lahuman.pem
ssh-rsa ABCDEF........key......

# ssh-rsa 이후 키 값을 복사하여 authorized_keys 에 추가한다.
$&amp;gt; vi .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 내 자리에서 pem 파일을 이용해서 로그인을 시도 하면 잘 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; ssh -i &quot;lahuman.pem&quot; lahuman@IP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;쉬운-듯-어려운-설정&quot;&gt;쉬운 듯 어려운 설정&lt;/h2&gt;</content><category term="pem" /><category term="cert" /><summary type="html">AWS에서 key(pem)을 생성하고 로그인까지 해보기</summary></entry><entry><title type="html">crt, key 인증서 파일 pem으로 변환</title><link href="https://lahuman.github.io/cet_key_to_pem/" rel="alternate" type="text/html" title="crt, key 인증서 파일 pem으로 변환" /><published>2019-02-27T00:00:00+09:00</published><updated>2019-02-27T00:00:00+09:00</updated><id>https://lahuman.github.io/cet_key_to_pem</id><content type="html" xml:base="https://lahuman.github.io/cet_key_to_pem/">&lt;h1 id=&quot;cert-key-파일을-pem-파일로-변환-하기&quot;&gt;cert, key 파일을 pem 파일로 변환 하기&lt;/h1&gt;

&lt;p&gt;nginx에서 사용하던 인증서를 nodejs에서 바로 사용을 하기 위해 pem 파일 형식으로 변경 해야하는 일이 생겨서 검색을 해보았다.
파일 형석의 변환은 다음과 같이 쉽게 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# key 변경
openssl rsa -in server.key -text &amp;gt; private.pem
# crt 변경
openssl x509 -inform PEM -in server.crt &amp;gt; public.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;추가-팁-nodejs-에서-https-설정&quot;&gt;추가 팁] nodejs 에서 https 설정&lt;/h2&gt;
&lt;p&gt;nodejs에서 https 사용을 위해서는 https 모듈을 추가로 설치 해야 한다.&lt;/p&gt;

&lt;p&gt;이후 소스내에 다음과 같이 인증서를 &lt;strong&gt;options&lt;/strong&gt;을 추가 하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const https = require('https');
const fs = require('fs');
const options = {
  ca: fs.readFileSync('인증서경로/ca-bundle.pem')
  key: fs.readFileSync('인증서경로/domain_xxxxx.key.pem')
  cert: fs.readFileSync('인증서경로/domain_xxxxx.crt.pem')
};
https.createServer(options, (req, res) =&amp;gt; {
  res.writeHead(200);
  res.end('hello world\n');
}).listen(443);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;참-쉽죠&quot;&gt;참 쉽죠?&lt;/h3&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/991758/how-to-get-pem-file-from-key-and-crt-files&quot;&gt;How to get .pem file from .key and .crt files?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.securesign.kr/guides/Node-js-SSL-Certificates-Install&quot;&gt;Node.js SSL 인증서 설치/적용 가이드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="pem" /><category term="cert" /><summary type="html">인증서 파일 형식 변경 처리 &amp; node 에서 https 사용설정</summary></entry><entry><title type="html">요즘 진행된 일들을 정리를 못하고 있다.</title><link href="https://lahuman.github.io/20190227/" rel="alternate" type="text/html" title="요즘 진행된 일들을 정리를 못하고 있다." /><published>2019-02-27T00:00:00+09:00</published><updated>2019-02-27T00:00:00+09:00</updated><id>https://lahuman.github.io/20190227</id><content type="html" xml:base="https://lahuman.github.io/20190227/">&lt;h1 id=&quot;요즘-많은-새로운-것을-익히기도-하고-기존에-해-보았던-것도-다시-해보고-있다&quot;&gt;요즘 많은 새로운 것을 익히기도 하고, 기존에 해 보았던 것도 다시 해보고 있다.&lt;/h1&gt;

&lt;p&gt;이직을 하고 3개월이 흘렀다. 
월급을 3번 받아 보았고, 제대로된 급여는 2번 받아 보았다.&lt;/p&gt;

&lt;p&gt;이직하고 달라진 점드를 뽑으면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용하는 언어가 달라 졌다.
    &lt;ul&gt;
      &lt;li&gt;10여년간 사용하던 JAVA에서 Python을 거쳐 Nodejs를 사용하고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;바쁘게 일한다.
    &lt;ul&gt;
      &lt;li&gt;20대 후반에 하는 방식으로 일하고 있다.&lt;/li&gt;
      &lt;li&gt;변화를 두려워 하지 않고 일단 해본다.&lt;/li&gt;
      &lt;li&gt;안되면 동료에게 물어본다.&lt;/li&gt;
      &lt;li&gt;새로운 도전을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이젠 시니어다.
    &lt;ul&gt;
      &lt;li&gt;주니어 개발자와 함께 일하며, 주니어 개발자가 발전 할 수 있는 조언을 주어야 한다.&lt;/li&gt;
      &lt;li&gt;꼰대 같은 생각이 든다.&lt;/li&gt;
      &lt;li&gt;나도 모르게 “내 생각이 옳다고만 생각 한다.”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장점도 있고 단점도 있지만 이직 자체는 성공적이다.&lt;/p&gt;

&lt;p&gt;기존 회사보다 일도 많아지고 책임도 커졌지만, 무엇보다 즐겁다.&lt;/p&gt;

&lt;h3 id=&quot;반성해-하는-점&quot;&gt;반성해 하는 점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;또 오지랍을 부리고 있다.
    &lt;ul&gt;
      &lt;li&gt;내 일이나 잘하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;은근 슬쩍 잘하는 사람에게 일을 미룬다.
    &lt;ul&gt;
      &lt;li&gt;함께 하는 동료중에 잘하는 분이 계신데 너무 믿고 있는건지 내일도 슬쩍 미룬다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;잘난척 한다.
    &lt;ul&gt;
      &lt;li&gt;이건 대 반성 하자…&lt;/li&gt;
      &lt;li&gt;좀 조용하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;반성-하면-변화하는-내가-되자&quot;&gt;반성 하면 변화하는 내가 되자&lt;/h3&gt;</content><category term="단상" /><summary type="html">바쁘다는 핑계로 정리를 못하고 있다.</summary></entry><entry><title type="html">MongoDB backup &amp;amp; restore</title><link href="https://lahuman.github.io/mongodb_backup_restore/" rel="alternate" type="text/html" title="MongoDB backup &amp; restore" /><published>2019-02-23T00:00:00+09:00</published><updated>2019-02-23T00:00:00+09:00</updated><id>https://lahuman.github.io/mongodb_backup_restore</id><content type="html" xml:base="https://lahuman.github.io/mongodb_backup_restore/">&lt;h1 id=&quot;mongodb-backup--restore&quot;&gt;MongoDB backup &amp;amp; restore&lt;/h1&gt;

&lt;p&gt;간단하게 몽고 디비 백업과 복구를 해보겠다.&lt;/p&gt;

&lt;p&gt;먼저 백업 명령은 다음과 같다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 결과로 디렉터리가 생성 된다.
# 특정 collection 명이나 DB 명을 Backup 할 수 있다.
$&amp;gt; mongodump --collection words --db TEST --out ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 복원 하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 특정 컬렉션만 복원 할 수 있으며 --drop  옵션을 추가 하면 삭제하고 복원 한다.
$&amp;gt; mongorestore --host 172.30.10.1 --port 27017 --db TEST --collection words --username tester --password 'password'  ./TEST/words.bson --drop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;가끔씩-쓸일이-생긴다&quot;&gt;가끔씩 쓸일이 생긴다.&lt;/h2&gt;</content><category term="mongodb" /><category term="tip" /><summary type="html">몽고 DB 백업 &amp; 리스토어</summary></entry><entry><title type="html">AWS LAMBDA를 이용해서 개발하다</title><link href="https://lahuman.github.io/Aws_Lambda/" rel="alternate" type="text/html" title="AWS LAMBDA를 이용해서 개발하다" /><published>2019-02-20T00:00:00+09:00</published><updated>2019-02-20T00:00:00+09:00</updated><id>https://lahuman.github.io/Aws_Lambda</id><content type="html" xml:base="https://lahuman.github.io/Aws_Lambda/">&lt;h1 id=&quot;aws-lambda-를-개발시-알면-좋은-팁&quot;&gt;AWS LAMBDA 를 개발시 알면 좋은 팁&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Lambda를 API Gateway를 통해서 호출 하도록 설정 할때 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&quot;&gt;매핑 템플릿
&lt;/a&gt;을 사용하면 IP 등의 정보를 얻을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Lambda에서 RDS에 접근하기 위해서는 VPC를 설정해야 한다.&lt;/li&gt;
  &lt;li&gt;VPC가 설정된 Lambda는 외부 인터넷에 접근 할 수 없다.&lt;/li&gt;
  &lt;li&gt;VPC가 설정된 Lambda는 내부 private IP만 접근 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다시 사용할 일이 올지는 모르겠지만, 재미있었다.&lt;/p&gt;

&lt;h3 id=&quot;신기술은-늘-어렵다-근데-써보고-나면-별거-없다&quot;&gt;신기술은 늘 어렵다. 근데 써보고 나면 별거 없다.&lt;/h3&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&quot;&gt;API Gateway 매핑 템플릿 참조
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.shikisoft.com/running-aws-lambda-in-vpc-accessing-rds/?fbclid=IwAR2-KHd23Db2PnVfm1JKDW_WoanfKRe2oamcsAhO1-mJomvta_EHNzoppVk&quot;&gt;Running AWS Lambda Functions in a VPC and Accessing RDS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="aws" /><category term="tip" /><summary type="html">작은 모듈을 사용할때 좋을 듯!</summary></entry><entry><title type="html">Async 모듈을 이용한 비동기 처리</title><link href="https://lahuman.github.io/node_async/" rel="alternate" type="text/html" title="Async 모듈을 이용한 비동기 처리" /><published>2019-02-12T00:00:00+09:00</published><updated>2019-02-12T00:00:00+09:00</updated><id>https://lahuman.github.io/node_async</id><content type="html" xml:base="https://lahuman.github.io/node_async/">&lt;h1 id=&quot;얼마전-node에서-비동기-처리를-순서대로-처리해야-하는-일이-있었다&quot;&gt;얼마전 Node에서 비동기 처리를 순서대로 처리해야 하는 일이 있었다.&lt;/h1&gt;

&lt;p&gt;구글을 검색하다 &lt;a href=&quot;https://stackoverflow.com/questions/31799175/async-waterfall-in-a-for-loop-in-node-js?fbclid=IwAR3Mx9ZXS8qxNhKQqgSqB8KIFmIko031E0uCmhPFkAiXY0mFR5UAs5Y-_XA&quot;&gt;async.waterfall in a For Loop in Node.js&lt;/a&gt;을 찾았다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var async = require(&quot;async&quot;)
var users = []; // Initialize user array or get it from DB

async.forEachLimit(users, 1, function(user, userCallback){

    async.waterfall([
        function(callback) {
            callback(null, 'one', 'two');
        },
        function(arg1, arg2, callback) {
            // arg1 now equals 'one' and arg2 now equals 'two'
            callback(null, 'three');
        },
        function(arg1, callback) {
            // arg1 now equals 'three'
            callback(null, 'done');
        }
    ], function (err, result) {
        // result now equals 'done'
        console.log('done')
        userCallback();
    });


}, function(err){
    console.log(&quot;User For Loop Completed&quot;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async&lt;/a&gt;는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;async, await&lt;/a&gt;인줄 알았는데, 비동기 처리에 사용하는 모듈 이었다.&lt;/p&gt;

&lt;p&gt;70 여 가지 모듈을 지원하며, 예제도 잘 나와 있다.&lt;/p&gt;

&lt;p&gt;이중 제어 관련하여 다음의 매소드 등이 제공된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XXXLimit : 한번에 처리 하는 Worker 갯수 지정&lt;/li&gt;
  &lt;li&gt;XXXSeries : 한개씩 처리&lt;/li&gt;
  &lt;li&gt;waterfall : 여러 비동기 처리를 순차적으로 처리&lt;/li&gt;
  &lt;li&gt;parallel : 콜렉션을 병렬 처리&lt;/li&gt;
  &lt;li&gt;apply : 인수 처리&lt;/li&gt;
  &lt;li&gt;map : 새로운 컬렉션을 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 외에도 많은 기능이 제공된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Async provides around 70 functions that include the usual ‘functional’ suspects (map, reduce, filter, each…) as well as some common patterns for asynchronous control flow (parallel, series, waterfall…). All these functions assume you follow the Node.js convention of providing a single callback as the last argument of your asynchronous function – a callback which expects an Error as its first argument – and calling the callback once.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;비동기-처리를-할때-사용하면-상당히-유용하다&quot;&gt;비동기 처리를 할때 사용하면 상당히 유용하다.&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31799175/async-waterfall-in-a-for-loop-in-node-js?fbclid=IwAR3Mx9ZXS8qxNhKQqgSqB8KIFmIko031E0uCmhPFkAiXY0mFR5UAs5Y-_XA&quot;&gt;async.waterfall in a For Loop in Node.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31815917/how-to-skip-a-async-foreachof-loop-iteration-in-node-js&quot;&gt;How to Skip a “async.forEachOf” loop iteration in Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="tip" /><summary type="html">병렬, 직렬, 순서 등 비동기 제어에 도움이 되는 모듈</summary></entry></feed>

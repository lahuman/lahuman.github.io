<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2019-02-12T23:29:41+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">Async 모듈을 이용한 비동기 처리</title><link href="https://lahuman.github.io/node_async/" rel="alternate" type="text/html" title="Async 모듈을 이용한 비동기 처리" /><published>2019-02-12T00:00:00+09:00</published><updated>2019-02-12T00:00:00+09:00</updated><id>https://lahuman.github.io/node_async</id><content type="html" xml:base="https://lahuman.github.io/node_async/">&lt;h1 id=&quot;얼마전-node에서-비동기-처리를-순서대로-처리해야-하는-일이-있었다&quot;&gt;얼마전 Node에서 비동기 처리를 순서대로 처리해야 하는 일이 있었다.&lt;/h1&gt;

&lt;p&gt;구글을 검색하다 &lt;a href=&quot;https://stackoverflow.com/questions/31799175/async-waterfall-in-a-for-loop-in-node-js?fbclid=IwAR3Mx9ZXS8qxNhKQqgSqB8KIFmIko031E0uCmhPFkAiXY0mFR5UAs5Y-_XA&quot;&gt;async.waterfall in a For Loop in Node.js&lt;/a&gt;을 찾았다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var async = require(&quot;async&quot;)
var users = []; // Initialize user array or get it from DB

async.forEachLimit(users, 1, function(user, userCallback){

    async.waterfall([
        function(callback) {
            callback(null, 'one', 'two');
        },
        function(arg1, arg2, callback) {
            // arg1 now equals 'one' and arg2 now equals 'two'
            callback(null, 'three');
        },
        function(arg1, callback) {
            // arg1 now equals 'three'
            callback(null, 'done');
        }
    ], function (err, result) {
        // result now equals 'done'
        console.log('done')
        userCallback();
    });


}, function(err){
    console.log(&quot;User For Loop Completed&quot;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async&lt;/a&gt;는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;async, await&lt;/a&gt;인줄 알았는데, 비동기 처리에 사용하는 모듈 이었다.&lt;/p&gt;

&lt;p&gt;70 여 가지 모듈을 지원하며, 예제도 잘 나와 있다.&lt;/p&gt;

&lt;p&gt;이중 제어 관련하여 다음의 매소드 등이 제공된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XXXLimit : 한번에 처리 하는 Worker 갯수 지정&lt;/li&gt;
  &lt;li&gt;XXXSeries : 한개씩 처리&lt;/li&gt;
  &lt;li&gt;waterfall : 여러 비동기 처리를 순차적으로 처리&lt;/li&gt;
  &lt;li&gt;parallel : 콜렉션을 병렬 처리&lt;/li&gt;
  &lt;li&gt;apply : 인수 처리&lt;/li&gt;
  &lt;li&gt;map : 새로운 컬렉션을 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 외에도 많은 기능이 제공된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Async provides around 70 functions that include the usual ‘functional’ suspects (map, reduce, filter, each…) as well as some common patterns for asynchronous control flow (parallel, series, waterfall…). All these functions assume you follow the Node.js convention of providing a single callback as the last argument of your asynchronous function – a callback which expects an Error as its first argument – and calling the callback once.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;비동기-처리를-할때-사용하면-상당히-유용하다&quot;&gt;비동기 처리를 할때 사용하면 상당히 유용하다.&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31799175/async-waterfall-in-a-for-loop-in-node-js?fbclid=IwAR3Mx9ZXS8qxNhKQqgSqB8KIFmIko031E0uCmhPFkAiXY0mFR5UAs5Y-_XA&quot;&gt;async.waterfall in a For Loop in Node.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31815917/how-to-skip-a-async-foreachof-loop-iteration-in-node-js&quot;&gt;How to Skip a “async.forEachOf” loop iteration in Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="tip" /><summary type="html">병렬, 직렬, 순서 등 비동기 제어에 도움이 되는 모듈</summary></entry><entry><title type="html">인증서버 구축기 - 1</title><link href="https://lahuman.github.io/auth_server_1/" rel="alternate" type="text/html" title="인증서버 구축기 - 1 " /><published>2019-02-09T00:00:00+09:00</published><updated>2019-02-09T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_1</id><content type="html" xml:base="https://lahuman.github.io/auth_server_1/">&lt;h1 id=&quot;간단한-인증-서버를-구축-해보자&quot;&gt;간단한 인증 서버를 구축 해보자!&lt;/h1&gt;

&lt;p&gt;인증 서버를 구축해보려고 한다.&lt;/p&gt;

&lt;p&gt;간단하게 설계는 다음과 같이 했다.&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;/assets/img/post_img/auth_service.png&quot;&gt;&lt;img src=&quot;/assets/img/post_img/auth_service.png&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;AUTH server Sequence diagram&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;개발 언어는 &lt;a href=&quot;https://nodejs.org/ko/&quot;&gt;Node.js&lt;/a&gt;를 이용하여 개발 계획이다.&lt;/p&gt;

&lt;p&gt;이미 Auth Server를 구현한 샘플이 많아서 새로운 것은 아니지만, 새로운 기술을 배우는 것을 목적으로 진행한다.&lt;/p&gt;

&lt;p&gt;Frontend는 &lt;a href=&quot;https://kr.vuejs.org/v2/guide/index.html&quot;&gt;vue.js&lt;/a&gt;를 사용해보고 ORM 툴인 &lt;a href=&quot;http://docs.sequelizejs.com/&quot;&gt;sequelizejs&lt;/a&gt;도 사용할 계획이다.&lt;/p&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;</content><category term="node" /><category term="auth" /><summary type="html">기존에는 완료된 프로젝트만 적었는데, 진행하는 과정을 남겨 보자</summary></entry><entry><title type="html">nodejs에서 request Body에 json 처리 &amp;amp; body 크기 제한</title><link href="https://lahuman.github.io/node_bodyParser/" rel="alternate" type="text/html" title="nodejs에서 request Body에 json 처리 &amp; body 크기 제한" /><published>2019-02-06T00:00:00+09:00</published><updated>2019-02-06T00:00:00+09:00</updated><id>https://lahuman.github.io/ node_bodyParser</id><content type="html" xml:base="https://lahuman.github.io/node_bodyParser/">&lt;h1 id=&quot;express에서-post호출-시-request의-body에서-undefined가-발생한다&quot;&gt;Express에서 post호출 시 request의 body에서 undefined가 발생한다.&lt;/h1&gt;

&lt;p&gt;다음과 같이 호출 했는데 결과가 undefined일 경우는 body-parser를 설정하지 않아서 이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# post 호출시, body에 {test:'hello&quot;} 를 함께 전송

#router 소스
router.post('/', (req, res) =&amp;gt; {
  console.log(req.body); undefined 발생
  res.redirect('/');
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처리 방법은 body-parser를 express에서 사용하도록 설정 하면된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# body-parser 설치
$&amp;gt; npm install --save body-parser

#app.js 소스
const express = require('express');
const bodyParser = require('body-parser');

const app = express();
app.use(bodyParser().json()); //bodyparser 사용 설정
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 만나는 문제는 body의 크기가 크다는 오류를 만난 수 있다.
이때는 body의 크기를 옵션 설정하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const bodyParser = require('body-parser');
app.use(bodyParser.json({limit: '50mb'})); //body 의 크기 설정
app.use(bodyParser.urlencoded({limit: '50mb', extended: true})); //url의 크기 설정
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가로 express 4.16부터는 body-parser를 포함 하고 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const express = require('express')
const app = express();
app.use(express.json())
app.post('/', (req, res) =&amp;gt; {
  console.log(req.body)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;알아두자&quot;&gt;알아두자&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/9049993/node-js-how-to-limit-the-http-request-size-and-upload-file-size&quot;&gt;node-js-how-to-limit-the-http-request-size-and-upload-file-size&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://expressjs.com/en/4x/api.html#express-json-middleware&quot;&gt;express-json-middleware&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="bodyparser" /><summary type="html">express 4.16이상에서는 body-Pararse가 내장되어 있다.</summary></entry><entry><title type="html">Node 모듈 설치시 오류시 해결 방법</title><link href="https://lahuman.github.io/node_tip/" rel="alternate" type="text/html" title="Node 모듈 설치시 오류시 해결 방법" /><published>2019-02-04T00:00:00+09:00</published><updated>2019-02-04T00:00:00+09:00</updated><id>https://lahuman.github.io/node_tip</id><content type="html" xml:base="https://lahuman.github.io/node_tip/">&lt;h1 id=&quot;node-모듈-설치시-오류시-해결-방법&quot;&gt;Node 모듈 설치시 오류시 해결 방법&lt;/h1&gt;

&lt;p&gt;node 버젼이 변경된 상태에서 npm install을 하면, 오류가 발생하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;이럴때 해결 방법은 정말 단순 하다.&lt;/p&gt;

&lt;p&gt;해당 모듈을 삭제 하고 재설치 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install
#oracle-db 모듈 오류발생

#oracle-db 모듈 삭제
npm uninstall oracle-db

#oracle-db 모듈 설치
npm install --save oracle-db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;컴터-동작이-이상하면-재기동-하면-되듯이-모듈도-재설치-하면된다&quot;&gt;컴터 동작이 이상하면 재기동 하면 되듯이, 모듈도 재설치 하면된다.&lt;/h2&gt;</content><category term="node" /><category term="tip" /><summary type="html">npm install 시 오류 발생시 처리 방안</summary></entry><entry><title type="html">pm2 cluster mode 특징</title><link href="https://lahuman.github.io/pm2_cluster_mode/" rel="alternate" type="text/html" title="pm2 cluster mode 특징" /><published>2019-02-03T00:00:00+09:00</published><updated>2019-02-03T00:00:00+09:00</updated><id>https://lahuman.github.io/pm2_cluster_mode</id><content type="html" xml:base="https://lahuman.github.io/pm2_cluster_mode/">&lt;h1 id=&quot;pm2-cluster-mode에서는-session이나-websocket이-동작-하지-않는다&quot;&gt;pm2 cluster mode에서는 session이나 websocket이 동작 하지 않는다.&lt;/h1&gt;

&lt;p&gt;pm2에서 제공하는 클러스터 모드는 코드의 수정 없이 CPU를 확장할 수 있다. Node.js 클러스터 모듈을 사용하여 확장 된 응용 프로그램의 하위 프로세스가 자동으로 서버 포트를 공유 하도록 하는 기능이다.&lt;/p&gt;

&lt;p&gt;사용법은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -i 옵션이 cluster 모드이며, max는 사용할 CPU 수를 입력 하면 된다.
# 0을 입력하면, 자동으로 모든 CPU 숫자만큼 클러스터가 생성된다.
pm2 start app.js -i max
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;또는 js/yaml/json 파일을 통해서 설정을 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;apps&quot; : [{
    &quot;script&quot;    : &quot;api.js&quot;,
    &quot;instances&quot; : &quot;max&quot;,
    &quot;exec_mode&quot; : &quot;cluster&quot; 
  }]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cluster Mode를 사용하면 가장 중요한게 &lt;a href=&quot;http://pm2.keymetrics.io/docs/usage/specifics/#stateless-apps&quot;&gt;stateless application&lt;/a&gt;이 된다는 것이다.&lt;/p&gt;

&lt;p&gt;이 상태에서는 가중 중요한게 로컬 데이터 저장소를 프로세스에서 사용할수 없다는 것이다. 사용을 하고 싶으면, &lt;a href=&quot;https://github.com/tj/connect-redis&quot;&gt;connect-redis&lt;/a&gt;과 같은 프로그램을 이용하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;session이-동작하지-않아서-한참-해멧다&quot;&gt;Session이 동작하지 않아서 한참 해멧다.&lt;/h2&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://pm2.keymetrics.io/docs/usage/cluster-mode/&quot;&gt;cluster-mode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pm2.keymetrics.io/docs/usage/specifics/#stateless-apps&quot;&gt;stateless-apps&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tj/connect-redis&quot;&gt;connect-redis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="pm2" /><category term="cluster" /><summary type="html">session 동작을 하지 않는다.</summary></entry><entry><title type="html">Vuejs를 express로 배포 후 vuejs route 동작 처리</title><link href="https://lahuman.github.io/vue_build_route/" rel="alternate" type="text/html" title="Vuejs를 express로 배포 후 vuejs route 동작 처리" /><published>2019-01-30T00:00:00+09:00</published><updated>2019-01-30T00:00:00+09:00</updated><id>https://lahuman.github.io/vue_build_route</id><content type="html" xml:base="https://lahuman.github.io/vue_build_route/">&lt;h1 id=&quot;vuejs-배포시-route-동작-처리&quot;&gt;Vuejs 배포시 route 동작 처리&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://lahuman.github.io/vuejs_express_helloworld/&quot;&gt;vuejs에서 express로 배포하는 방식을 기존에 설명 했었다.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;문제는 vuejs route에 주소를 직접 치고 들어가면 404 오류가 발생하였다.&lt;/p&gt;

&lt;p&gt;express쪽에서 기본적인 요청은 vuejs의 route를 바라보게 하고 싶어서 검색을 해보니, &lt;a href=&quot;https://github.com/egoist/vuepack/issues/138?fbclid=IwAR1KiC3mfi5E_2D8p3DGIxw_2_APSQ60oKAASmuwqfNKQvtWQq5heAt09to&quot;&gt;Routes not working in production&lt;/a&gt;라는 글을 확인 하였다.&lt;/p&gt;

&lt;p&gt;처리 방법은 express에 마지막 부분에 다음 코드를 추가 하면 된다.
index.html은 vuejs를 배포한 위치이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('*', (req, res) =&amp;gt; {
  res.sendFile(`${__dirname}/public/index.html`);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;vuejs도-잼나네&quot;&gt;vuejs도 잼나네!&lt;/h3&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/egoist/vuepack/issues/138?fbclid=IwAR1KiC3mfi5E_2D8p3DGIxw_2_APSQ60oKAASmuwqfNKQvtWQq5heAt09to&quot;&gt;Routes not working in production&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://router.vuejs.org/guide/essentials/history-mode.html?fbclid=IwAR2DbYoXnGUeYzeNeu289E7XsIVwX3XEE5dTSdntOZwe9-bti98P1sIPZ1E#example-server-configurations&quot;&gt;HTML5 History Mode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vue" /><summary type="html">Vuejs URL을 호출 하면 404가 발생하지 않게 하기</summary></entry><entry><title type="html">How to fix this is undefined in Vue.</title><link href="https://lahuman.github.io/vue_method_this/" rel="alternate" type="text/html" title="How to fix this is undefined in Vue." /><published>2019-01-23T00:00:00+09:00</published><updated>2019-01-23T00:00:00+09:00</updated><id>https://lahuman.github.io/vue_method_this</id><content type="html" xml:base="https://lahuman.github.io/vue_method_this/">&lt;h1 id=&quot;how-to-fix-this-is-undefined-in-vue&quot;&gt;How to fix “this is undefined” in Vue.&lt;/h1&gt;

&lt;p&gt;Vue를 써보고 있는데, Vue 안에 method를 선언하고 this를 호출하니 undefined가 발생하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export default {
  methods: {
    sayHello: () =&amp;gt; {
    	this.val = 'hello';
    	console.log(this.val);
    }
  },
  data() {
	  return {
	  	val: ''
	  }
  }
}

#### 결과
this is undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원인을 찾아 보니 다음과 같은 내용을 확인했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;If you try to access this from inside of an arrow function that’s on a Vue component, you’ll get an error because this doesn’t exist!&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Vue 구성 요소에있는 화살표 함수 내부에서 this에 액세스하려고 하면 존재하지 않기 때문에 오류가 발생합니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vue 구성 요소 안에서 this를 사용하려면 화살표 함수를 사용하지 말아야 한다는 내용이다. 다음과 같이 수정하면 잘 동작한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export default {
  methods: {
    sayHello() {
    	this.val = 'hello';
    	console.log(this.val);
    }
  },
  data() {
	  return {
	  	val: ''
	  }
  }
}

#### 결과
hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;화살표 함수는 익명 함수를 만들때 사용하며, 다음과 같은 이유로 사용됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보다 짧고 응축된 구문&lt;/li&gt;
  &lt;li&gt;향상된 가독성&lt;/li&gt;
  &lt;li&gt;this 주변상황에서 취해진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vue의 method 내부에서 사용하는 것은 크게 문제가 없지만, method 자체를 화살표 함수로 선언할 경우 this를 사용할 수 없다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Vue 내부에서 화살표 함수 사용 예
data() {
  return {
    match: 'This is a message',
  };
},
computed: {
  filteredMessages(messages) {
    console.log(this); // Our Vue component
    
    const filteredMessages = messages.filter(
      // References our Vue Component
      (message) =&amp;gt; message.includes(this.match)
    );
    
    return filteredMessages;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://michaelnthiessen.com/this-is-undefined/&quot;&gt;How to fix “this is undefined” in Vue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vue" /><summary type="html">Vue에서 this is undefined를 고치는 방법</summary></entry><entry><title type="html">How To Use Winston to Log Node.js Applications</title><link href="https://lahuman.github.io/winston_app-root-path/" rel="alternate" type="text/html" title="How To Use Winston to Log Node.js Applications" /><published>2019-01-21T00:00:00+09:00</published><updated>2019-01-21T00:00:00+09:00</updated><id>https://lahuman.github.io/winston_app-root-path</id><content type="html" xml:base="https://lahuman.github.io/winston_app-root-path/">&lt;h1 id=&quot;how-to-use-winston-to-log-nodejs-applications&quot;&gt;How To Use Winston to Log Node.js Applications&lt;/h1&gt;

&lt;p&gt;간단하게 설정만 작성하는 것으로 원본자료 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-use-winston-to-log-node-js-applications&quot;&gt;How To Use Winston to Log Node.js Applications&lt;/a&gt;을 보세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var appRoot = require('app-root-path');
var winston = require('winston');

// define the custom settings for each transport (file, console)
var options = {
  file: {
    level: 'info',
    filename: `${appRoot}/logs/app.log`,
    handleExceptions: true,
    json: true,
    maxsize: 5242880, // 5MB
    maxFiles: 5,
    colorize: false,
  },
  console: {
    level: 'debug',
    handleExceptions: true,
    json: false,
    colorize: true,
  },
};

// instantiate a winston.createLogger with the settings defined above
var logger = winston.createLogger({
  transports: [
    new winston.transports.File(options.file),
    new winston.transports.Console(options.console)
  ],
  exitOnError: false, // do not exit on handled exceptions
});

// create a stream object with a 'write' function that will be used by `morgan`
logger.stream = {
  write: function(message, encoding) {
    // use the 'info' log level so the output will be picked up by both transports (file and console)
    logger.info(message);
  },
};

module.exports = logger;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;요렇게 설정만 해놓아도 기본으로 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;추가로 알게된 &lt;a href=&quot;https://www.npmjs.com/package/app-root-path&quot;&gt;App Root Path Module&lt;/a&gt; 도 꽤 유용해보인다.&lt;/p&gt;

&lt;p&gt;app의 root path를 제공하여 다음과 같이 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#1 
var appRoot = require('app-root-path');
var myModule = require(appRoot + '/lib/my-module.js');

#2
var reqlib = require('app-root-path').require;
var myModule = reqlib('/lib/my-module.js');

#3
// In app.js
global.reqlib = require('app-root-path').require;
 
// In lib/module/component/subcomponent.js
var myModule = reqlib('/lib/my-module.js');

#4
var myModulePath = require('app-root-path').resolve('/lib/my-module.js');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;좋은게 많은데 몰라서 못쓴다.&lt;/p&gt;

&lt;p&gt;공부 많이 좀 해야겠다. 요즘 게을러져서 공부도 안하고 그냥 날로 먹을라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-use-winston-to-log-node-js-applications&quot;&gt;How To Use Winston to Log Node.js Applications&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/app-root-path&quot;&gt;App Root Path Module&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="winston" /><summary type="html">winston 설정을 하다 찾은 추가 모듈까지 설명</summary></entry><entry><title type="html">구글 콜라보에서 제공하는 주피터 노트북</title><link href="https://lahuman.github.io/20190119/" rel="alternate" type="text/html" title="구글 콜라보에서 제공하는 주피터 노트북" /><published>2019-01-19T00:00:00+09:00</published><updated>2019-01-19T00:00:00+09:00</updated><id>https://lahuman.github.io/20190119</id><content type="html" xml:base="https://lahuman.github.io/20190119/">&lt;p&gt;#함께 일하시는 분이 주피터 노트북을 사용하는 것을 보았다.&lt;/p&gt;

&lt;p&gt;요청사항에 대하여 크롤링하고 간단하게 화면에 통계를 뽑는 것을 주피터를 이용하여 뚝딱 하는 모습을 보았다.&lt;/p&gt;

&lt;p&gt;존멋! 나도 해보고 싶어서 요청 드려서 배웠다.&lt;/p&gt;

&lt;p&gt;일단 &lt;a href=&quot;https://colab.research.google.com&quot;&gt;구글 콜라보&lt;/a&gt;에서 새로운 프로젝트를 생성한다.&lt;/p&gt;

&lt;p&gt;필요한 모듈의 설치는 느낌펴(!)를 붙여서 설치하며 절차 지향적으로 프로그램을 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#모듈 설치
!pip install pandas
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;값을 확인하고 싶으면 그냥 해당 변수를 쓴다(약간 matlab 같은 느낌이다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = &quot;hello&quot;
# 이렇게 하면 출력 된다.
a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파이썬을 이용한 머신러닝, 딥러닝 실전 개발 입문 이라는 책에서 나오는 예제를 돌려 보았다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
from sklearn import svm
xor_data = [
    #P, Q, result
    [0,0,0],
    [0,1,1],
    [1,0,1],
    [1,1,0]
]

data = []
label = []
for row in xor_data:
  p = row[0]
  q = row[1]
  r = row[2]
  data.append([p,q])
  label.append(r)

clf = svm.SVC()
clf.fit(data, label)

pre = clf.predict(data)
print(&quot;예측결과&quot;, pre)

ok = 0; total = 0
for idx , answer in enumerate(label):
  p = pre[idx]
  if p == answer: 
    ok += 1
  total += 1
  
print(&quot;정답율:&quot;, ok, '/', total, &quot;=&quot;, ok/total)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘된다. 자주 써주마!&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jupyter.org/&quot;&gt;주피터&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://colab.research.google.com&quot;&gt;구글 콜라보&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="단상" /><summary type="html">이거물건일세!</summary></entry><entry><title type="html">사람이 점점 뻔뻔하고 말이 너무 많아진다.</title><link href="https://lahuman.github.io/20190112/" rel="alternate" type="text/html" title="사람이 점점 뻔뻔하고 말이 너무 많아진다." /><published>2019-01-12T00:00:00+09:00</published><updated>2019-01-12T00:00:00+09:00</updated><id>https://lahuman.github.io/20190112</id><content type="html" xml:base="https://lahuman.github.io/20190112/">&lt;p&gt;#누구 이야기냐고? 나야…&lt;/p&gt;

&lt;p&gt;요즘 함께 일하는 분에게 되도 않는 조언을 하고 있다.&lt;/p&gt;

&lt;p&gt;말하고 나서 뒤돌아서면, 괜한 오지랍 같다.&lt;/p&gt;

&lt;p&gt;내 앞가림이나 잘하고 살자.&lt;/p&gt;

&lt;p&gt;그리고 말좀 적게 해라 이놈아!!!&lt;/p&gt;

&lt;h2 id=&quot;넌-말이-너무-많아&quot;&gt;넌 말이 너무 많아&lt;/h2&gt;</content><category term="단상" /><summary type="html">잘 익은 벼일수록 고개를 숙인다는데...</summary></entry></feed>

<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2019-03-22T11:52:29+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">리더 또는 사수라 불리는 자리에 있다.</title><link href="https://lahuman.github.io/20190322/" rel="alternate" type="text/html" title="리더 또는 사수라 불리는 자리에 있다." /><published>2019-03-22T00:00:00+09:00</published><updated>2019-03-22T00:00:00+09:00</updated><id>https://lahuman.github.io/20190322</id><content type="html" xml:base="https://lahuman.github.io/20190322/">&lt;h1 id=&quot;어떤-리더가-되어야-할까&quot;&gt;어떤 리더가 되어야 할까??&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;일을 시작한 지 정신을 차려보니 13년이 지났다. 어느덧 사수라고 불리며 동료에게 업무를 배정하거나, 막히는 부분에 대한 지원도 해주고 업무에 대한 조언을 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;얼마 전 꼰대 방지 5계명을 읽고 “내가 꼰대처럼 행동했구나!”라고 생각했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;꼰대-방지-5계명&quot;&gt;꼰대 방지 5계명&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;내가 틀렸을지도 모른다.&lt;/li&gt;
  &lt;li&gt;내가 바꿀 수 있는 사람은 없다.&lt;/li&gt;
  &lt;li&gt;그때는 맞고 지금은 틀리다.&lt;/li&gt;
  &lt;li&gt;말하지 않고 들어라, 답하지 말고 물어라&lt;/li&gt;
  &lt;li&gt;존경은 권리가 아니라 성취다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;요즘 좋은 리더가 되기 위하여 많은 내용을 보고 있는데,&lt;/p&gt;

&lt;p&gt;꼰대에 대한 많은 생각을 하게 된다. 
&lt;strong&gt;우황청심원&lt;/strong&gt;에 대한 내용도 기억해야 겠다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우: 우월적 지위를 잊어라.&lt;/li&gt;
  &lt;li&gt;황: (상)황이 바뀌었음을 알자.&lt;/li&gt;
  &lt;li&gt;청: 청년시절을 기억하라. 입장을 바꿔보라.&lt;/li&gt;
  &lt;li&gt;심: 심판관 노릇하지, 가르치려 하지마라&lt;/li&gt;
  &lt;li&gt;원: 원칙을 버리지 마라.﻿&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마지막으로 리더가 되었을때 조심해야 하는게 무엇일까?&lt;/p&gt;

&lt;h2 id=&quot;좋은-리더--좋은-조직&quot;&gt;좋은 리더 &amp;amp; 좋은 조직&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;동료에게서 기회를 빼앗지 마라
    &lt;ul&gt;
      &lt;li&gt;내가 잘하는 일이라고 내가 하기 보다 동료가 배울 기회를 제공하라&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;무능한 사람은 버려라
    &lt;ul&gt;
      &lt;li&gt;실패와 무능은 다르다. 생산적 실패는 용인하고 무능함을 근절하는 것사이에서 건강한 균형을 유지하는건 쉬운 일이 아니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조언을 하지 마라
    &lt;ul&gt;
      &lt;li&gt;듣는 사람에게 고역일 뿐이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;하지만-나는&quot;&gt;하지만 나는…&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;지금까지 일하면서 동료와 함께 많이 배우고 서로 자신만의 영역을 만들고 해당 영역에서는 최고의 전문가가 되기 위해 노력 하였다.&lt;/p&gt;

  &lt;p&gt;부족한 동료의 발전을 위해 많은 시도를 했고, 동료가 스스로 노력하기를  기대 하였다.&lt;/p&gt;

  &lt;p&gt;좋은 방향으로 이끌어 가도록 조언을 많이 하였다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결국 그냥 꼰대 짓을 한것이 아닌가 싶다.&lt;/p&gt;

&lt;p&gt;얼마전에 함께 일했던 동료가 나로 인해 힘들었다는 이야기도 들었다.&lt;/p&gt;

&lt;h2 id=&quot;꼰대가-되지-않도록-노력하자&quot;&gt;꼰대가 되지 않도록 노력하자.&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jjalbox.com/vfgFF&quot;&gt;꼰대 방지 5계명&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=jJCiXkizKwA&quot;&gt;꼰대 5계명 - 나이들수록 명심해야할 5가지 - 꼰대 되지 않는 법 - 우황청심원&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.hbrkorea.com/magazine/article/view/2_1/page/1/article_no/1284&quot;&gt;혁신적 조직문화에 관한 냉혹한 진실&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="단상" /><summary type="html">많은 종류의 리더가 있다.</summary></entry><entry><title type="html">Frontend 에서 Npm 모듈 사용하기</title><link href="https://lahuman.github.io/npm_frontend-dependencies/" rel="alternate" type="text/html" title="Frontend 에서 Npm 모듈 사용하기" /><published>2019-03-20T00:00:00+09:00</published><updated>2019-03-20T00:00:00+09:00</updated><id>https://lahuman.github.io/npm_frontend-dependencies</id><content type="html" xml:base="https://lahuman.github.io/npm_frontend-dependencies/">&lt;h1 id=&quot;frontend-에서-npm-모듈-사용하기&quot;&gt;Frontend 에서 Npm 모듈 사용하기&lt;/h1&gt;

&lt;p&gt;지금 일하는 곳에서 frontend 모듈 의존성 관리를 위해서 &lt;a href=&quot;https://bower.io/&quot;&gt;Bower&lt;/a&gt;를 사용하고 있다. 하지만 Bower를 더 이상 사용하지 말고 &lt;a href=&quot;https://yarnpkg.com/lang/en/&quot;&gt;Yarn&lt;/a&gt;나 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;를 사용하라고 추천 하고 있다.&lt;/p&gt;

&lt;p&gt;Node의 모듈 의존성 관리를 위해 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;을 사용하고 있는데, Npm으로 frontend 까지 처리하고 싶은 욕심이 생겨서 좀 검색을 해보다가 &lt;a href=&quot;https://www.npmjs.com/package/frontend-dependencies&quot;&gt;frontend-dependencies&lt;/a&gt;을 찾았다.&lt;/p&gt;

&lt;p&gt;단순하게 node_modules에 있는 특정 디렉토리 또는 파일을 원하는 곳으로 복사하는 기능이지만, 이 정도면 충분한거 같아서 사용하고 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 설치 
npm install --save frontend-dependencies
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치 이후에 package.json 에 설정을 해줘야 한다. 다음은 &lt;a href=&quot;https://www.npmjs.com/package/frontend-dependencies&quot;&gt;frontend-dependencies&lt;/a&gt;의 full example를 발췌 하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;frontend-dependencies-test&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;frontend-dependencies test project&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;author&quot;: &quot;Matias Surdi &amp;lt;matias@surdi.net&amp;gt;&quot;,
  &quot;license&quot;: &quot;Apache-2.0&quot;,
  &quot;dependencies&quot;: { },
  &quot;devDependencies&quot;: {
    &quot;shelljs&quot;: &quot;0.7.4&quot;
  },
  ## 추가되는 내용!!!
  &quot;frontendDependencies&quot;: {
    &quot;target&quot;: &quot;static/&quot;,
    &quot;packages&quot;: {
      &quot;jquery&quot;: {             // npm package name
          &quot;version&quot;: &quot;3.1.0&quot;, // for `npm install`: version, tag or version range
          &quot;src&quot;: &quot;dist/*&quot;     // relative path in package to copy files
          &quot;namespaced&quot;: true  // extra parent folder with package Name
      },
      &quot;normalize.css&quot;: { // copy whole package
          &quot;version&quot;: &quot;4.2.0&quot;
      },
      &quot;turbolinks&quot;: {
          // alternative to 'version`: specifie git url, tarball url, tarball file, folder
          &quot;url&quot;: &quot;git://github.com/turbolinks/turbolinks.git&quot;,     
          &quot;src&quot;: &quot;{src,LICENSE}&quot;, // copy multiple files
          &quot;target&quot;: &quot;static/turbo&quot; // specific target path
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;내 경우에는 특정 파일을 지정하기 귀찮아서 전체 파일을 복사하게 아래와 같이 사용하고 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;frontendDependencies&quot;: {
    &quot;target&quot;: &quot;public/static/&quot;,
    &quot;packages&quot;: {
      &quot;jquery&quot;: {
        &quot;version&quot;: &quot;3.1.0&quot;,
        &quot;namespace&quot;: true
      },
      &quot;bootstrap&quot;: {
        &quot;version&quot;: &quot;4.3.1&quot;,
        &quot;namespace&quot;: true
      },
      &quot;axios&quot;: {
        &quot;version&quot;: &quot;^0.18.0&quot;,
        &quot;namespace&quot;: true
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 실제 파일을 복사하기 위해 다음과 같은 명령어를 실행해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 파일 복사 진행
node ./node_modules/frontend-dependencies/index.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단하게 package.json에 scripts에 추가해서 사용해도 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &quot;scripts&quot;: {
        &quot;postinstall&quot;: &quot;node ./node_modules/frontend-dependencies/index.js&quot;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;이렇게-하면-npm으로-하나만으로-backend와-frontend의-의존성을-관리-할-수-있다&quot;&gt;이렇게 하면 npm으로 하나만으로 backend와 frontend의 의존성을 관리 할 수 있다.&lt;/h2&gt;

&lt;h2 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://bower.io/&quot;&gt;Bower&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yarnpkg.com/lang/en/&quot;&gt;Yarn&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/frontend-dependencies&quot;&gt;frontend-dependencies&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="frontend" /><summary type="html">frontend-dependencies를 이용해서 복사 기능을 사용하자!</summary></entry><entry><title type="html">형태소 분석기 API 개발</title><link href="https://lahuman.github.io/morphs_api/" rel="alternate" type="text/html" title="형태소 분석기 API 개발" /><published>2019-03-18T00:00:00+09:00</published><updated>2019-03-18T00:00:00+09:00</updated><id>https://lahuman.github.io/morphs_api</id><content type="html" xml:base="https://lahuman.github.io/morphs_api/">&lt;h1 id=&quot;형태소-분석기-api-개발&quot;&gt;형태소 분석기 API 개발&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://konlpy.org&quot;&gt;KoNLPy&lt;/a&gt;라는 형태소 분석기가 있다. 이 프로그램은 한국어 정보처리를 위한 파이썬 패키지입니다.&lt;/p&gt;

&lt;p&gt;간단하게 원하는 형태소를 분석하여 줍니다.&lt;/p&gt;

&lt;p&gt;2개의 API를 만들고, 한개는 형태소를 분석한 결과를 리턴하고, 다른 한개는 명사만 리턴 하도록 작성하였습니다.
(형태소 분석기가 다해줌..)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;를 써보려했으나, 손이 많이 가서 &lt;a href=&quot;http://flask.pocoo.org/&quot;&gt;Flask&lt;/a&gt;를 이용하였습니다.&lt;/p&gt;

&lt;p&gt;API 주요 코드는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from flask import Flask
from flask import request
from flask import Response
from flask import json
from flask import make_response
from konlpy.tag import Mecab
from functools import wraps


mecab = Mecab()
app = Flask(__name__)

@app.route('/api/morphs', methods=['POST'])
def morphs():
    param = (request.get_json())
    res = make_response(json.dumps(mecab.morphs(param[&quot;text&quot;]), ensure_ascii=False))
    res.headers['Content-Type'] = 'application/json'
    return res


@app.route('/api/nouns', methods=['POST'])
def nouns():
    param = (request.get_json())
    res = make_response(json.dumps(mecab.nouns(param[&quot;text&quot;]), ensure_ascii=False))
    res.headers['Content-Type'] = 'application/json'
    return res


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000,debug=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그냥 사용할 경우 한글이 유니코드로 표출되어 추가 처리가 들어갔습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 한글 유니코드를 UTF8 처리
res = make_response(json.dumps(mecab.morphs(param[&quot;text&quot;]), ensure_ascii=False))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;간단한-api-제작하는데-2시간-걸림-끙&quot;&gt;간단한 API 제작하는데 2시간 걸림… 끙&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://konlpy.org/ko/latest/api/konlpy.tag/#module-konlpy.tag._hannanum&quot;&gt;KoNLPy-tag Package&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://flask.pocoo.org/&quot;&gt;Flask&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="morphs" /><category term="konlpy" /><summary type="html">형태소 분석기와 연결만 할뿐</summary></entry><entry><title type="html">kill 명령을 구동중인 Port 기반으로 처리</title><link href="https://lahuman.github.io/kill_by_port/" rel="alternate" type="text/html" title="kill 명령을 구동중인 Port 기반으로 처리" /><published>2019-03-17T00:00:00+09:00</published><updated>2019-03-17T00:00:00+09:00</updated><id>https://lahuman.github.io/kill_by_port</id><content type="html" xml:base="https://lahuman.github.io/kill_by_port/">&lt;h1 id=&quot;kill-명령을-구동중인-port-기반으로-처리&quot;&gt;kill 명령을 구동중인 Port 기반으로 처리&lt;/h1&gt;

&lt;p&gt;특정 port를 Listening하고 있는 PID를 kill 하는 명령어입니다.&lt;/p&gt;

&lt;p&gt;fuser 명령어는 특정 파일을 어떤 프로세스에서 사용하는지 확인할수 있다. 또한 PID를 KILL 또는 재시작도 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fuser 명령어
옵션
-a : 사용되고 있지 않은 파일까지도 표시한다.
-k : 지정된 파일과 관련된 모든 프로세스들을 KILL 한다.
-i : 프로세스를 KILL 하기전에 사용자에게 확인한다.
-n space : 지정된 공간(file, udp, or , tcp)내에서 검색한다.
-s : 결과를 간략히 출력한다.
-u : 프로세스 ID(PID)의 소유자를 보여준다.

1)특정파일이나 디렉토리를 사용하고 있는 프로세스의 PID를 확인하는 명령어
#fuser -m /etc/sshd/sshd_config  -&amp;gt; sshd_config파일을 사용하는 프로세스의 PID를 확인한다.
2)특정파일이나 디렉토리를 사용하고 있는 프로세스를 모두 죽이는 명령어
#fuser -k /usr/sbin/sshd          -&amp;gt; sshd 데몬을 사용하고 있는 프로세스를 모두 KILL한다.
3)특정프로세스(또는 데몬파일)가 실행 중에 사용한 사용한정보(user),PID정보, ACCESS상태정보,
실행명령어(COMMAND)등의 자세한 상황을 파악할수 있다

#fuser -v /usr/sbin/sshd
USER        PID    ACCESS    COMMAND
/usr/sbin/sshd:       root       3432    ...e.        sshd
                     root       5176    ...e.        sshd
                     test       5179    ...e.        sshd
ACCESS항목의  의미
- c : 현재 디렉토리를 의미함.
- e : 실행 가능함을 표시함.
- f : 열려진 파일을 의미함.(default 이므로 생략됨)
- r : root 디렉토리를 의미함.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;사용예&quot;&gt;사용예&lt;/h2&gt;

&lt;p&gt;10001 port를 사용하는 프로그램 kill&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 10001 port process kill
#!/bin/bash
sudo fuser -k 10001/tcp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://faq.hostway.co.kr/?mid=Linux_ETC&amp;amp;page=4&amp;amp;document_srl=1559&quot;&gt;리눅스에서 fuser 명령어 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="linux" /><category term="kill" /><summary type="html">kill 명령도 여러가지!</summary></entry><entry><title type="html">MongoDB aggregate 사용해보기</title><link href="https://lahuman.github.io/mongodb_aggregate/" rel="alternate" type="text/html" title="MongoDB aggregate 사용해보기" /><published>2019-03-14T00:00:00+09:00</published><updated>2019-03-14T00:00:00+09:00</updated><id>https://lahuman.github.io/mongodb_aggregate</id><content type="html" xml:base="https://lahuman.github.io/mongodb_aggregate/">&lt;h1 id=&quot;mongodb-aggregate-사용&quot;&gt;MongoDB aggregate 사용&lt;/h1&gt;

&lt;p&gt;다음과 같은 형식의 여러 ROW의 데이터를 하나의 데이터로 표현 하고 싶었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# DATA
{
    &quot;_id&quot; : ObjectId(&quot;5c864b1e1cd4038eed5b5633&quot;),
    &quot;link_tag&quot; : [ 
        &quot;#핫앤쿨&quot;, 
        &quot;#마스크팩&quot;, 
        &quot;#홈케어&quot;, 
        &quot;#리뉴메디&quot;, 
        &quot;#젊줌마&quot;, 
        &quot;#예뻐지는시간&quot;
    ],
    &quot;name&quot; : &quot;홈케어&quot;,
    &quot;text&quot; : &quot;젊어지는시간\n. .\n\n#핫앤쿨 #마스크팩 #홈케어\n#리뉴메디 #젊줌마 #예뻐지는시간&quot;,
    &quot;owner&quot; : &quot;10961953345&quot;,
    &quot;shortcode&quot; : &quot;Bu3eX2iHIFG&quot;,
    &quot;display_url&quot; : &quot;https://scontent-icn1-1.cdninstagram.com/vp/c330b55401b96aca266acca202386b42/5D08D97D/t51.2885-15/e35/54446467_181108306201409_5180562059450456961_n.jpg?_nc_ht=scontent-icn1-1.cdninstagram.com&quot;,
    &quot;is_video&quot; : false,
    &quot;accessibility_caption&quot; : &quot;Image may contain: 1 person&quot;,
    &quot;writed_date&quot; : ISODate(&quot;2019-03-11T11:44:00.000Z&quot;),
    &quot;hash&quot; : &quot;086e2b6a65b823c887ef1afc19734f67&quot;,
    &quot;createdAt&quot; : ISODate(&quot;2019-03-11T11:48:46.276Z&quot;),
    &quot;updatedAt&quot; : ISODate(&quot;2019-03-11T12:22:43.532Z&quot;),
    &quot;__v&quot; : 3
}

/* 2 */
{
    &quot;_id&quot; : ObjectId(&quot;5c864b1e1cd4038eed5b5632&quot;),
    &quot;link_tag&quot; : [ 
        &quot;#토니슈어&quot;, 
        &quot;#다낭까지와서&quot;, 
        &quot;#이러고있다&quot;, 
        &quot;#간절한걸어떡함&quot;, 
        &quot;#플라즈마&quot;, 
        &quot;#갈바닉&quot;, 
        &quot;#너네둘만믿는다&quot;, 
        &quot;#동안피부&quot;, 
        &quot;#얼굴마사지기&quot;, 
        &quot;#피부개선&quot;, 
        &quot;#탄력&quot;, 
        &quot;#피부미용기기&quot;, 
        &quot;#미용&quot;, 
        &quot;#홈케어&quot;, 
        &quot;#피부미인&quot;, 
        &quot;#데일리&quot;, 
        &quot;#뷰티&quot;, 
        &quot;#살균&quot;, 
        &quot;#셀프&quot;, 
        &quot;#피부질환&quot;, 
        &quot;#플라즈마&quot;, 
        &quot;#트러블케어&quot;, 
        &quot;#피부&quot;, 
        &quot;#피부과&quot;, 
        &quot;#선물&quot;, 
        &quot;#물광피부&quot;, 
        &quot;#보습&quot;, 
        &quot;#안티에이징&quot;, 
        &quot;#led마스크&quot;, 
        &quot;#미백&quot;, 
        &quot;#콜라겐&quot;
    ],
    &quot;name&quot; : &quot;홈케어&quot;,
    &quot;text&quot; : &quot;토니느님~ 제 피부를 10년전으로 돌려주세요\n\n제발요....♡ .\n\n#토니슈어 #다낭까지와서 #이러고있다 #간절한걸어떡함 #플라즈마 #갈바닉 #너네둘만믿는다 #동안피부 가즈앙~ \n#얼굴마사지기 #피부개선 #탄력 #피부미용기기 #미용 #홈케어 #피부미인 #데일리 #뷰티 #살균 #셀프 #피부질환 #플라즈마 #트러블케어 #피부 #피부과 #선물 #물광피부 #보습 #안티에이징 #led마스크 #미백 #콜라겐&quot;,
    &quot;owner&quot; : &quot;10698447319&quot;,
    &quot;shortcode&quot; : &quot;Bu3e2n_jrrE&quot;,
    &quot;display_url&quot; : &quot;https://scontent-icn1-1.cdninstagram.com/vp/97d840dbdea55753d2a976302f90002b/5D065CE9/t51.2885-15/fr/e15/s1080x1080/53176269_319394038719034_3474616797099883761_n.jpg?_nc_ht=scontent-icn1-1.cdninstagram.com&quot;,
    &quot;is_video&quot; : false,
    &quot;accessibility_caption&quot; : &quot;Image may contain: outdoor and water&quot;,
    &quot;writed_date&quot; : ISODate(&quot;2019-03-11T11:48:12.000Z&quot;),
    &quot;hash&quot; : &quot;c9a418d8295391c1c83553f0316d1127&quot;,
    &quot;createdAt&quot; : ISODate(&quot;2019-03-11T11:48:46.266Z&quot;),
    &quot;updatedAt&quot; : ISODate(&quot;2019-03-11T12:22:43.527Z&quot;),
    &quot;__v&quot; : 3
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원하는 결과 데이터&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
	{ &quot;tag&quot; : &quot;#미백&quot;, &quot;count&quot; : 3},
	{ &quot;tag&quot; : &quot;#물광&quot;, &quot;count&quot; : 4},
	{ &quot;tag&quot; : &quot;#보습&quot;, &quot;count&quot; : 10},
	...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;구글을 검색하니 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/update/push/&quot;&gt;$push&lt;/a&gt;명령어를 찾았다.&lt;/p&gt;

&lt;p&gt;내가 처리한 Query는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.hashtag.aggregate([
    { $match: { $and: [{ name: &quot;테그명&quot; }, { &quot;createdAt&quot;: { $gte: (new Date()), $lt: (new Date()) } }] } },
    {$unwind: &quot;$link_tag&quot;},
    {$group:{_id:null, clrs: {$push: {name: &quot;$link_tag&quot;, count:1}}}},
    {$unwind: &quot;$clrs&quot;},
    {$group:{_id:&quot;$clrs.name&quot;, size: {$sum:&quot;$clrs.count&quot;}}},
    { $sort: { size:-1} },
    { $limit : 5 },
    {$project: {_id:1, size:1 }
  ]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 처리 하면 다음과 같은 결과를 받을 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
	{ _id:&quot;#물광&quot;, size:15 },
	{ _id:&quot;#홈케어&quot;, size:13 }
	{ _id:&quot;#대일리&quot;, size:12 }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 매 시간별로 수집된 데이터를 counting 하는 query 이다.
내가 원하는 결과는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
	{&quot;date&quot;: &quot;2018-03-14 10&quot;, &quot;count&quot;:30},
	{&quot;date&quot;: &quot;2018-03-14 11&quot;, &quot;count&quot;:20},
	{&quot;date&quot;: &quot;2018-03-14 12&quot;, &quot;count&quot;:33},
	{&quot;date&quot;: &quot;2018-03-14 13&quot;, &quot;count&quot;:34}
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다행이 이번 QUERY는 한방에 처리 하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.hashtag.aggregate([
    { $match: { $and: [{ name: &quot;태그명&quot; }, { &quot;createdAt&quot;: { $gte: (new Date()), $lt: (new Date()) } }] } },
    {
      $group:
      {
        _id:
        {
          hour: { $hour: &quot;$createdAt&quot; },
          day: { $dayOfMonth: &quot;$createdAt&quot; },
          month: { $month: &quot;$createdAt&quot; },
          year: { $year: &quot;$createdAt&quot; }
        },
        value: { $sum: 1 },
        date: { $first: &quot;$createdAt&quot; },
        sortDate: { $first: &quot;$createdAt&quot; }
      }
    },
    {
      $project:
      {
        date:
        {
          $dateToString: { format: &quot;%Y-%m-%d %H&quot;, date: &quot;$date&quot; }
        },
        sortDate: 1,
        value: 1,
        _id: 0
      }
    },
    { $sort: { sortDate: 1 }}
  ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;분명히 많은 기능을 Mongodb에서 제공해주고 있는데, 잘 쓰지 못하고 있다…&lt;/p&gt;

&lt;h2 id=&quot;노력하자&quot;&gt;노력하자.&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/update/push/&quot;&gt;$push&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="mongodb" /><category term="aggregate" /><summary type="html">많은걸 제공해주는데 내가 잘 모름...</summary></entry><entry><title type="html">Mongoosejs 삽질기</title><link href="https://lahuman.github.io/mongoosejs_usage/" rel="alternate" type="text/html" title="Mongoosejs 삽질기" /><published>2019-03-12T00:00:00+09:00</published><updated>2019-03-12T00:00:00+09:00</updated><id>https://lahuman.github.io/mongoosejs_usage</id><content type="html" xml:base="https://lahuman.github.io/mongoosejs_usage/">&lt;h1 id=&quot;mongoosejs-삽질기&quot;&gt;Mongoosejs 삽질기&lt;/h1&gt;

&lt;p&gt;Mongoosejs를 최근 프로젝트에서 잘 쓰고, 에러를 만나서 한참 고생을 했다.&lt;/p&gt;

&lt;p&gt;기억에 1g도 안나서 삽질을 많이 했다.&lt;/p&gt;

&lt;p&gt;Model에서 async와 await를 사용했더니, 에러가 많이 발생하였다.&lt;/p&gt;

&lt;h2 id=&quot;model에서는-비동기-처리로-남겨-두어야-큰-문제-없이-동작한다&quot;&gt;Model에서는 비동기 처리로 남겨 두어야 큰 문제 없이 동작한다.&lt;/h2&gt;

&lt;p&gt;잊지말자!&lt;/p&gt;

&lt;p&gt;오늘 삽질일기…&lt;/p&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md&quot;&gt;puppeteer troubleshooting&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/issues/404&quot;&gt;puppeteer not working on Ubuntu 16.04 but works on 14.04&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="mongoosejs" /><summary type="html">쉬운데 어려움...</summary></entry><entry><title type="html">puppeteer를 Ubuntu에 설치하고 기동하기</title><link href="https://lahuman.github.io/puppeteer_on_ubuntu/" rel="alternate" type="text/html" title="puppeteer를 Ubuntu에 설치하고 기동하기" /><published>2019-03-11T00:00:00+09:00</published><updated>2019-03-11T00:00:00+09:00</updated><id>https://lahuman.github.io/puppeteer_on_ubuntu</id><content type="html" xml:base="https://lahuman.github.io/puppeteer_on_ubuntu/">&lt;h1 id=&quot;puppeteer를-설치하고-구동하기&quot;&gt;puppeteer를 설치하고 구동하기&lt;/h1&gt;

&lt;p&gt;설치는 아주 간단하다. npm 을 이용해서 설치 하면 바로 되는데, 문제는 설치후 기동하면 오류가 난다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 설치
npm install --save puppeteer

# 실행
node app.js

# error 발생

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;에러 메시지에서는 &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md&quot;&gt;puppeteer troubleshooting&lt;/a&gt;를 보라고 하지만, 내게 도움되는 내역이 없었다.&lt;/p&gt;

&lt;p&gt;구글의 도움을 받아 찾은 &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/issues/404&quot;&gt;puppeteer not working on Ubuntu 16.04 but works on 14.04&lt;/a&gt;에서 다음 라이브러리를 설치하라는 메시지를 확인하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install libpangocairo-1.0-0 libx11-xcb1 libxcomposite1 libxcursor1 libxdamage1 libxi6 libxtst6 libnss3 libcups2 libxss1 libxrandr2 libgconf2-4 libasound2 libatk1.0-0 libgtk-3-0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치를 하고 나서 실행하면 문제 없이 잘된다.&lt;/p&gt;

&lt;h2 id=&quot;그러하다&quot;&gt;그러하다~&lt;/h2&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md&quot;&gt;puppeteer troubleshooting&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/issues/404&quot;&gt;puppeteer not working on Ubuntu 16.04 but works on 14.04&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="puppeteer" /><summary type="html">설치는 쉬운데, 필요한 라이브러리가 있음!</summary></entry><entry><title type="html">nodejs에서 sleep 구현하기</title><link href="https://lahuman.github.io/nodejs_sleep_inside_for/" rel="alternate" type="text/html" title="nodejs에서 sleep 구현하기" /><published>2019-03-09T00:00:00+09:00</published><updated>2019-03-09T00:00:00+09:00</updated><id>https://lahuman.github.io/nodejs_sleep_inside_for</id><content type="html" xml:base="https://lahuman.github.io/nodejs_sleep_inside_for/">&lt;h1 id=&quot;nodejs에서-sleep-구현하기&quot;&gt;nodejs에서 sleep 구현하기&lt;/h1&gt;

&lt;p&gt;nodejs에서 for문에 비동기 처리가 들어 있으면 해당 비동기 처리가 종료 되는 것을 기다려 주지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 Sleep 같은 처리를 하려면 많은 신경을 써야 한다.&lt;/p&gt;

&lt;p&gt;참고 자료를 기반으로 처리해보니 잘된다.&lt;/p&gt;

&lt;p&gt;내가 하려는데도 문제 없이 반영되는지 월요일에 확인해봐야겠다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const init = async () =&amp;gt; {
    for (let i=0; i&amp;lt;5; i++){
        console.log(1);
        await sleep(1000);
        console.log(2);
    }
 }
 const sleep = (ms) =&amp;gt; {
     return new Promise(resolve=&amp;gt;{
         setTimeout(resolve,ms)
     })
 }

init();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;쉬운게없다&quot;&gt;쉬운게없다&lt;/h2&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14249506/how-can-i-wait-in-node-js-javascript-l-need-to-pause-for-a-period-of-time&quot;&gt;How Can I Wait In Node.js (Javascript), l need to pause for a period of time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="sleep" /><summary type="html">nodejs는 for 문이 기본적으로 비동기로 동작하니 주의 할 것!</summary></entry><entry><title type="html">인증서버 구축기 - 3</title><link href="https://lahuman.github.io/auth_server_3/" rel="alternate" type="text/html" title="인증서버 구축기 - 3" /><published>2019-03-04T00:00:00+09:00</published><updated>2019-03-04T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_3</id><content type="html" xml:base="https://lahuman.github.io/auth_server_3/">&lt;h1 id=&quot;로그인-성공시-jwt를-이용하여-token-전송&quot;&gt;로그인 성공시 JWT를 이용하여 Token 전송&lt;/h1&gt;

&lt;h2 id=&quot;jwt&quot;&gt;&lt;a href=&quot;https://jwt.io&quot;&gt;JWT&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;jwt-설명-내용&quot;&gt;JWT 설명 내용&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSON Web Token(JWT)는 JSON 객체로 당사자간에 안전하게 정보를 전송할수 있는 작고 독립적인 방법을 정의하는 공개 표준(&lt;a href=&quot;https://tools.ietf.org/html/rfc7519&quot;&gt;RFC 7519&lt;/a&gt;)입니다. 이 정보는 디지털 서명되기 때문에 검증되고 신뢰할 수 있습니다. JWT는 RSA/ECDSA를 이용한 공개키/개인키 또는 암호화(HMAC 알고리즘)를 이용하여 서명할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;jwt-사용-예시&quot;&gt;JWT 사용 예시&lt;/h3&gt;

&lt;h4 id=&quot;로그인-후속-처리&quot;&gt;로그인 후속 처리&lt;/h4&gt;

&lt;p&gt;가장 많이 사용되는 방법으로 사용자가 로그인 하면 후속 요청에 JWT가 포함되어 사용자가 해당 토큰으로 허용되는 경로, 서비스 및 리소스 액세스 할 수 있게 한다. 또한 JWT를 이용한 SSO(Single Sign On)은 오버헤드가 적고 다른 도메인에서 쉽게 사용할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;정보-교환&quot;&gt;정보 교환&lt;/h4&gt;

&lt;p&gt;JSON 웹 토큰은 당사자간에 정보를 안전하게 전송하는 좋은 방법이다. JWT는 서명을 할 수 있기 때문에 발신자에 대한 확인과 내용의 변조 여부를 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;json-구조&quot;&gt;JSON 구조&lt;/h3&gt;

&lt;p&gt;JSON은 dots(.)을 기준으로 3가지로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Header&lt;/li&gt;
  &lt;li&gt;Payload&lt;/li&gt;
  &lt;li&gt;Signature&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 형태로 되어 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aaaaaa.zzzzzz.yyyyyy
______.______.______
Header.Payload.Signature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Header는 타입과 알고리즘 두가지 정보를 가지고 있다.&lt;/p&gt;

&lt;p&gt;Payload는 클레임(claim)이라고 명칭되는 name/value 한쌍으로 이루어 져 있다.&lt;/p&gt;

&lt;p&gt;클레임은 세 분류로 나눈다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;등록된(registred) 클레임 : iss(발급자), exp(만료시간), sub(주제), aud(잠재고객) 등이다.&lt;/li&gt;
  &lt;li&gt;공개(public) 클레임 : 자유롭게 정의할수 있다. 충돌을 방지하기 위해 URI 형식을 권장한다.&lt;/li&gt;
  &lt;li&gt;비공개(private) 클레임: 보통 클라이언트와 서버간 협의하에 사용되는 클레임 이름이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;JWT의 등록된 클레임 이름의 길이는 3자이다. 또한 서명된 토큰의 경우 변조되지 않도록 보호는 되지만 모든 사람이 읽을 수 있다. 암호화되지 않은 JWT의 페이로드 또는 헤더 요소에 비밀 정보를 넣으면 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Signature는 Header와 Payload의 인코딩 값을 합친후 주어진 비밀키로 해쉬를 생성 한다.&lt;/p&gt;

&lt;h2 id=&quot;jwt-구현-하기&quot;&gt;JWT 구현 하기&lt;/h2&gt;

&lt;p&gt;기존 프로젝트 코드에서 jsonwebtoken을 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; npm install --save jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 router/index.js파일에서 해당 모듈을 이용해서 로그인 성공시 Token을 전달하고, isAdmin 토큰을 검증하고 ROLE_TEST1을 가지고 있을 경우만 통과 하도록 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...모듈 추가...
const jwt = require('jsonwebtoken');

...로그인 성공시...
const token = jwt.sign(userInfo, secretKey, { expiresIn: '5m' });
res.json({ status: 'success', token });

...isAdmin...
const isAdmin = (req, res, next) =&amp;gt; {
  try {
    const decoded = jwt.verify(req.header('X-token'), secretKey);
    if (decoded.role.includes(roleAdmin)) {
      next();
    }
    else {
      res.json({ status: 403, message: 'Login failed' });
    }
  }
  catch (error) {
    res.json({ status: 500, message: `token Error: ${error.message}` });
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음시간에는 사용자 암호에 대한 해쉬알고리즘을 이용한 암호화 처리를 진행하자.&lt;/p&gt;

&lt;h3 id=&quot;금방끝나네&quot;&gt;금방끝나네!&lt;/h3&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io&quot;&gt;JWT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="auth" /><summary type="html">JWT를 이용하여 로그인 성공시 Token 전송</summary></entry><entry><title type="html">인증서버 구축기 - 2</title><link href="https://lahuman.github.io/auth_server_2/" rel="alternate" type="text/html" title="인증서버 구축기 - 2 " /><published>2019-03-02T00:00:00+09:00</published><updated>2019-03-02T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_2</id><content type="html" xml:base="https://lahuman.github.io/auth_server_2/">&lt;h1 id=&quot;간단하게-dbms-구현과-로그인-처리&quot;&gt;간단하게 DBMS 구현과 로그인 처리&lt;/h1&gt;

&lt;p&gt;인증서버 구현에 대한 설계만 하고 손도 안되고 생각만 하고 있었다.&lt;/p&gt;

&lt;p&gt;DBMS는 다음 그림과 같은 형태로 구현했다.&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;/assets/img/post_img/auth_erd.png&quot;&gt;&lt;img src=&quot;/assets/img/post_img/auth_erd.png&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;AUTH server ERD&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이번 시간에는 Login API를 구현하고 테스트까지 진행한다.&lt;/p&gt;

&lt;h2 id=&quot;모델-구현&quot;&gt;모델 구현&lt;/h2&gt;

&lt;p&gt;모델을 구현하기 위하여 &lt;a href=&quot;https://github.com/sequelize/express-example&quot;&gt;Sequelize Express Example&lt;/a&gt;를 참조 하였다.&lt;/p&gt;

&lt;p&gt;DBMS를 참고 하여 각 모델을 다음과 같이 작성 하였다.&lt;/p&gt;

&lt;h3 id=&quot;users&quot;&gt;Users&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var User = sequelize.define('Users', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    user_id: { type: DataTypes.STRING(50), allowNull: false, unique: true },
    password: { type: DataTypes.STRING(100), allowNull: false },
    description: { type: DataTypes.STRING(1000), allowNull: true }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: true
  });


  User.associate = (models) =&amp;gt; {
    models.Users.belongsToMany(models.Roles, { through: 'UserRoles', foreignKey: 'u_id' });
  };

  return User;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;roles&quot;&gt;Roles&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var Roles = sequelize.define('Roles', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    role_name: { type: DataTypes.STRING(20), allowNull: false, unique: true },
    description: { type: DataTypes.STRING(1000), allowNull: true }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: true
  });

  Roles.associate = (models) =&amp;gt; {
    models.Roles.belongsToMany(models.Users, { through: 'UserRoles', foreignKey: 'r_id' });
  };

  return Roles;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;userroles&quot;&gt;UserRoles&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var UserRole = sequelize.define('UserRoles', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    r_id: {
      type: DataTypes.INTEGER
    },
    u_id: {
      type: DataTypes.INTEGER
    }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true
  });
  return UserRole;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가적으로 LoginHistory를 구현하였고 최근 10분간 로그인이 5회 실패시 잠시 후 시도하도록 했다.&lt;/p&gt;

&lt;h3 id=&quot;loginhistorys&quot;&gt;LoginHistorys&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
module.exports = (sequelize, DataTypes) =&amp;gt; {
    var LoginHistory = sequelize.define('LoginHistorys', {
      id: {
        type: DataTypes.INTEGER,
        autoIncrement: true,
        primaryKey: true
      },
      user_id: { type: DataTypes.STRING(50), allowNull: false },
      login_success: { type: DataTypes.STRING(1), allowNull: false, defaultValue:'Y' }
    }, {
      freezeTableName: true,
      underscored: true,
      timestamps: true,
      paranoid: true
    });
  
    return LoginHistory;
  };
  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;로그인-구현&quot;&gt;로그인 구현&lt;/h2&gt;

&lt;p&gt;로그인은 간단하게 routers/index.js 에 구현하였다. 추가로 다른 기능이 생긴다면 디렉토리를 추가하여 처리 할 예정이다.&lt;/p&gt;

&lt;h3 id=&quot;login-process&quot;&gt;Login Process&lt;/h3&gt;

&lt;p&gt;10분동안 5회 이상의 로그인 실패가 있을 경우 잠시후 시도하라는 메시지가 표출되며, 로그인 실패/성공은 LoginHistory에 저장된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.post('/login', (req, res, next) =&amp;gt; {
  const loginInfo = req.body;
  if (!Object.prototype.hasOwnProperty.call(loginInfo, 'user_id')
    || !Object.prototype.hasOwnProperty.call(loginInfo, 'password')) {
    res.json({ status: 'error', message: 'Invalid Prameter' });
  }
  else {
    models.LoginHistorys.count({ where: { user_id: loginInfo.user_id, login_success: 'N', created_at: { [models.Sequelize.Op.gt]: moment().subtract(20, 'minutes').toDate() } } }).then((c) =&amp;gt; {
      if (c &amp;gt; 5) {
        res.json({ status: 'error', message: 'Login failed several times. Please try again in 10 minutes.' });
      }
      else {
        models.Users.findOne({
          where: { user_id: loginInfo.user_id, password: loginInfo.password },
          include: [models.Roles]
        }).then((u) =&amp;gt; {
          if (u) {
            const userInfo = {
              user_id: u.user_id,
              password: u.password,
              desc: u.description,
              role: u.Roles.map(r =&amp;gt; r.role_name)
            };
            res.json({ status: 'success', userInfo });
            loginInfo.login_success = 'Y';
          }
          else {
            res.json({ status: 'error', message: 'check ID or PW' });
            loginInfo.login_success = 'N';
          }
          models.LoginHistorys.create(loginInfo);
        });
      }
    });
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;todo-진행-예정&quot;&gt;TODO 진행 예정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io/&quot;&gt;JWT&lt;/a&gt;를 이용하여 로그인 성공시 전송되는 내용을 토큰 처리&lt;/li&gt;
  &lt;li&gt;토큰 validate API 제공&lt;/li&gt;
  &lt;li&gt;사용자 PASSWORD hash 암호화 처리(&lt;a href=&quot;https://epthffh.tistory.com/entry/SHA256-%EC%9D%B8%EC%BD%94%EB%94%A9-%EC%86%8C%EC%8A%A4&quot;&gt;SHA-256&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;나머지도-하나씩-처리-하자&quot;&gt;나머지도 하나씩 처리 하자!&lt;/h3&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;</content><category term="node" /><category term="auth" /><summary type="html">로그인 처리와 HISTORY 기록</summary></entry></feed>

<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2020-01-27T12:09:51+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">windows에 wsl 설치하고 설정하기</title><link href="https://lahuman.github.io/windows-wsl-setting/" rel="alternate" type="text/html" title="windows에 wsl 설치하고 설정하기" /><published>2020-01-26T00:00:00+09:00</published><updated>2020-01-26T00:00:00+09:00</updated><id>https://lahuman.github.io/windows-wsl-setting</id><content type="html" xml:base="https://lahuman.github.io/windows-wsl-setting/">&lt;h1 id=&quot;windows에-wsl-설치하고-설정하기&quot;&gt;windows에 wsl 설치하고 설정하기&lt;/h1&gt;

&lt;p&gt;일반적으로 windows OS에서 linux 환경을 사용하기 위해서는 vmware를 이용해 OS를 설치하고 활용했다.
장단점이 있지만, 기본적으로 OS 설치 비용 + 디스크, 메모리 등을 쉐어 하기 때문에 호스트 OS에도 부담이 되는 방식이다.&lt;/p&gt;

&lt;p&gt;2년전쯤 WSL을 설치하려고 시도하다가 업데이트가 잘 안되서 실패 했었다.&lt;/p&gt;

&lt;p&gt;요즘은 쉽게 설치가 된다고 하여 다시 재도전을 해보았다.&lt;/p&gt;

&lt;h2 id=&quot;제어판에서-linux용-windows-하위-시스템-사용-설정&quot;&gt;제어판에서 &lt;strong&gt;Linux용 Windows 하위 시스템&lt;/strong&gt; 사용 설정&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;제어판을 연다.&lt;/li&gt;
  &lt;li&gt;프로그램을 선택한다.&lt;/li&gt;
  &lt;li&gt;Windows 기능 켜기/끄기 선택&lt;/li&gt;
  &lt;li&gt;Linux용 Windows 하위 시스템 켜기&lt;/li&gt;
  &lt;li&gt;재부팅 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_setting.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ubuntu-1804-설치&quot;&gt;Ubuntu 18.04 설치&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Microsoft Store에서 Linux를 검색한다.&lt;/li&gt;
  &lt;li&gt;Ubuntu 18.04 LTS를 선택한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;처음에 Ubuntu를 설치했더니, &lt;strong&gt;yum update&lt;/strong&gt; 부터 오류가 발생했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_msstore_ubuntu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치가 끝나면 실행을 한다.&lt;/p&gt;

&lt;p&gt;실행을 하면 사용자 ID와 Password를 입력하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_ubuntu18.04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nvm-설치-하기&quot;&gt;nvm 설치 하기&lt;/h2&gt;

&lt;p&gt;현재(2020.01.26)기준 최신 버젼은 0.35.2이다. 다음 명령어를 이용해서 설치 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 13527  100 13527    0     0  13888      0 --:--:-- --:--:-- --:--:-- 13873
=&amp;gt; Downloading nvm from git to '/home/lahuman/.nvm'
=&amp;gt; Cloning into '/home/lahuman/.nvm'...
remote: Enumerating objects: 288, done.
remote: Counting objects: 100% (288/288), done.
remote: Compressing objects: 100% (258/258), done.
remote: Total 288 (delta 35), reused 95 (delta 18), pack-reused 0
Receiving objects: 100% (288/288), 146.70 KiB | 408.00 KiB/s, done.
Resolving deltas: 100% (35/35), done.
=&amp;gt; Compressing and cleaning up git repository

=&amp;gt; Appending nvm source string to /home/lahuman/.bashrc
=&amp;gt; Appending bash_completion source string to /home/lahuman/.bashrc
: not foundram Files/nodejs/npm: 3: /mnt/c/Program Files/nodejs/npm:
: not foundram Files/nodejs/npm: 5: /mnt/c/Program Files/nodejs/npm:
/mnt/c/Program Files/nodejs/npm: 6: /mnt/c/Program Files/nodejs/npm: Syntax error: word unexpected (expecting &quot;in&quot;)
=&amp;gt; Close and reopen your terminal to start using nvm or run the following to use it now:

export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm
[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 끝나면 마지막 3줄을 복사해서 붙이면 설치는 마무리 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export NVM_DIR=&quot;$HOME/.nvm&quot;
$ [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/nvm.sh&quot; 
$ [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/bash_completion&quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;nvm list&lt;/strong&gt;명령어를 이용해서 현재 설치된 것을 확인하면, 다음과 같이 아무것도 설치 되어 있지 않다는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nvm list
            N/A
iojs -&amp;gt; N/A (default)
node -&amp;gt; stable (-&amp;gt; N/A) (default)
unstable -&amp;gt; N/A (default)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;nvm install node&lt;/strong&gt; 명령어를 이용해서 node를 설치 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nvm install node
Downloading and installing node v13.7.0...
Downloading https://nodejs.org/dist/v13.7.0/node-v13.7.0-linux-x64.tar.xz...
################################################################################################################# 100.0%
Computing checksum with sha256sum
Checksums matched!
Now using node v13.7.0 (npm v6.13.6)
Creating default alias: default -&amp;gt; node (-&amp;gt; v13.7.0)
$ node -v
v13.7.0
$ npm -v
6.13.6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치 버젼을 확인하여, 설치가 잘된 것을 확인한다.&lt;/p&gt;

&lt;h2 id=&quot;docker-설치-하기&quot;&gt;docker 설치 하기&lt;/h2&gt;

&lt;p&gt;기본적으로 WSL은 docker 데몬을 지원 하지 않는다.&lt;/p&gt;

&lt;p&gt;하지만! WSL2 라면 지원을 한다.&lt;/p&gt;

&lt;h3 id=&quot;wsl2설치&quot;&gt;WSL2설치&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;WSL2란, 최신의 가상화 기술을 사용하여 경량 유틸리티 VM(가상 머신) 내에서 Linux 커널을 실행합니다. 기존 VM과 다르게, WSL1과 동일한 사용자 환경을 유지 하면서 백그라운드에서 관리되고 실행됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선 Hyper-v를 사용하도록 설정 해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BIOS 설정
&lt;img src=&quot;https://i2.wp.com/www.nextofwindows.com/wp-content/uploads/2015/05/6116.HVW8a.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Hyper-V 설정
&lt;img src=&quot;/assets/img/post_img/w_w_hyper-v.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;wsl2 설치&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;WSL 2는 Windows 10 빌드 18917 이상에서만 사용할 수 있음 
Windows 참가자 프로그램을 참가하여야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_update.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 업데이트(인터넷 속도에 따라 2시간 정도 걸림)를 모두 하면, 빌드 버젼이 2020.01.27기준 10.0.19041.21이다.
버전을 확인하는 방법은 cmd 명령창에서 &lt;strong&gt;ver&lt;/strong&gt; 명령어로 확인이 가능합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ver

Microsoft Windows [Version 10.0.19041.21]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 가상 컴퓨터 플랫폼을 사용하도록 powserShell에서 다음 명령어를 입력한다. 주의 할것은 powserShell을 관리자 권한으로 실행해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
# dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 powserShell에서 wsl의 배포판 모드를 변경한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# wsl --set-version &amp;lt;Distro&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_wsl2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이제 docker를 사용할 준비가 완료 되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;docker-설치&quot;&gt;docker 설치&lt;/h2&gt;

&lt;p&gt;docker container를 설치해보자, 설치는 다음의 명령어를 이용해서 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo apt-key fingerprint 0EBFCD88
$ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;
$ sudo apt-get update
$ sudo apt-get install docker-ce
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 완료 되었으면, docker service를 root 권한으로 실행하여야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo service docker start
 * Starting Docker: docker                                                                                       [ OK ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본적으로 docker는 root 권한으로만 실행할 수 있다. docker 명령어를 이용할 때마다, sudo를 붙이는게 귀찮다면, 다음과 같이 사용자를 docker그룹에 추가하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo usermod -aG docker $(whoami)
# 터미널 종료후 다시 열어야 한다.
$ exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;샘플 docker 실행 테스트&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d --name react-app -p 80:80 lahuman/test-react-app
Unable to find image 'lahuman/test-react-app:latest' locally
latest: Pulling from lahuman/test-react-app
e7c96db7181b: Pull complete
8985e402e050: Pull complete
41c1b09855ea: Pull complete
Digest: sha256:bb4d447b8a51845510671f731d68a4b944e681fe856bef670102bb97f904895d
Status: Downloaded newer image for lahuman/test-react-app:latest
5e0cd323d4c97682e4ecb3103555ff9c9ff9d10ffd2bc30fe9591a8b8157fad1

$ docker ps
CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES
5e0cd323d4c9        lahuman/test-react-app   &quot;nginx -g 'daemon of…&quot;   5 seconds ago       Up 3 seconds        0.0.0.0:80-&amp;gt;80/tcp   react-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;ubuntu-삭제-하기&quot;&gt;ubuntu 삭제 하기&lt;/h2&gt;

&lt;p&gt;설치된 wsl의 OS를 삭제하기 위해서는 &lt;strong&gt;앱 및 기능&lt;/strong&gt;으로 이동해서 ms store에서 설치했던, Ubuntu를 찾아서 제거 하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_ubuntu_remove.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.windowscentral.com/install-windows-subsystem-linux-windows-10&quot;&gt;How to install Windows Subsystem for Linux (WSL) on Windows 10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/wsl/wsl2-install?fbclid=IwAR29NZ7vEdgWpYbvtXn0PhTCrD2udghu9H3r-9mtc64tDRAna7QOELDvMPk&quot;&gt;WSL 2의 설치 지침&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subhankarsarkar.com/wsl2-for-containerised-dot-net-core-development-using-docker/?fbclid=IwAR3QFlL-sgSbWDk4wYGgsaTJ5-st4VgxvNMuuaRYrGQ4EMneAznuMyjPBsk&quot;&gt;Build Containerised .NET Core Application using Docker on Windows Subsystem for Linux (WSL) 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/nodejs/setup-on-wsl2?fbclid=IwAR0E6rXQNJRPIt5Ki4tD49bkNvTBCRn-Wk7BpkTd-jYdY-aoT240lfr5SbY&quot;&gt;WSL 2를 사용 하 여 node.js 개발 환경 설정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/virtualization/hyper-v-on-windows/quick-start/quick-create-virtual-machine?fbclid=IwAR0W7qMdgawtOTZzJ-qruiceGyfrB7aKN-hJj8cd00OQkozebeXL6dg5mSs&quot;&gt;Hyper-V를 사용하여 가상 컴퓨터 만들기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="windows" /><category term="wsl" /><category term="vscode" /><summary type="html">vscode의 remote WSL까지 연결하면 신세계가 열린다.</summary></entry><entry><title type="html">kubernetes Persistent Volumes 설정하여 사용하기</title><link href="https://lahuman.github.io/kubernetes-persistent-volumes/" rel="alternate" type="text/html" title="kubernetes Persistent Volumes 설정하여 사용하기" /><published>2020-01-23T00:00:00+09:00</published><updated>2020-01-23T00:00:00+09:00</updated><id>https://lahuman.github.io/kubernetes-persistent-volumes</id><content type="html" xml:base="https://lahuman.github.io/kubernetes-persistent-volumes/">&lt;h1 id=&quot;kubernetes-persistent-volumes-사용하기&quot;&gt;Kubernetes Persistent Volumes 사용하기&lt;/h1&gt;

&lt;h2 id=&quot;준비-작업&quot;&gt;준비 작업&lt;/h2&gt;

&lt;p&gt;가장 쉽게 돈 안들이고 구성하기 위해서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%8C%8C%EC%9D%BC_%EC%8B%9C%EC%8A%A4%ED%85%9C&quot;&gt;Network file system(NFS)&lt;/a&gt;을 설치하여 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;centos에-nfs-설치--구성&quot;&gt;CentOS에 NFS 설치 &amp;amp; 구성&lt;/h3&gt;

&lt;p&gt;우선 설치는 다음과 같이 쉽게 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install nfs-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 끝났면, nfs 데몬을 시작하고 재부팅시 자동으로 실행 될수 있도록 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# nfs 서버 기동
$ systemctl start nfs-server
# 서버 재기동시 nfs 서버 기동
$ systemctl enable nfs-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 exports 할 디렉토리를 생성하고 exports에 해당 위치를 설정 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir /nfs
$ vi /etc/exports
/nfs *(rw,root-squash,sync)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;수정이 다 되었다면, 다음 명령으로 변경된 내역을 반영합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ exportfs -r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 해당 서비스를 다른 서버에서 사용하기 위해 방화벽을 허용해야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ firewall-cmd --permanent --add-service=nfs
$ firewall-cmd --reload
$ firewall-cmd --list-all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 NFS 공유가 잘되었는지 확인합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ showmount -e
Export list for server:
/nfs *

$ sudo exportfs -v
/nfs          	&amp;lt;world&amp;gt;(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,all_squash)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;추가-정보-etcexports-설정-정보&quot;&gt;추가 정보 /etc/exports 설정 정보&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;옵션&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ro&lt;/td&gt;
      &lt;td&gt;파일 시스템을 읽기전용으로 마운트&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rw&lt;/td&gt;
      &lt;td&gt;파일시스템을 읽기/쓰기 로 마운트&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;root_squash&lt;/td&gt;
      &lt;td&gt;클라이언트에서 루트를 서버상에 nobody 사용자로 매핑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;no_root_squash&lt;/td&gt;
      &lt;td&gt;서버와 클라이언트 모두 같은 root를 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;secure&lt;/td&gt;
      &lt;td&gt;클라이언트 마운트 요청시 포트를 1024 이하로 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anonuid&lt;/td&gt;
      &lt;td&gt;익명 사용자를 위한 사용자 ID를 지정하실 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anongid&lt;/td&gt;
      &lt;td&gt;익명 사용자를 위한 그룹 ID를 지정하실 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;insecure&lt;/td&gt;
      &lt;td&gt;인증되지 않은 액세스도 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;noaccess&lt;/td&gt;
      &lt;td&gt;액세스 거부&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;link_relative&lt;/td&gt;
      &lt;td&gt;서버에 있는 루트와의 링크를 포함하는 디렉토리에서 얻는 “../” 만큼 링크 앞에 두어 절대 심볼릭 링크를 상대 심볼릭 링크로 바꿀때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sync&lt;/td&gt;
      &lt;td&gt;파일 시스템이 변경되면 즉시 동기화합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;async&lt;/td&gt;
      &lt;td&gt;sync 옵션을 사용하지 않는 경우에 해당 하며, 서버는 데이터가 저장소에 안전히 저장됐는지를 확인하지 않음 클라이언트의 데이터 쓰기 요청이 들어오면 바로 응답을 보냄 데이터 curruption이 발생할 수 있지만 성능 향상을 기대할 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;no_subtree_check&lt;/td&gt;
      &lt;td&gt;파일 시스템의 전체 디렉토리가 아닌 하부 디렉토리가 내보내진 경우, 서버는 내보낸 하부 디렉토리에 요청된 파일이 존재하는지를 검사 함 이러한 검사 과정을 하부구조 검사라고 부르는데, 이 옵션을 선택하시면 하부구조 검사를 사용하지 않음 전체 파일 시스템이 내보내진 경우에 이 옵션을 선택하면 하부구조 검사를 하지 않음으로서 전송률을 높일 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;all_squash&lt;/td&gt;
      &lt;td&gt;root를 제외하고 서버와 클라이언트의 사용자를 동일한 권한으로 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;no_all_squash&lt;/td&gt;
      &lt;td&gt;root를 제외하고 서버와 클라이언트의 사용자들을 하나의 권한을 가지도록 설정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;nfs-exporting-설정-예&quot;&gt;NFS Exporting 설정 예&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
/home/redhat  디렉토리를 one.linux.co.kr과 two.linux.co.kr 
두 개의 클라이언트 컴퓨터들이 마운트할 수 있으며, 
one 클라이언트 컴퓨터는 오직 읽기로만 마운트되고, 
two 클라이언트 컴퓨터에는 읽기/쓰기로 마운트 된다.
*/

/home/redhat   one.linux.co.kr  (ro)  two.linux.co.kr  (rw)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# linux.co.kr 도메인 내에 있는 모든 컴퓨터들이 /usr/local/bin 파일 시스템을 읽기 전용으로 마운트된다.
/usr/local/bin    *.linux.co.kr    (ro)
# /pub 디렉토리에 대해서 읽기로만 마운트할 수 있고, 사용자 인증이 없이 액세스가 가능하며, 이 데렉토리 파일 시스템에 액세스 하는 모든 컴퓨터의 루트를 서버에서 nobody 사용자로 액세스할 수 있게 한다는 의미이다.
/pub                                        (ro, insecure,root_square)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;클라이언트-설치-테스트&quot;&gt;클라이언트 설치 테스트&lt;/h3&gt;

&lt;p&gt;우선 nfs 패키지를 설치 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install nfs-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;export 위치를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 192.168.0.1 서버 IP
$ showmount -e 192.168.0.1
Export list for server:
/nfs *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NFS 디렉토리와 마운트 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;마운트할 디렉토리 생성
$ mkdir /test/nfs
# 마운트
$ mount -t nfs -o sync 192.168.0.1:/nfs /test/nfs
# 확인
$ df -h | grep nfs
192.168.0.1:/nfs  228G  9.8G  218G   5% /test/nfs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 리부팅시 자동으로 마운트 하기를 원한다면 다음과 같이 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim /etc/fstab
192.168.0.1:/nfs     /test/nfs       nfs     sync    0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mount를 끊기를 원한다면 다음과 같이 하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ umount -f -l /test/nfs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;오류-발생-linux-clnt_create-rpc-program-not-registered-를-확인하면&quot;&gt;오류 발생 &lt;a href=&quot;https://unix.stackexchange.com/questions/82290/linux-clnt-create-rpc-program-not-registered&quot;&gt;Linux: clnt_create: RPC: Program not registered&lt;/a&gt; 를 확인하면,&lt;/h3&gt;

&lt;p&gt;nfs service가 제대로 기동 되지 않은 것이다. 다시 시작하자!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ service nfs status
rpc.svcgssd is stopped
rpc.mountd is stopped
nfsd is stopped
rpc.rquotad is stopped

$ service nfs start
Starting NFS services:                                     [  OK  ]
Starting NFS quotas:                                       [  OK  ]
Starting NFS daemon:                                       [  OK  ]
Starting NFS mountd:                                       [  OK  ]

$ chkconfig nfs on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;persistent-volumes-추가&quot;&gt;Persistent Volumes 추가&lt;/h2&gt;

&lt;p&gt;kuberctl로 추가 하는 방법도 있고, 지금 사용하는 Rancher UI에서 처리 하는 방법도 있다.&lt;/p&gt;

&lt;p&gt;간단하게 Rancher UI에서 설정하는 방식은 우선 아래 메뉴로 이동 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kpv_menu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 &lt;strong&gt;Add Volumes&lt;/strong&gt; 버튼을 클릭해서 Volume을 설정을 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/add_volume.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설정을 저장하면 다음과 같이 추가된 내역을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kpv_menu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;claim-설정&quot;&gt;Claim 설정&lt;/h2&gt;

&lt;p&gt;Available 된 Persistent Volumes을 pod와 연동을 위해서 Claim과 연결 해야 한다.&lt;/p&gt;

&lt;p&gt;다음 메뉴로 이동 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/ku_claim_menu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Add Volumn&lt;/strong&gt; 버튼을 클릭하고, 아래와 같이 설정 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/add_claim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저장을 하고 나면, Bound 된 상태 확인이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/claim_bound.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용해보기&quot;&gt;사용해보기&lt;/h2&gt;

&lt;p&gt;이제 설정이 다 되었으면 다음과 같이 사용 하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: elasticsearch
  namespace: devops-tool
  labels:
    app: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: elasticsearch:latest
        ports:
        - containerPort: 9200
        imagePullPolicy: Always
        volumeMounts:
        - mountPath: /usr/share/elasticsearch/data
          name: elasticsearchdata
      volumes:
      - name: elasticsearchdata
        persistentVolumeClaim:
          claimName: mongodb-claim
---
apiVersion: v1
kind: Service
metadata:
  namespace: devops-tool
  name: elasticsearch
spec:
  ports:
    - port: 9200
      targetPort: 9200
      protocol: TCP
      name: http
      nodePort: 30560
  selector:
    app: elasticsearch
  type: LoadBalancer
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;중간에 내용을 보면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        volumeMounts:
        - mountPath: /usr/share/elasticsearch/data
          name: elasticsearchdata
      volumes:
      - name: elasticsearchdata
        persistentVolumeClaim:
          claimName: mongodb-claim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기를 잘 보면 된다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://waspro.tistory.com/580&quot;&gt;Kubernetes Persistent Volume 생성하기 - PV, PVC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yangnoon.tistory.com/38&quot;&gt;[LINUX][RHEL7] 리눅스 NFS서버 NFS클라이언트 설정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://unix.stackexchange.com/questions/82290/linux-clnt-create-rpc-program-not-registered&quot;&gt;Linux: clnt_create: RPC: Program not registered&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://server-talk.tistory.com/117&quot;&gt;NFS 설정하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="kubernetes" /><category term="persistent" /><category term="volumes" /><category term="nfs" /><summary type="html">pod의 저장소를 쓰면 pod가 삭제될때 함께 삭제되어 피똥 쌀 수 있다.</summary></entry><entry><title type="html">kubernetes Logging 처리를 해보자!</title><link href="https://lahuman.github.io/kubernetes-logging/" rel="alternate" type="text/html" title="kubernetes Logging 처리를 해보자!" /><published>2020-01-17T00:00:00+09:00</published><updated>2020-01-17T00:00:00+09:00</updated><id>https://lahuman.github.io/kubernetes-logging</id><content type="html" xml:base="https://lahuman.github.io/kubernetes-logging/">&lt;h1 id=&quot;fluentd를-활용해-kubernetes-로그를-elasticsearch에-저장하고-kibana로-표출-해보자&quot;&gt;fluentd를 활용해 kubernetes 로그를 elasticsearch에 저장하고 kibana로 표출 해보자!&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;kubernetes를 셋팅을 하고 다음으로 해야 할일은 모니터링이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그 작업의 기초가 되는일이 바로 로깅을 쌓는 일이다.&lt;/p&gt;

&lt;p&gt;모든 컨테이너의 로그들을 모아서 한 곳에서 확인할 수 있도록 구성했다.&lt;/p&gt;

&lt;p&gt;각 컨테이너에서 로그를 가져오는 것은 &lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt;를 이용했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt;에서 &lt;a href=&quot;https://www.elastic.co/kr/what-is/elasticsearch&quot;&gt;elasticsearch&lt;/a&gt;로 데이터를 적재 하도록 설정하였고, &lt;a href=&quot;https://www.elastic.co/kr/products/kibana&quot;&gt;kibana&lt;/a&gt;를 통해서 해당 데이터를 표출했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubernetes &amp;lt;-로그수집- fluentd -데이터 적재-&amp;gt; elasticsearch &amp;lt;-표출- kibana
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;구축-순서&quot;&gt;구축 순서&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.elastic.co/kr/what-is/elasticsearch&quot;&gt;elasticsearch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.elastic.co/kr/products/kibana&quot;&gt;kibana&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;elasticsearch-구성&quot;&gt;&lt;a href=&quot;https://www.elastic.co/kr/what-is/elasticsearch&quot;&gt;elasticsearch&lt;/a&gt; 구성&lt;/h3&gt;

&lt;p&gt;kubernetes의 오브젝트를 생성하기 위한 yaml 파일을 다음과 같이 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# elastic.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: elasticsearch
  labels:
    app: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: elastic/elasticsearch:6.8.6
        env:
        - name: discovery.type
          value: &quot;single-node&quot;
        ports:
        - containerPort: 9200
        - containerPort: 9300
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: elasticsearch
  name: elasticsearch-svc
  namespace: default
spec:
  ports:
  - name: elasticsearch-rest
    nodePort: 30482
    port: 9200
    protocol: TCP
    targetPort: 9200
  - name: elasticsearch-nodecom
    nodePort: 30930
    port: 9300
    protocol: TCP
    targetPort: 9300
  selector:
    app: elasticsearch
  type: NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; 명령어를 이용해서 오브젝트를 kubernetes에 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kbuectl apply -f elastic.yml
deployment.apps/elasticsearch created
service/elasticsearch-svc created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정된 노드포트를 통해서 서비스를 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://${kubernetes_host}:30842/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/elastic_service_check.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kibana-구성&quot;&gt;&lt;a href=&quot;https://www.elastic.co/kr/products/kibana&quot;&gt;kibana&lt;/a&gt; 구성&lt;/h3&gt;

&lt;p&gt;kubernetes의 오브젝트를 생성하기 위한 yaml 파일을 다음과 같이 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# kibana.yml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
  labels:
    app: kibana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      containers:
      - name: kibana
        image: elastic/kibana:6.8.6
        env:
        - name: SERVER_NAME
          value: &quot;kibana.kubenetes.example.com&quot;
        - name: ELASTICSEARCH_URL
          value: &quot;http://elasticsearch-svc.default.svc.cluster.local:9200&quot;
        ports:
        - containerPort: 5601
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: kibana
  name: kibana-svc
  namespace: default
spec:
  ports:
  - nodePort: 30920
    port: 5601
    protocol: TCP
    targetPort: 5601
  selector:
    app: kibana
  type: NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;연결하는 elasticsearch 주소는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://elasticsearch-svc.default.svc.cluster.local:9200&lt;/code&gt;이다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; 명령어를 이용해서 오브젝트를 kubernetes에 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kbuectl apply -f kibana.yml
deployment.apps/kibana created
service/kibana-svc created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정된 노드포트를 통해서 서비스를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kibana_service_check.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fluentd-구성&quot;&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt; 구성&lt;/h3&gt;

&lt;p&gt;kubernetes의 오브젝트를 생성하기 위한 yaml 파일을 다음과 같이 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# fluentd.yml

apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    k8s-app: fluentd
  name: fluentd
  namespace: kube-system

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: fluentd
rules:
  - apiGroups:
      - &quot;&quot;
    resources:
      - &quot;namespaces&quot;
      - &quot;pods&quot;
    verbs:
      - &quot;list&quot;
      - &quot;get&quot;
      - &quot;watch&quot;

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: fluentd
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: fluentd
subjects:
- kind: ServiceAccount
  name: fluentd
  namespace: kube-system

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
  namespace: kube-system
  labels:
    k8s-app: fluentd-logging
    version: v1
    kubernetes.io/cluster-service: &quot;true&quot;
spec:
  selector:
    matchLabels:
      k8s-app: fluentd-logging
  template:
    metadata:
      labels:
        k8s-app: fluentd-logging
        version: v1
        kubernetes.io/cluster-service: &quot;true&quot;
    spec:
      serviceAccount: fluentd
      serviceAccountName: fluentd
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: fluentd
        image: fluent/fluentd-kubernetes-daemonset:v1.4.2-debian-elasticsearch-1.1
        env:
          - name:  FLUENT_ELASTICSEARCH_HOST
            value: &quot;elasticsearch-svc.default.svc.cluster.local&quot;
          - name:  FLUENT_ELASTICSEARCH_PORT
            value: &quot;9200&quot;
          - name: FLUENT_ELASTICSEARCH_SCHEME
            value: &quot;http&quot;
          - name: FLUENTD_SYSTEMD_CONF
            value: &quot;disable&quot;
          - name: FLUENT_UID
            value: &quot;0&quot;
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 설정에서 보면 /var/log를 모두 로그를 가져오며 가져온 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://elasticsearch-svc.default.svc.cluster.local:9200&lt;/code&gt;에 적재 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; 명령어를 이용해서 오브젝트를 kubernetes에 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kbuectl apply -f fluentd.yml
serviceaccount/fluentd created
clusterrole.rbac.authorization.k8s.io/fluentd created
clusterrolebinding.rbac.authorization.k8s.io/fluentd created
daemonset.apps/fluentd created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;설치시-오류-발생에-따른-해결책&quot;&gt;설치시 오류 발생에 따른 해결책&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/58252254/unable-to-recognize-filebeat-kubernetes-yaml-no-matches-for-kind-daemonset&quot;&gt;unable to recognize “filebeat-kubernetes.yaml”: no matches for kind “DaemonSet” in version “extensions/v1beta1”&lt;/a&gt; 과 같은 오류가 발생한 이유는 &lt;code class=&quot;highlighter-rouge&quot;&gt;apiVersion&lt;/code&gt;이 extensions/v1beta1을 사용하지 말고 apps/v1을 사용하도록 되어 있다.&lt;/p&gt;

&lt;p&gt;다음과 같은 오류가 발생할 경우,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2018-11-26 23:19:44 +0000 [warn]: suppressed same stacktrace
2018-11-26 23:19:50 +0000 [info]: stats - namespace_cache_size: 3, pod_cache_size: 6, namespace_cache_api_updates: 15, pod_cache_api_updates: 15, id_cache_miss: 15
2018-11-26 23:20:14 +0000 [warn]: temporarily failed to flush the buffer. next_retry=2018-11-26 23:20:44 +0000 error_class=&quot;MultiJson::AdapterError&quot; error=&quot;Did not recognize your adapter specification (cannot load such file -- bigdecimal).&quot; plugin_id=&quot;out_es&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;debian 계열의 이미지를 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;containers:
- name: fluentd
image: fluent/fluentd-kubernetes-daemonset:v1.4.2-debian-elasticsearch-1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset/issues/230&quot;&gt;Did not recognize your adapter specification #230&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료되고 나면, 각 worker node에서 기동하는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;kibana-설정&quot;&gt;kibana 설정&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Management =&amp;gt; kibana =&amp;gt; Index Patterns =&amp;gt; Create Index Pattern =&amp;gt; &quot;logstash-*&quot; 추가
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kibana_setting.png&quot; alt=&quot;설정화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 처리 하면 다음과 같은 결과를 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kibana_result_sample.png&quot; alt=&quot;설정화면&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;한땀 한땀 설치 kubernetes의 오부젝트에 대하여 더 많이 이해하게 되었다.&lt;/p&gt;

&lt;p&gt;데이터 적재의 형태나, node의 error 로그 적재 등은 좀더 확인해봐야겠다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/cluster-administration/logging/&quot;&gt;https://kubernetes.io/docs/concepts/cluster-administration/logging/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arisu1000.tistory.com/27852&quot;&gt;쿠버네티스 로깅(kubernetes logging)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/58252254/unable-to-recognize-filebeat-kubernetes-yaml-no-matches-for-kind-daemonset&quot;&gt;unable to recognize “filebeat-kubernetes.yaml”: no matches for kind “DaemonSet” in version “extensions/v1beta1”&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset/issues/230&quot;&gt;Did not recognize your adapter specification #230&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="kubernetes" /><category term="fluentd" /><category term="elasticsearch" /><category term="kibana" /><summary type="html">fluentd를 활용해 kubernetes 로그를 elasticsearch에 저장하고 kibana로 표출 해보자!</summary></entry><entry><title type="html">kubernetes의 각 항목을 살펴보자.</title><link href="https://lahuman.github.io/kubernetes-yaml/" rel="alternate" type="text/html" title="kubernetes의 각 항목을 살펴보자." /><published>2020-01-14T00:00:00+09:00</published><updated>2020-01-14T00:00:00+09:00</updated><id>https://lahuman.github.io/kubernetes-yaml</id><content type="html" xml:base="https://lahuman.github.io/kubernetes-yaml/">&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/Gdt6XNEK0dydXF&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt;
&lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/lahuman1/kubernetes-object&quot; title=&quot;Kubernetes object에 대하여&quot; target=&quot;_blank&quot;&gt;Kubernetes object에 대하여&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;https://www.slideshare.net/lahuman1&quot; target=&quot;_blank&quot;&gt;Daniel Lim&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;

&lt;h1 id=&quot;오브젝트-기술하기&quot;&gt;오브젝트 기술하기&lt;/h1&gt;

&lt;p&gt;쿠버네티스에서 오브젝트를 생성할 때, 기본적인 정보와 더불어 의도한 상태를 기술한 오브젝트 spec를 제시해줘야 한다.&lt;/p&gt;

&lt;p&gt;많이 사용되는 것은 &lt;strong&gt;.yaml&lt;/strong&gt; 파일로 &lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt;에 정보를 제공해준다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt;은 API 요청이 이루어질 때, JSON 형식으로 정보를 변환시켜준다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;요청-필드와-오브젝트-spac를-보여주는-yaml-파일-예시&quot;&gt;요청 필드와 오브젝트 spac를 보여주는 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yaml&lt;/code&gt; 파일 예시&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# application/deployment.yaml 

apiVersion: apps/v1 # apps/v1beta2를 사용하는 1.9.0보다 더 이전의 버전용
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # 템플릿에 매칭되는 파드 2개를 구동하는 디플로이먼트임
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;yaml-파일을-이용한-반영-예시&quot;&gt;.yaml 파일을 이용한 반영 예시&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.yaml&lt;/code&gt; 파일을 &lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply&quot;&gt;kubectl apply&lt;/a&gt; 명령어를 이용해서 반영 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
deployment.apps/nginx-deployment created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;필드들-설명&quot;&gt;필드들 설명&lt;/h1&gt;

&lt;p&gt;생성하고자 하는 쿠버네티스 오브젝트에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;.yaml&lt;/code&gt; 파일 내, 다음 필드를 위한 값들을 설정해 줘야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;apiVersion - 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지&lt;/li&gt;
  &lt;li&gt;kind - 어떤 종류의 오브젝트를 생성하고자 하는지&lt;/li&gt;
  &lt;li&gt;metadata - 이름 문자열, UID, 그리고 선택적인 네임스페이스 를 포함하여 오브젝트를 유일하게 구분지어 줄 데이터&lt;/li&gt;
  &lt;li&gt;spec - 오브젝트에 대해 어떤 상태를 의도하는지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오브젝트 &lt;code class=&quot;highlighter-rouge&quot;&gt;spec&lt;/code&gt;에 대한 정확한 포맷은 모든 코버네티스 오브젝트마다 다르고 그 오브젝트 특유의 중첩된 필드를 포함한다.&lt;/p&gt;

&lt;h6 id=&quot;kubernetes-api-reference-는-쿠버네티스를-이용하여-생성할-수-있는-오브젝트에-대한-모든-spec-포맷을-살펴볼-수-있도록-해준다&quot;&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/&quot;&gt;Kubernetes API Reference &lt;/a&gt;는 쿠버네티스를 이용하여 생성할 수 있는 오브젝트에 대한 모든 spec 포맷을 살펴볼 수 있도록 해준다.&lt;/h6&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;용어-설명1&quot;&gt;용어 설명(1)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;노드(Node)
  ###### + 클러스터의 일부이며, 쿠버네티스에 속한 워커 머신.&lt;/li&gt;
  &lt;li&gt;클러스터(Cluster)
  ###### + 쿠버네티스에서 관리되는 컨테이너화 된 애플리케이션을 실행하는 노드 집합. 이 예시와 대부분의 일반적인 쿠버네티스 배포에서 클러스터에 속한 노드는 퍼블릭 인터넷의 일부가 아니다.&lt;/li&gt;
  &lt;li&gt;에지 라우터(Edge router)
  ###### + 클러스터에 방화벽 정책을 적용하는 라우터. 이것은 클라우드 공급자 또는 물리적 하드웨어의 일부에서 관리하는 게이트웨이일 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;용어-설명2&quot;&gt;용어 설명(2)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;클러스터 네트워크(Cluster network)
  ###### + 쿠버네티스 네트워킹 모델에 따라 클러스터 내부에서 통신을 용이하게 하는 논리적 또는 물리적 링크 집합.&lt;/li&gt;
  &lt;li&gt;서비스(Service)
  ###### + 레이블 셀렉터를 사용해서 파드 집합을 식별하는 쿠버네티스 서비스(Service). 달리 언급하지 않으면 서비스는 클러스터 네트워크 내에서만 라우팅 가능한 가상 IP를 가지고 있다고 가정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;파드pod에-대하여&quot;&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/workloads/pods/pod-overview/&quot;&gt;파드(Pod)에 대하여&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;파드는 쿠버네티스 애플리케이션의 기본 실행 단위이다. 쿠버네티스 객체 모델 중 만들고 배포할 수 있는 가장 작고 간단한 단위이다. 파드는 &lt;a href=&quot;https://kubernetes.io/ko/docs/reference/glossary/?all=true#term-cluster&quot;&gt;Cluster&lt;/a&gt;에서의 동작하는 프로세스를 나타낸다.&lt;/p&gt;

&lt;p&gt;파다는 애플리케이션 컨테이너, 저장소 리소스, 특정 네트워크 IP 그리고 &lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/#%ec%99%9c-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%9d%b8%ea%b0%80&quot;&gt;container&lt;/a&gt;가 동작하기 위해 만들어진 옵션들을 캡술화한다.파드는 배포의 단위를 말한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;도커&lt;/a&gt;는 쿠버네티스 파드에서 사용되는 가장 대표적인 컨테이너 런타임이지만, 파드는 다른 &lt;a href=&quot;https://kubernetes.io/ko/docs/setup/production-environment/container-runtimes/&quot;&gt;컨테이너 런타임&lt;/a&gt; 역시 지원한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;파드는-두가지-방법으로-사용된다&quot;&gt;파드는 두가지 방법으로 사용된다.&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;단일 컨테이너만 동작하는 파드&lt;/li&gt;
  &lt;li&gt;함께 동작하는 작업이 필요한 다중 컨테이너가 동작하는 파드&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;어떻게-파드가-다중-컨테너를-관리하는가&quot;&gt;어떻게 파드가 다중 컨테너를 관리하는가?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/pod.svg&quot; alt=&quot;fit opacity bg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파드는 &lt;a href=&quot;https://kubernetes.io/ko/docs/reference/glossary/?all=true#term-init-container&quot;&gt;init containers&lt;/a&gt; 뿐만 아니라 &lt;a href=&quot;https://kubernetes.io/ko/docs/reference/glossary/?all=true#term-app-container&quot;&gt;app containers&lt;/a&gt;도 가진다.&lt;/p&gt;

&lt;p&gt;파드는 같은 파드 안에 속한 컨테이너에게 두가지 공유 리소스를 제공한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;네트워킹
    &lt;ul&gt;
      &lt;li&gt;유일한 IP주소를 할당 받음&lt;/li&gt;
      &lt;li&gt;파드 안의 컨테이너끼리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt;를 통해 통신 할수 있음&lt;/li&gt;
      &lt;li&gt;파드 안의 컨테이너와 파드 밖의 요소와 통신을 위해 네트워크 리소스 공유(PORT 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저장소
    &lt;ul&gt;
      &lt;li&gt;공유 저장 집합인 &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/volumes/&quot;&gt;volumes&lt;/a&gt; 명시&lt;/li&gt;
      &lt;li&gt;
        &lt;h2 id=&quot;컨테이너가-재시작-해야-하는-상황에도-파드-안의-데이터가-영구적으로-유지될-수-있게-한다&quot;&gt;컨테이너가 재시작 해야 하는 상황에도 파드 안의 데이터가 영구적으로 유지될 수 있게 한다.&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;파드와-컨트롤러&quot;&gt;파드와 컨트롤러&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;h6 id=&quot;파드는-스스로를-치료-하지-않는다-만약-스케줄링된-노드애-장애가-생기거나-스케쥴링-동작이-스스로-실패할-경우-파드는-삭제-된다-그와-비슷하게-리소스나-노드의-유지-부족으로-인해-제거-되는-상황에서-살아남지-못한다&quot;&gt;파드는 스스로를 치료 하지 않는다. 만약 스케줄링된 노드애 장애가 생기거나, 스케쥴링 동작이 스스로 실패할 경우 파드는 삭제 된다. 그와 비슷하게 리소스나 노드의 유지 부족으로 인해 제거 되는 상황에서 살아남지 못한다.&lt;/h6&gt;
  &lt;h6 id=&quot;쿠버네티스는-상대적으로-일시적인-파드-인스턴스를-관리하는-작업을-처리하는-컨트롤러-라고-하는-고수준의-추상적-개념을-사용한다&quot;&gt;쿠버네티스는 상대적으로 일시적인 파드 인스턴스를 관리하는 작업을 처리하는 &lt;strong&gt;컨트롤러&lt;/strong&gt; 라고 하는 고수준의 추상적 개념을 사용한다.&lt;/h6&gt;
&lt;/blockquote&gt;

&lt;p&gt;컨트롤러는 다중 파드를 생성하고 관리해 주는데, 클러스터 범위 내에서의 레플리케이션 핸들링, 롤아웃 그리고 셀프힐링 기능 제공을 한다. 예를 들어, 만약 노드가 고장났을 때, 컨트롤러는 다른 노드에 파드를 스케줄링 함으로써 자동으로 교체할 것이다.&lt;/p&gt;

&lt;p&gt;한 가지 또는 그 이상의 파드를 보유한 컨트롤러의 몇 가지 예시.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/workloads/controllers/deployment/&quot;&gt;디플로이먼트&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/workloads/controllers/statefulset/&quot;&gt;스테이트풀 셋&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/workloads/controllers/daemonset/&quot;&gt;데몬 셋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;파드-템플릿&quot;&gt;파드 템플릿&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo 안녕하세요 쿠버네티스! &amp;amp;&amp;amp; sleep 3600']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/workloads/pods/pod/&quot;&gt;파드(Pod)에 대하여 더 알아보고 싶다면!&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;서비스servic&quot;&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/&quot;&gt;서비스(Servic)&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;kubernetes에서 서비스는 논리적 포트 세트와 액세스 할 수 있는 정책을 정의하는 추상화를 제공합니다. 서비스가 대상으로 하는 파드의 세트는 설정으로 결정됩니다.&lt;/p&gt;

&lt;h6 id=&quot;예를-들어-tcp-포트-9376을-사용하는-파드-셋의-레이블이-appmyapp-일때-my-service를-다음과-같이-설정-할-수-있습니다&quot;&gt;예를 들어 TCP 포트 9376을 사용하는 파드 셋의 레이블이 app=Myapp 일때, my-service를 다음과 같이 설정 할 수 있습니다.&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;서비스-external-설정&quot;&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/&quot;&gt;서비스 external 설정&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ClusterIP (기본값)&lt;/strong&gt; - 클러스터 내에서 내부 IP 에 대해 서비스를 노출해준다. 이 방식은 오직 클러스터 내에서만 서비스가 접근될 수 있도록 해준다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NodePort&lt;/strong&gt; - NAT가 이용되는 클러스터 내에서 각각 선택된 노드들의 동일한 포트에 서비스를 노출시켜준다. &lt;NodeIP&gt;:&lt;NodePort&gt;를 이용하여 클러스터 외부로부터 서비스가 접근할 수 있도록 해준다. CluserIP의 상위 집합이다.&lt;/NodePort&gt;&lt;/NodeIP&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LoadBalancer&lt;/strong&gt; - (지원 가능한 경우) 기존 클라우드에서 외부용 로드밸런서를 생성하고 서비스에 고정된 공인 IP를 할당해준다. NodePort의 상위 집합이다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ExternalName&lt;/strong&gt; - 이름으로 CNAME 레코드를 반환함으로써 임의의 이름(스펙에서 externalName으로 명시)을 이용하여 서비스를 노출시켜준다. 프록시는 사용되지 않는다. 이 방식은 kube-dns 버전 1.7 이상에서 지원 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;서비스와-레이블&quot;&gt;서비스와 레이블&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/module_04_labels.svg&quot; alt=&quot;fit h:700 bg right&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서비스는 파드 셋에 걸쳐서 트래픽을 라우트한다&lt;/p&gt;

&lt;p&gt;서비스는 쿠버네티스의 객체들에 대해 논리 연산을 허용해주는 기본 그룹핑 단위인, &lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/labels/&quot;&gt;레이블과 셀렉터&lt;/a&gt;를 이용하여 파드 셋과 매치시킨다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;인그레스ingress&quot;&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/services-networking/ingress/&quot;&gt;인그레스(Ingress)&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;클러스터 내의 서비스에 대한 외부 접근을 관리하는 API 오브젝트이며, 일반적으로 HTTP를 관리함.&lt;/p&gt;

&lt;p&gt;인그레스는 부하 분산, SSL 종료, 명칭 기반의 가상 호스팅을 제공할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인그레스는 클러스터 외부에서 클러스터 내부 서비스로 HTTP와 HTTPS 경로를 노출한다. 트래픽 라우팅은 인그레스 리소스에 정의된 규칙에 의해 컨트롤된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;인그레스-리소스&quot;&gt;인그레스 리소스&lt;/h2&gt;

&lt;p&gt;최소한의 인그레스 리소스 예제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: test-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - path: /testpath
        backend:
          serviceName: test
          servicePort: 80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;인그레스-유형들&quot;&gt;인그레스 유형들&lt;/h2&gt;

&lt;h4 id=&quot;--단일-서비스&quot;&gt;- 단일 서비스&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NAME           HOSTS     ADDRESS           PORTS     AGE
test-ingress   *         107.178.254.228   80        59s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;--간단한-팬아웃fanout&quot;&gt;- 간단한 팬아웃(fanout)&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foo.bar.com -&amp;gt; 178.91.123.132 -&amp;gt; / foo    service1:4200
                                 / bar    service2:8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;--이름-기반의-가상-호스팅&quot;&gt;- 이름 기반의 가상 호스팅&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foo.bar.com --|                 |-&amp;gt; foo.bar.com service1:80
              | 178.91.123.132  |
bar.foo.com --|                 |-&amp;gt; bar.foo.com service2:80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;인그레스-컨트롤러&quot;&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/services-networking/ingress-controllers/&quot;&gt;인그레스 컨트롤러&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;인그레스 리소스가 작동하려면, 클러스터는 실행 중인 인그레스 컨트롤러가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;kube-controller-manager 바이너리의 일부로 실행되는 컨트롤러의 다른 타입과 달리 인그레스 컨트롤러는 클러스터와 함께 자동으로 실행되지 않는다. 클러스터에 가장 적합한 인그레스 컨트롤러 구현을 선택하는데 이 페이지를 사용한다.&lt;/p&gt;

&lt;p&gt;프로젝트로써 쿠버네티스는 현재 &lt;a href=&quot;https://github.com/kubernetes/ingress-gce/blob/master/README.md&quot;&gt;GCE&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/kubernetes/ingress-nginx/blob/master/README.md&quot;&gt;nginx&lt;/a&gt; 컨트롤러를 지원하고 유지한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/&quot;&gt;쿠버네티스 오브젝트 이해하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="kubernetes" /><category term="yaml" /><summary type="html">많이 사용되고 꼭 알아야 하는 정보만 기억하자!</summary></entry><entry><title type="html">ReactJS에서 docker 이미지 생성 &amp;amp; 배포 하기</title><link href="https://lahuman.github.io/reactjs-dockerfile/" rel="alternate" type="text/html" title="ReactJS에서 docker 이미지 생성 &amp; 배포 하기" /><published>2020-01-13T00:00:00+09:00</published><updated>2020-01-13T00:00:00+09:00</updated><id>https://lahuman.github.io/reactjs-dockerfile</id><content type="html" xml:base="https://lahuman.github.io/reactjs-dockerfile/">&lt;h1 id=&quot;reactjs-proejct-docker-이미지-생성--배포-하기&quot;&gt;ReactJS Proejct Docker 이미지 생성 &amp;amp; 배포 하기&lt;/h1&gt;

&lt;p&gt;ReactJS 프로젝트를 docker 이미지를 생성하는 방법을 정리 합니다.&lt;/p&gt;

&lt;p&gt;기본적으로 node 12.x 의 이미지에 nginx 이미지를 활용하여서 생성하였습니다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 &lt;a href=&quot;/Dockerfile&quot;&gt;Dockerfile&lt;/a&gt; 파일을 참고 하시면 됩니다.&lt;/p&gt;

&lt;p&gt;ReactJS 파일은 기본 명령어를 이용해서 생성하였습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npx create-react-app mycode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;1-우선-reacjs-프로젝트에서-다음-파일을-생성합니다&quot;&gt;1. 우선 ReacJS 프로젝트에서 다음 파일을 생성합니다.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/Dockerfile&quot;&gt;Dockerfile&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/default.conf&quot;&gt;default.conf&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/expires.conf&quot;&gt;expires.conf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-이미지-생성하기&quot;&gt;2. 이미지 생성하기&lt;/h2&gt;

&lt;p&gt;다음 명령어를 이용해서 이미지를 생성 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# docker build -t ${image-name}:${version} .

$ docker build -t react-dockerfile:1.0 .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-이미지-테스트-하기&quot;&gt;3. 이미지 테스트 하기&lt;/h2&gt;

&lt;p&gt;생성된 이미지를 docker run으로 테스트 합니다.&lt;/p&gt;

&lt;p&gt;아래 명령어는 이미지를 띄우고 &lt;strong&gt;Ctrl + C&lt;/strong&gt;를 이용해서 종료 하면 바로 컨테이너를 삭제 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# docker run -p 8888:80 --rm ${image-name}:${version}

$ docker run -p 8888:80 --rm react-dockerfile:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로컬 PC의 8888 포트와 컨테이너 80 포트를 연결 하여서 띄우기 때문에 http://localhost:8888 을 브라우저에서 입력하시고 결과를 확인해세요.&lt;/p&gt;

&lt;h2 id=&quot;4-이미지를-docker-repository에-올리기&quot;&gt;4. 이미지를 docker repository에 올리기&lt;/h2&gt;

&lt;p&gt;마지막으로 만든 이미지에 문제가 없다면, 해당 이미지를 docker repository에 올립니다.&lt;/p&gt;

&lt;h3 id=&quot;41-docker-login-을-하세요&quot;&gt;4.1 docker login 을 하세요.&lt;/h3&gt;

&lt;p&gt;저장하려는 repository에 로그인 하세요 기본으로 로그인시 docker hub에 저장하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: lahuman
Password:
Login Succeeded
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;42-우선-이미지-태그를-다시-생성하셔요&quot;&gt;4.2 우선 이미지 태그를 다시 생성하셔요.&lt;/h3&gt;

&lt;p&gt;docker 이미지 태그는 docker hub 계정 정보가 함께 들어 갑니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# docker tag ${image-name}:${version} ${account}/${image-name}:${version}

$ docker tag react-dockerfile:1.0 lahuman/react-dockerfile:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;43-push를-하세요&quot;&gt;4.3 push를 하세요&lt;/h3&gt;

&lt;p&gt;마지막으로 이미지를 docker hub에 push 하세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker push ${account}/${image-name}:${version}
$ docker push lahuman/react-dockerfile:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;오류-denied-requested-access-to-the-resource-is-denied&quot;&gt;[오류] denied: requested access to the resource is denied&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;로그인 정보를 확인하세요.&lt;/li&gt;
  &lt;li&gt;tag에 계정 정보가 알맞게 저장 되었는지 확인하세요.&lt;/li&gt;
&lt;/ol&gt;</content><category term="reactjs" /><category term="dockerfile" /><summary type="html">node + nginx로 처리 하면 참 쉽죠?</summary></entry><entry><title type="html">harbor 설치 부터 kubernetes 연동까지!</title><link href="https://lahuman.github.io/kubernetes-harbor/" rel="alternate" type="text/html" title="harbor 설치 부터 kubernetes 연동까지!" /><published>2020-01-11T00:00:00+09:00</published><updated>2020-01-11T00:00:00+09:00</updated><id>https://lahuman.github.io/kubernetes-harbor</id><content type="html" xml:base="https://lahuman.github.io/kubernetes-harbor/">&lt;h1 id=&quot;harbor-설치-부터-kubernetes-연동까지&quot;&gt;harbor 설치 부터 kubernetes 연동까지!&lt;/h1&gt;

&lt;h2 id=&quot;harbor-설치&quot;&gt;&lt;a href=&quot;https://goharbor.io/&quot;&gt;Harbor&lt;/a&gt; 설치&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;설치 전에 필수 설치 사항
    &lt;ul&gt;
      &lt;li&gt;docker-compose&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
$ sudo chmod +x /usr/local/bin/docker-compose
# version 확인
$ docker-compose -v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Harbor를 다운받기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;기본적으로 Online(harbor-online-installer-vx.x.x.tgz)으로 받아서 설치를 시작하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/harbor_download.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2020년 1월 11일 최신 버젼인 &lt;a href=&quot;https://github.com/goharbor/harbor/releases/download/v1.9.4/harbor-online-installer-v1.9.4.tgz&quot;&gt;harbor-online-installer-v1.9.4.tgz&lt;/a&gt;을 기준으로 진행하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wget https://github.com/goharbor/harbor/releases/download/v1.9.4/harbor-online-installer-v1.9.4.tgz
$ tar xvfz harbor-online-installer-v1.9.4.tgz
$ cd harbor
# 특정 설정을 변경해야 한다.
# hostname과 https 설정 필수 수정
# 작동하는 PORT를 변경할 경우 다음 파일에서 수정
$ vi harbor.yml
# 설치는 ROOT 계정으로 진행하는 것을 추천한다.
$ ./install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;동작 확인&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;브라우저를 통해서 확인한다. HTTPS를 활성화 했다면 https로 확인이 가능하다.
로그인 기본 ID 는 admin이며 password는 harbor.yml에 표기되어 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 파일 내 기본 비밀번호 
harbor_admin_password: Harbor12345
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;harbor.xml 수정시 반영 방법&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;harbor.xml을 수정후 무언가 반영할때는 다음과 같이 진행한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 변경내역 반영
$ ./prepare
# docker-compose 재실행
$ docker-compose down -v
$ docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;harbor에-이미지-올리고-받기&quot;&gt;harbor에 이미지 올리고 받기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;docker login&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;먼저 docker에서 이미지를 push 하기 위해서 login을 해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker login 10.52.181.240:8443
Username: admin
Password:
WARNING! Your password will be stored unencrypted in /home/service/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;docker tag 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker tag lahuman/react-app:0.1 10.52.181.240:8443/51scrum/test-react-app:0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;docker push&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker push 10.52.181.240:8443/51scrum/test-react-app:0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;docker pull&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker pull 10.52.181.240:8443/51scrum/test-react-app:0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;만약-x503-에러가-발생하면서-docker-login이-되지-않는다면&quot;&gt;만약 x503 에러가 발생하면서 docker login이 되지 않는다면?&lt;/h3&gt;

&lt;p&gt;인증서 문제인데 내 경우는 그냥 http 통신으로 처리하였다.&lt;/p&gt;

&lt;p&gt;우선 http 방식의 docker login을 위해서는 &lt;strong&gt;/etc/docker/daemon.json&lt;/strong&gt; 파일을 생성하고 주소 정보와 IP를 다음과 같이 추가 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;insecure-registries&quot; : [&quot;10.52.181.240:8000&quot;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 docker 서비스를 재기동 후 http로 로그인을 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ systemctl restart docker
# 로그인
$ docker login 10.52.181.240:8000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;kubernetes에서-private-repository-이미지-가져오기&quot;&gt;kubernetes에서 Private Repository 이미지 가져오기&lt;/h2&gt;

&lt;p&gt;kubernetes에서 Private Repository를 사용하기 위해서는 secret를 등록해야 한다. 
lahuman이라는 이름을 가진 secret를 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create secret docker-registry lahuman --docker-server=http://10.52.181.240:8000 --docker-username=admin --docker-password='비밀번호' --docker-email=&quot;이메일&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 http 통신으로 docker login 한다면, kubernetes worker의 docker에 &lt;strong&gt;insecure-registries&lt;/strong&gt; 설정을 해야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;등록된 값의 상세 확인은 다음의 명령어로 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secret lahuman --output=&quot;jsonpath={.data.\.dockerconfigjson}&quot; | base64 -d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 pod를 배포해서 정상 동작 되는지 확인해보자&lt;/p&gt;

&lt;p&gt;우산 다음과 같은 pod.yml을 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: react
  template:
    metadata:
      labels:
        app: react
    spec:
      containers:
      - name: hello-container
        image: lahuman/test-react-app
        ports:
        - containerPort: 80
      imagePullSecrets:
      - name: lahuman
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성된 파일을 kubectl 명령어를 이용해서 반영한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f pod.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pod
NAME                          READY   STATUS    RESTARTS   AGE
hello-react-6968cdc94-5fxrv   1/1     Running   0          51m
hello-react-6968cdc94-5lpdg   1/1     Running   0          51m
hello-react-6968cdc94-82zh6   1/1     Running   0          51m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;외부에서 접근하기 위해서 service.yml 파일을 작성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: hello-svc
spec:
  selector:
    app: react
  ports:
    - port: 8200
      targetPort: 80
  externalIPs:
    - 10.52.181.240
    - 10.52.181.241
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;서비스 파일을 kubectl 명령을 이용해서 반영한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl apply -f service.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정상적으로 동작하는지 브라우저를 통해 확인하면 된다!&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://goharbor.io/&quot;&gt;Harbor&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://sarc.io/index.php/cloud/1702-install-harbor&quot;&gt;Harbor 설치&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/&quot;&gt;Pull an Image from a Private Registry&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.rackspace.com/docs/rkaas/latest/external/rkaas-userguide/configure-docker-registry/&quot;&gt;Example of private Docker registry usage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.uniqbuild.co.kr/?p=724&quot;&gt;Kubernetes + private docker registry&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ohgyun.com/484&quot;&gt;쉘에서 느낌표 이스케이프하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="kubernetes" /><category term="yaml" /><summary type="html">private repository를 생성해서 이미지를 올리고, kubernetes에서 실행해보자!</summary></entry><entry><title type="html">Material-Components</title><link href="https://lahuman.github.io/material-components/" rel="alternate" type="text/html" title="Material-Components" /><published>2020-01-10T00:00:00+09:00</published><updated>2020-01-10T00:00:00+09:00</updated><id>https://lahuman.github.io/material-components</id><content type="html" xml:base="https://lahuman.github.io/material-components/">&lt;h1 id=&quot;material-components&quot;&gt;MATERIAL-COMPONENTS&lt;/h1&gt;

&lt;h2 id=&quot;github-source-바로가기&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/Material-components&quot;&gt;github source 바로가기&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;docker-repository-바로가기&quot;&gt;&lt;a href=&quot;https://hub.docker.com/repository/docker/lahuman/test-react-app&quot;&gt;docker repository 바로가기&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;docker로-빠른-실행-해보기&quot;&gt;docker로 빠른 실행 해보기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d --name react-app -p 80:80 lahuman/test-react-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;프로젝트-개요&quot;&gt;프로젝트 개요&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;오랜만에 진행하는 개인 프로젝트입니다.
(간간히 짧은건 몇개 진행하였습니다.) 요즘 ReactJS를 활용하고 있는데요. 몇몇 컴포넌트들은 살짝 변경해서 공통으로 쓰고 있습니다. 이런 공통 컴포넌트들을 오픈소스화 해보려고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ReactJS + MaterialUI 기반에서 동작합니다.&lt;/p&gt;

&lt;p&gt;기본으로 제공되는 component를 변경하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;datepicker&quot;&gt;Datepicker&lt;/h2&gt;

&lt;p&gt;기존 datepicker에서 달력에 표시되는 포멧을 한글로 변경하고 삭제 등의 기능을 추가 하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/lahuman/Material-components/raw/master/images/datepicker.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;App.js에서 포멧이나 타임존에 대한 변경을 할수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;주의 할점은 @date-io/moment 2.X에서는 오류가 발생합니다. 1.3.x를 사용해주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// for MuiPickers only
MomentUtils.prototype.getCalendarHeaderText = date =&amp;gt; {
  return MomentUtils.prototype.format(date, 'YYYY년 M월');
};
MomentUtils.prototype.getDateTimePickerHeaderText = date =&amp;gt; {
  return MomentUtils.prototype.format(date, &quot;M월 D일&quot;);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;datatable&quot;&gt;DataTable&lt;/h2&gt;

&lt;p&gt;기본 테이블에 정렬기능을 추가 하였습니다.&lt;/p&gt;

&lt;p&gt;복잡하지 않고 정렬만 사용할 경우 유용합니다.&lt;/p&gt;

&lt;p&gt;정렬되고 있는 컬럼에 정렬방식을 표기하고 다시 클릭하면 반대로 정렬합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/lahuman/Material-components/raw/master/images/datatable.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><category term="reactjs" /><category term="materialui" /><summary type="html">ReactJS + MaterialUI = Custom Components</summary></entry><entry><title type="html">Rancher로 Kubernetes 설치 &amp;amp; 관리 하기</title><link href="https://lahuman.github.io/rancher/" rel="alternate" type="text/html" title="Rancher로 Kubernetes 설치 &amp; 관리 하기" /><published>2020-01-09T00:00:00+09:00</published><updated>2020-01-09T00:00:00+09:00</updated><id>https://lahuman.github.io/rancher</id><content type="html" xml:base="https://lahuman.github.io/rancher/">&lt;h1 id=&quot;rancher로-kubernetes-설치--관리-하기&quot;&gt;Rancher로 Kubernetes 설치 &amp;amp; 관리 하기&lt;/h1&gt;

&lt;p&gt;어제 쿠버네티스를 한땀 한땀 설치하였다. 
설정을 하려고 보니 생각보다 손이 많이가서 오늘 진행하기로 하였다.&lt;/p&gt;

&lt;h2 id=&quot;하지만&quot;&gt;하지만!&lt;/h2&gt;

&lt;p&gt;쿠버네티스 경험자인 동료분이 Rancher를 활용하면 쉽게 설치를 할 수 있다고 추천해주셨다.&lt;/p&gt;

&lt;h2 id=&quot;rancher란&quot;&gt;Rancher란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rancher is a complete software stack for teams adopting containers. It addresses the operational and security challenges of managing multiple Kubernetes clusters across any infrastructure, while providing DevOps teams with integrated tools for running containerized workloads.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Rancher는 컨테이너를 채택한 팀을위한 완벽한 소프트웨어 스택입니다. 모든 인프라에서 여러 Kubernetes 클러스터를 관리해야하는 운영 및 보안 문제를 해결하는 동시에 DevOps 팀에 컨테이너화 된 워크로드 실행을위한 통합 도구를 제공합니다.&lt;/p&gt;

&lt;h2 id=&quot;설치-하기&quot;&gt;설치 하기&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이로서 Rancher가 설치 되었다.&lt;/p&gt;

&lt;p&gt;만약 아래와 같은 오류가 발생한다면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher
6ab639e217cccebed6fb4bdd8aa4049e247740b4f00c519c5294fe1ad40c9239
docker: Error response from daemon: driver failed programming external connectivity on endpoint thirsty_volhard (58f908f66cd6a307f6c0ce111fe5b755049a76df806c0ed85d53cfe3e24cce6b):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 443 -j DNAT --to-destination 172.17.0.2:443 ! -i docker0: iptables: No chain/target/match by that name.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker 서비스를 재기동 후 다시 설치하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Rancher는 도커 환경에서 실행되며 쿠버네티스를 도커 환경에서 구축한다.&lt;/p&gt;

&lt;p&gt;이후 웹 화면을 띄우면 admin 비밀번호를 설정 하도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;add-cluster&quot;&gt;Add Cluster&lt;/h2&gt;

&lt;p&gt;첫화면을 들어갔다면 먼저 Add Cluster메뉴를 선택해서 쿠버네티스를 구성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-cluster.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버의 디스크를 활용할 예정이라면, &lt;strong&gt;From existing nodes (Custom)&lt;/strong&gt; 버튼을 클릭한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-addcluster-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Cluster Name만 주고 Next 버튼을 클릭해도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-addcluster-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 docker 명령어가 화면에 표시 된다.&lt;/p&gt;

&lt;p&gt;첫 2개의 체크 박스는 마스터 노드를 뜻한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-master.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막 체크 박스인 worker는 pod을 가진 node를 뜻한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-worker.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;물론 3개의 체크박스를 모두 선택하고 명령어를 실행해도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-runcommand.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령어를 실행하고 난 이후 결과는 다음과 같다.
(좀 많은 시간이 걸린다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-active.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 활성화된 클러스터를 클릭 하면 다음과 같은 대시 보드를 확인 할수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-dashboard.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 쿠버네티스 관련 명령어를 웹에서 &lt;strong&gt;Launch Kubectl&lt;/strong&gt; 명령어를 이용해서 실행해볼 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;kubectl get all&lt;/strong&gt;을 실행한 결과이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-shell.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;오늘-엄청-배움&quot;&gt;오늘 엄청 배움!!!&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/rancher-worker.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><category term="kubernetes" /><category term="rancher" /><summary type="html">오메 신세계다!!!</summary></entry><entry><title type="html">쿠버네티스 설치 yum 명령어에서 오류를 만났다.</title><link href="https://lahuman.github.io/yum_certificate_issuer/" rel="alternate" type="text/html" title="쿠버네티스 설치 yum 명령어에서 오류를 만났다." /><published>2020-01-08T00:00:00+09:00</published><updated>2020-01-08T00:00:00+09:00</updated><id>https://lahuman.github.io/yum_certificate_issuer</id><content type="html" xml:base="https://lahuman.github.io/yum_certificate_issuer/">&lt;h1 id=&quot;쿠버네티스-설치-중-오류를-만났다&quot;&gt;쿠버네티스 설치 중 오류를 만났다.&lt;/h1&gt;

&lt;h2 id=&quot;1-도커설치&quot;&gt;1. 도커설치&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;쿠버네티스를 설치 하기 전에 도커를 설치 해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install -y yum-utils device-mapper-persistent-data lvm2
$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
$ yum install docker-ce
$ systemctl start docker &amp;amp;&amp;amp; systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2-쿠버네티스-설치&quot;&gt;2. 쿠버네티스 설치&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
$ [kubernetes]
$ name=Kubernetes
$ baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
$ enabled=1
$ gpgcheck=1
$ repo_gpgcheck=1
$ gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
$ EOF
 
$ # Set SELinux in permissive mode (effectively disabling it)
$ setenforce 0
$ sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config
 
$ yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes

$ systemctl enable --now kubelet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치 과정을 따라 하던중, 이 부분에서 다음과 같은 오류를 만나게 되었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: ftp.iij.ad.jp
 * extras: ftp.iij.ad.jp
 * updates: mirror.navercorp.com
base                                                     | 3.6 kB     00:00
docker-ce-stable                                         | 3.5 kB     00:00
extras                                                   | 2.9 kB     00:00
https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64/repodata/repomd.xml: [Errno 14] curl#60 - &quot;Peer's certificate issuer has been marked as not trusted by the user.&quot;
Trying other mirror.
It was impossible to connect to the CentOS servers.
This could mean a connectivity issue in your environment, such as the requirement to configure a proxy,
or a transparent proxy that tampers with TLS security, or an incorrect system clock.
You can try to solve this issue by using the instructions on https://wiki.centos.org/yum-errors
If above article doesn't help to resolve this issue please use https://bugs.centos.org/.

... 계속
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문제 발생 이유로는 방화벽일 수도 있고, 보안 프로그램일수도 있다고 한다.&lt;/p&gt;

&lt;p&gt;가장 쉽게 해결하는 방법은&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sslverify=0&lt;/strong&gt;을 /etc/yum.repos.d/kubernetes.repo 파일에 추가 하면 다음과 같이 넘거 간다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: ftp.iij.ad.jp
 * extras: ftp.iij.ad.jp
 * updates: mirror.navercorp.com
base                                                     | 3.6 kB     00:00
docker-ce-stable                                         | 3.5 kB     00:00
extras                                                   | 2.9 kB     00:00
kubernetes/signature                                     |  454 B     00:00
Retrieving key from https://packages.cloud.google.com/yum/doc/yum-key.gpg
Importing GPG key 0xA7317B0F:
 Userid     : &quot;Google Cloud Packages Automatic Signing Key &amp;lt;gc-team@google.com&amp;gt;&quot;
 Fingerprint: d0bc 747f d8ca f711 7500 d6fa 3746 c208 a731 7b0f
 From       : https://packages.cloud.google.com/yum/doc/yum-key.gpg
Retrieving key from https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
kubernetes/signature                                     | 1.4 kB     00:00 !!!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;끝&quot;&gt;끝!!!&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/&quot;&gt;Get Docker Engine - Community for CentOS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&quot;&gt;Installing kubeadm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://forums.centos.org/viewtopic.php?t=65658&quot;&gt;yum https repository error no. 14&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="yum" /><category term="error" /><summary type="html">Peer's certificate issuer has been marked as not trusted by the user.</summary></entry><entry><title type="html">Material UI의 몇몇 컴포넌트를 내부용 OPENSOURCE 화해서 사용하는건 어떨가?</title><link href="https://lahuman.github.io/20200108/" rel="alternate" type="text/html" title="Material UI의 몇몇 컴포넌트를 내부용 OPENSOURCE 화해서 사용하는건 어떨가?" /><published>2020-01-08T00:00:00+09:00</published><updated>2020-01-08T00:00:00+09:00</updated><id>https://lahuman.github.io/20200108</id><content type="html" xml:base="https://lahuman.github.io/20200108/">&lt;h1 id=&quot;회사에서-reactjs를-사용하는데-몇몇-컴포넌트는-그냥-사용하기-아쉽다&quot;&gt;회사에서 ReactJS를 사용하는데, 몇몇 컴포넌트는 그냥 사용하기 아쉽다.&lt;/h1&gt;

&lt;p&gt;주요 사용하는 컴포넌트 중에 다음의 컴포넌트는 늘 수정해서 사용한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;TABLE : 데이터를 매핑하고 정렬기능, 페이징 기능을 추가&lt;/li&gt;
  &lt;li&gt;DATEPICKER : 한국느낌 나게 만들고, INPUT 을 심플하게 바꾸기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;우선 생각나는게 2개 있다.&lt;/p&gt;

&lt;h2 id=&quot;해보자&quot;&gt;해보자!!&lt;/h2&gt;</content><category term="단상" /><summary type="html">이거는 한번 해봐도 되겠다</summary></entry></feed>

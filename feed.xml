<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2019-03-02T15:17:03+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">AWS ec2 key 생성 &amp;amp; 로그인</title><link href="https://lahuman.github.io/aws_login_user_key/" rel="alternate" type="text/html" title="AWS ec2 key 생성 &amp; 로그인" /><published>2019-02-28T00:00:00+09:00</published><updated>2019-02-28T00:00:00+09:00</updated><id>https://lahuman.github.io/aws_login_user_key</id><content type="html" xml:base="https://lahuman.github.io/aws_login_user_key/">&lt;h1 id=&quot;aws에서-ec2-로그인-계정-생성-처리-방법&quot;&gt;AWS에서 EC2 로그인 계정 생성 처리 방법&lt;/h1&gt;

&lt;p&gt;현재 설정은 AWS에서 EC2 인스턴스(ubunt 기반)를 생성 후 접속은 pem 파일을 이용하도록 되어있다.&lt;/p&gt;

&lt;p&gt;하나의 pem 파일을 이용하는 것은 보안에도 좋지 않고, 초기 계정은 Root 권한을 가질 수 있는 계정이기에 위험하다. 따라서 EC2에 접근 가능한 추가 계정을 생성하는 것을 알아보자.&lt;/p&gt;

&lt;p&gt;AWS의 EC2 서버에서 먼저 계정을 생성 한다. 현재 계정은 root 권한을 가진 ubuntu(기본)이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 계정 생성
$&amp;gt; sudo useradd lahuman
# 생성된 계정으로 계정 변경
$&amp;gt; sudo su - lahuman
# .ssh 디렉토리 생성 &amp;amp; authorized_keys 파일 생성
$&amp;gt; mkdir .ssh
$&amp;gt; chmod 700 .ssh
$&amp;gt; cd .ssh
$&amp;gt; touch authorized_keys
$&amp;gt; chmod 600 authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;계정 생성이 완료 되었으면 &lt;kbd&gt;EC2&lt;/kbd&gt; &amp;gt; &lt;kbd&gt;네트워크 및 보안&lt;/kbd&gt; &amp;gt; &lt;kbd&gt;키 페어&lt;/kbd&gt; 메뉴로 이동을 하여 &lt;kbd&gt;키 페어 생성&lt;/kbd&gt; 버튼을 클릭한다.&lt;/p&gt;

&lt;p&gt;키 페어 명을 넣고 생성을 하면 &lt;kbd&gt;pem 파일&lt;/kbd&gt;이 자동으로 down 된다. 이 pem 파일은 무척 중요하다!&lt;/p&gt;

&lt;p&gt;이 pem 파일을 EC2 서버의 아까 생성한 계정 밑으로 복사 한다.&lt;/p&gt;

&lt;p&gt;이후 다음 명령어를 이용하여 public Key를 생성하고 해당 키 값을 authorized_keys에 저장한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# upload 된 pem 의 권한을 600 으로 수정한다.
$&amp;gt; chmod 500 lahuman.pem
# public key 생성
$&amp;gt; ssh-keygen -y
Enter file in which the key is (/home/lahuman/.ssh/id_rsa): /home/lahuman/lahuman.pem
ssh-rsa ABCDEF........key......

# ssh-rsa 이후 키 값을 복사하여 authorized_keys 에 추가한다.
$&amp;gt; vi .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 내 자리에서 pem 파일을 이용해서 로그인을 시도 하면 잘 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; ssh -i &quot;lahuman.pem&quot; lahuman@IP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;쉬운-듯-어려운-설정&quot;&gt;쉬운 듯 어려운 설정&lt;/h2&gt;</content><category term="pem" /><category term="cert" /><summary type="html">AWS에서 key(pem)을 생성하고 로그인까지 해보기</summary></entry><entry><title type="html">crt, key 인증서 파일 pem으로 변환</title><link href="https://lahuman.github.io/cet_key_to_pem/" rel="alternate" type="text/html" title="crt, key 인증서 파일 pem으로 변환" /><published>2019-02-27T00:00:00+09:00</published><updated>2019-02-27T00:00:00+09:00</updated><id>https://lahuman.github.io/cet_key_to_pem</id><content type="html" xml:base="https://lahuman.github.io/cet_key_to_pem/">&lt;h1 id=&quot;cert-key-파일을-pem-파일로-변환-하기&quot;&gt;cert, key 파일을 pem 파일로 변환 하기&lt;/h1&gt;

&lt;p&gt;nginx에서 사용하던 인증서를 nodejs에서 바로 사용을 하기 위해 pem 파일 형식으로 변경 해야하는 일이 생겨서 검색을 해보았다.
파일 형석의 변환은 다음과 같이 쉽게 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# key 변경
openssl rsa -in server.key -text &amp;gt; private.pem
# crt 변경
openssl x509 -inform PEM -in server.crt &amp;gt; public.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;추가-팁-nodejs-에서-https-설정&quot;&gt;추가 팁] nodejs 에서 https 설정&lt;/h2&gt;
&lt;p&gt;nodejs에서 https 사용을 위해서는 https 모듈을 추가로 설치 해야 한다.&lt;/p&gt;

&lt;p&gt;이후 소스내에 다음과 같이 인증서를 &lt;strong&gt;options&lt;/strong&gt;을 추가 하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const https = require('https');
const fs = require('fs');
const options = {
  ca: fs.readFileSync('인증서경로/ca-bundle.pem')
  key: fs.readFileSync('인증서경로/domain_xxxxx.key.pem')
  cert: fs.readFileSync('인증서경로/domain_xxxxx.crt.pem')
};
https.createServer(options, (req, res) =&amp;gt; {
  res.writeHead(200);
  res.end('hello world\n');
}).listen(443);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;참-쉽죠&quot;&gt;참 쉽죠?&lt;/h3&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/991758/how-to-get-pem-file-from-key-and-crt-files&quot;&gt;How to get .pem file from .key and .crt files?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.securesign.kr/guides/Node-js-SSL-Certificates-Install&quot;&gt;Node.js SSL 인증서 설치/적용 가이드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="pem" /><category term="cert" /><summary type="html">인증서 파일 형식 변경 처리 &amp; node 에서 https 사용설정</summary></entry><entry><title type="html">요즘 진행된 일들을 정리를 못하고 있다.</title><link href="https://lahuman.github.io/20190227/" rel="alternate" type="text/html" title="요즘 진행된 일들을 정리를 못하고 있다." /><published>2019-02-27T00:00:00+09:00</published><updated>2019-02-27T00:00:00+09:00</updated><id>https://lahuman.github.io/20190227</id><content type="html" xml:base="https://lahuman.github.io/20190227/">&lt;h1 id=&quot;요즘-많은-새로운-것을-익히기도-하고-기존에-해-보았던-것도-다시-해보고-있다&quot;&gt;요즘 많은 새로운 것을 익히기도 하고, 기존에 해 보았던 것도 다시 해보고 있다.&lt;/h1&gt;

&lt;p&gt;이직을 하고 3개월이 흘렀다. 
월급을 3번 받아 보았고, 제대로된 급여는 2번 받아 보았다.&lt;/p&gt;

&lt;p&gt;이직하고 달라진 점드를 뽑으면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용하는 언어가 달라 졌다.
    &lt;ul&gt;
      &lt;li&gt;10여년간 사용하던 JAVA에서 Python을 거쳐 Nodejs를 사용하고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;바쁘게 일한다.
    &lt;ul&gt;
      &lt;li&gt;20대 후반에 하는 방식으로 일하고 있다.&lt;/li&gt;
      &lt;li&gt;변화를 두려워 하지 않고 일단 해본다.&lt;/li&gt;
      &lt;li&gt;안되면 동료에게 물어본다.&lt;/li&gt;
      &lt;li&gt;새로운 도전을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이젠 시니어다.
    &lt;ul&gt;
      &lt;li&gt;주니어 개발자와 함께 일하며, 주니어 개발자가 발전 할 수 있는 조언을 주어야 한다.&lt;/li&gt;
      &lt;li&gt;꼰대 같은 생각이 든다.&lt;/li&gt;
      &lt;li&gt;나도 모르게 “내 생각이 옳다고만 생각 한다.”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장점도 있고 단점도 있지만 이직 자체는 성공적이다.&lt;/p&gt;

&lt;p&gt;기존 회사보다 일도 많아지고 책임도 커졌지만, 무엇보다 즐겁다.&lt;/p&gt;

&lt;h3 id=&quot;반성해-하는-점&quot;&gt;반성해 하는 점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;또 오지랍을 부리고 있다.
    &lt;ul&gt;
      &lt;li&gt;내 일이나 잘하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;은근 슬쩍 잘하는 사람에게 일을 미룬다.
    &lt;ul&gt;
      &lt;li&gt;함께 하는 동료중에 잘하는 분이 계신데 너무 믿고 있는건지 내일도 슬쩍 미룬다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;잘난척 한다.
    &lt;ul&gt;
      &lt;li&gt;이건 대 반성 하자…&lt;/li&gt;
      &lt;li&gt;좀 조용하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;반성-하면-변화하는-내가-되자&quot;&gt;반성 하면 변화하는 내가 되자&lt;/h3&gt;</content><category term="단상" /><summary type="html">바쁘다는 핑계로 정리를 못하고 있다.</summary></entry><entry><title type="html">MongoDB backup &amp;amp; restore</title><link href="https://lahuman.github.io/mongodb_backup_restore/" rel="alternate" type="text/html" title="MongoDB backup &amp; restore" /><published>2019-02-23T00:00:00+09:00</published><updated>2019-02-23T00:00:00+09:00</updated><id>https://lahuman.github.io/mongodb_backup_restore</id><content type="html" xml:base="https://lahuman.github.io/mongodb_backup_restore/">&lt;h1 id=&quot;mongodb-backup--restore&quot;&gt;MongoDB backup &amp;amp; restore&lt;/h1&gt;

&lt;p&gt;간단하게 몽고 디비 백업과 복구를 해보겠다.&lt;/p&gt;

&lt;p&gt;먼저 백업 명령은 다음과 같다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 결과로 디렉터리가 생성 된다.
# 특정 collection 명이나 DB 명을 Backup 할 수 있다.
$&amp;gt; mongodump --collection words --db TEST --out ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 복원 하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 특정 컬렉션만 복원 할 수 있으며 --drop  옵션을 추가 하면 삭제하고 복원 한다.
$&amp;gt; mongorestore --host 172.30.10.1 --port 27017 --db TEST --collection words --username tester --password 'password'  ./TEST/words.bson --drop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;가끔씩-쓸일이-생긴다&quot;&gt;가끔씩 쓸일이 생긴다.&lt;/h2&gt;</content><category term="mongodb" /><category term="tip" /><summary type="html">몽고 DB 백업 &amp; 리스토어</summary></entry><entry><title type="html">AWS LAMBDA를 이용해서 개발하다</title><link href="https://lahuman.github.io/Aws_Lambda/" rel="alternate" type="text/html" title="AWS LAMBDA를 이용해서 개발하다" /><published>2019-02-20T00:00:00+09:00</published><updated>2019-02-20T00:00:00+09:00</updated><id>https://lahuman.github.io/Aws_Lambda</id><content type="html" xml:base="https://lahuman.github.io/Aws_Lambda/">&lt;h1 id=&quot;aws-lambda-를-개발시-알면-좋은-팁&quot;&gt;AWS LAMBDA 를 개발시 알면 좋은 팁&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Lambda를 API Gateway를 통해서 호출 하도록 설정 할때 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&quot;&gt;매핑 템플릿
&lt;/a&gt;을 사용하면 IP 등의 정보를 얻을 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Lambda에서 RDS에 접근하기 위해서는 VPC를 설정해야 한다.&lt;/li&gt;
  &lt;li&gt;VPC가 설정된 Lambda는 외부 인터넷에 접근 할 수 없다.&lt;/li&gt;
  &lt;li&gt;VPC가 설정된 Lambda는 내부 private IP만 접근 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다시 사용할 일이 올지는 모르겠지만, 재미있었다.&lt;/p&gt;

&lt;h3 id=&quot;신기술은-늘-어렵다-근데-써보고-나면-별거-없다&quot;&gt;신기술은 늘 어렵다. 근데 써보고 나면 별거 없다.&lt;/h3&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&quot;&gt;API Gateway 매핑 템플릿 참조
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.shikisoft.com/running-aws-lambda-in-vpc-accessing-rds/?fbclid=IwAR2-KHd23Db2PnVfm1JKDW_WoanfKRe2oamcsAhO1-mJomvta_EHNzoppVk&quot;&gt;Running AWS Lambda Functions in a VPC and Accessing RDS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="aws" /><category term="tip" /><summary type="html">작은 모듈을 사용할때 좋을 듯!</summary></entry><entry><title type="html">Async 모듈을 이용한 비동기 처리</title><link href="https://lahuman.github.io/node_async/" rel="alternate" type="text/html" title="Async 모듈을 이용한 비동기 처리" /><published>2019-02-12T00:00:00+09:00</published><updated>2019-02-12T00:00:00+09:00</updated><id>https://lahuman.github.io/node_async</id><content type="html" xml:base="https://lahuman.github.io/node_async/">&lt;h1 id=&quot;얼마전-node에서-비동기-처리를-순서대로-처리해야-하는-일이-있었다&quot;&gt;얼마전 Node에서 비동기 처리를 순서대로 처리해야 하는 일이 있었다.&lt;/h1&gt;

&lt;p&gt;구글을 검색하다 &lt;a href=&quot;https://stackoverflow.com/questions/31799175/async-waterfall-in-a-for-loop-in-node-js?fbclid=IwAR3Mx9ZXS8qxNhKQqgSqB8KIFmIko031E0uCmhPFkAiXY0mFR5UAs5Y-_XA&quot;&gt;async.waterfall in a For Loop in Node.js&lt;/a&gt;을 찾았다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var async = require(&quot;async&quot;)
var users = []; // Initialize user array or get it from DB

async.forEachLimit(users, 1, function(user, userCallback){

    async.waterfall([
        function(callback) {
            callback(null, 'one', 'two');
        },
        function(arg1, arg2, callback) {
            // arg1 now equals 'one' and arg2 now equals 'two'
            callback(null, 'three');
        },
        function(arg1, callback) {
            // arg1 now equals 'three'
            callback(null, 'done');
        }
    ], function (err, result) {
        // result now equals 'done'
        console.log('done')
        userCallback();
    });


}, function(err){
    console.log(&quot;User For Loop Completed&quot;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async&lt;/a&gt;는 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;async, await&lt;/a&gt;인줄 알았는데, 비동기 처리에 사용하는 모듈 이었다.&lt;/p&gt;

&lt;p&gt;70 여 가지 모듈을 지원하며, 예제도 잘 나와 있다.&lt;/p&gt;

&lt;p&gt;이중 제어 관련하여 다음의 매소드 등이 제공된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;XXXLimit : 한번에 처리 하는 Worker 갯수 지정&lt;/li&gt;
  &lt;li&gt;XXXSeries : 한개씩 처리&lt;/li&gt;
  &lt;li&gt;waterfall : 여러 비동기 처리를 순차적으로 처리&lt;/li&gt;
  &lt;li&gt;parallel : 콜렉션을 병렬 처리&lt;/li&gt;
  &lt;li&gt;apply : 인수 처리&lt;/li&gt;
  &lt;li&gt;map : 새로운 컬렉션을 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 외에도 많은 기능이 제공된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Async provides around 70 functions that include the usual ‘functional’ suspects (map, reduce, filter, each…) as well as some common patterns for asynchronous control flow (parallel, series, waterfall…). All these functions assume you follow the Node.js convention of providing a single callback as the last argument of your asynchronous function – a callback which expects an Error as its first argument – and calling the callback once.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;비동기-처리를-할때-사용하면-상당히-유용하다&quot;&gt;비동기 처리를 할때 사용하면 상당히 유용하다.&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://caolan.github.io/async/&quot;&gt;async&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31799175/async-waterfall-in-a-for-loop-in-node-js?fbclid=IwAR3Mx9ZXS8qxNhKQqgSqB8KIFmIko031E0uCmhPFkAiXY0mFR5UAs5Y-_XA&quot;&gt;async.waterfall in a For Loop in Node.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31815917/how-to-skip-a-async-foreachof-loop-iteration-in-node-js&quot;&gt;How to Skip a “async.forEachOf” loop iteration in Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="tip" /><summary type="html">병렬, 직렬, 순서 등 비동기 제어에 도움이 되는 모듈</summary></entry><entry><title type="html">인증서버 구축기 - 1</title><link href="https://lahuman.github.io/auth_server_1/" rel="alternate" type="text/html" title="인증서버 구축기 - 1 " /><published>2019-02-09T00:00:00+09:00</published><updated>2019-02-09T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_1</id><content type="html" xml:base="https://lahuman.github.io/auth_server_1/">&lt;h1 id=&quot;간단한-인증-서버를-구축-해보자&quot;&gt;간단한 인증 서버를 구축 해보자!&lt;/h1&gt;

&lt;p&gt;인증 서버를 구축해보려고 한다.&lt;/p&gt;

&lt;p&gt;간단하게 설계는 다음과 같이 했다.&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;/assets/img/post_img/auth_service.png&quot;&gt;&lt;img src=&quot;/assets/img/post_img/auth_service.png&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;AUTH server Sequence diagram&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;개발 언어는 &lt;a href=&quot;https://nodejs.org/ko/&quot;&gt;Node.js&lt;/a&gt;를 이용하여 개발 계획이다.&lt;/p&gt;

&lt;p&gt;이미 Auth Server를 구현한 샘플이 많아서 새로운 것은 아니지만, 새로운 기술을 배우는 것을 목적으로 진행한다.&lt;/p&gt;

&lt;p&gt;Frontend는 &lt;a href=&quot;https://kr.vuejs.org/v2/guide/index.html&quot;&gt;vue.js&lt;/a&gt;를 사용해보고 ORM 툴인 &lt;a href=&quot;http://docs.sequelizejs.com/&quot;&gt;sequelizejs&lt;/a&gt;도 사용할 계획이다.&lt;/p&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;</content><category term="node" /><category term="auth" /><summary type="html">기존에는 완료된 프로젝트만 적었는데, 진행하는 과정을 남겨 보자</summary></entry><entry><title type="html">nodejs에서 request Body에 json 처리 &amp;amp; body 크기 제한</title><link href="https://lahuman.github.io/node_bodyParser/" rel="alternate" type="text/html" title="nodejs에서 request Body에 json 처리 &amp; body 크기 제한" /><published>2019-02-06T00:00:00+09:00</published><updated>2019-02-06T00:00:00+09:00</updated><id>https://lahuman.github.io/ node_bodyParser</id><content type="html" xml:base="https://lahuman.github.io/node_bodyParser/">&lt;h1 id=&quot;express에서-post호출-시-request의-body에서-undefined가-발생한다&quot;&gt;Express에서 post호출 시 request의 body에서 undefined가 발생한다.&lt;/h1&gt;

&lt;p&gt;다음과 같이 호출 했는데 결과가 undefined일 경우는 body-parser를 설정하지 않아서 이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# post 호출시, body에 {test:'hello&quot;} 를 함께 전송

#router 소스
router.post('/', (req, res) =&amp;gt; {
  console.log(req.body); undefined 발생
  res.redirect('/');
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처리 방법은 body-parser를 express에서 사용하도록 설정 하면된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# body-parser 설치
$&amp;gt; npm install --save body-parser

#app.js 소스
const express = require('express');
const bodyParser = require('body-parser');

const app = express();
app.use(bodyParser().json()); //bodyparser 사용 설정
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 만나는 문제는 body의 크기가 크다는 오류를 만난 수 있다.
이때는 body의 크기를 옵션 설정하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const bodyParser = require('body-parser');
app.use(bodyParser.json({limit: '50mb'})); //body 의 크기 설정
app.use(bodyParser.urlencoded({limit: '50mb', extended: true})); //url의 크기 설정
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가로 express 4.16부터는 body-parser를 포함 하고 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const express = require('express')
const app = express();
app.use(express.json())
app.post('/', (req, res) =&amp;gt; {
  console.log(req.body)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;알아두자&quot;&gt;알아두자&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/9049993/node-js-how-to-limit-the-http-request-size-and-upload-file-size&quot;&gt;node-js-how-to-limit-the-http-request-size-and-upload-file-size&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://expressjs.com/en/4x/api.html#express-json-middleware&quot;&gt;express-json-middleware&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="bodyparser" /><summary type="html">express 4.16이상에서는 body-Pararse가 내장되어 있다.</summary></entry><entry><title type="html">Node 모듈 설치시 오류시 해결 방법</title><link href="https://lahuman.github.io/node_tip/" rel="alternate" type="text/html" title="Node 모듈 설치시 오류시 해결 방법" /><published>2019-02-04T00:00:00+09:00</published><updated>2019-02-04T00:00:00+09:00</updated><id>https://lahuman.github.io/node_tip</id><content type="html" xml:base="https://lahuman.github.io/node_tip/">&lt;h1 id=&quot;node-모듈-설치시-오류시-해결-방법&quot;&gt;Node 모듈 설치시 오류시 해결 방법&lt;/h1&gt;

&lt;p&gt;node 버젼이 변경된 상태에서 npm install을 하면, 오류가 발생하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;이럴때 해결 방법은 정말 단순 하다.&lt;/p&gt;

&lt;p&gt;해당 모듈을 삭제 하고 재설치 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install
#oracle-db 모듈 오류발생

#oracle-db 모듈 삭제
npm uninstall oracle-db

#oracle-db 모듈 설치
npm install --save oracle-db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;컴터-동작이-이상하면-재기동-하면-되듯이-모듈도-재설치-하면된다&quot;&gt;컴터 동작이 이상하면 재기동 하면 되듯이, 모듈도 재설치 하면된다.&lt;/h2&gt;</content><category term="node" /><category term="tip" /><summary type="html">npm install 시 오류 발생시 처리 방안</summary></entry><entry><title type="html">pm2 cluster mode 특징</title><link href="https://lahuman.github.io/pm2_cluster_mode/" rel="alternate" type="text/html" title="pm2 cluster mode 특징" /><published>2019-02-03T00:00:00+09:00</published><updated>2019-02-03T00:00:00+09:00</updated><id>https://lahuman.github.io/pm2_cluster_mode</id><content type="html" xml:base="https://lahuman.github.io/pm2_cluster_mode/">&lt;h1 id=&quot;pm2-cluster-mode에서는-session이나-websocket이-동작-하지-않는다&quot;&gt;pm2 cluster mode에서는 session이나 websocket이 동작 하지 않는다.&lt;/h1&gt;

&lt;p&gt;pm2에서 제공하는 클러스터 모드는 코드의 수정 없이 CPU를 확장할 수 있다. Node.js 클러스터 모듈을 사용하여 확장 된 응용 프로그램의 하위 프로세스가 자동으로 서버 포트를 공유 하도록 하는 기능이다.&lt;/p&gt;

&lt;p&gt;사용법은 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -i 옵션이 cluster 모드이며, max는 사용할 CPU 수를 입력 하면 된다.
# 0을 입력하면, 자동으로 모든 CPU 숫자만큼 클러스터가 생성된다.
pm2 start app.js -i max
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;또는 js/yaml/json 파일을 통해서 설정을 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;apps&quot; : [{
    &quot;script&quot;    : &quot;api.js&quot;,
    &quot;instances&quot; : &quot;max&quot;,
    &quot;exec_mode&quot; : &quot;cluster&quot; 
  }]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cluster Mode를 사용하면 가장 중요한게 &lt;a href=&quot;http://pm2.keymetrics.io/docs/usage/specifics/#stateless-apps&quot;&gt;stateless application&lt;/a&gt;이 된다는 것이다.&lt;/p&gt;

&lt;p&gt;이 상태에서는 가중 중요한게 로컬 데이터 저장소를 프로세스에서 사용할수 없다는 것이다. 사용을 하고 싶으면, &lt;a href=&quot;https://github.com/tj/connect-redis&quot;&gt;connect-redis&lt;/a&gt;과 같은 프로그램을 이용하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;session이-동작하지-않아서-한참-해멧다&quot;&gt;Session이 동작하지 않아서 한참 해멧다.&lt;/h2&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://pm2.keymetrics.io/docs/usage/cluster-mode/&quot;&gt;cluster-mode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pm2.keymetrics.io/docs/usage/specifics/#stateless-apps&quot;&gt;stateless-apps&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tj/connect-redis&quot;&gt;connect-redis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="pm2" /><category term="cluster" /><summary type="html">session 동작을 하지 않는다.</summary></entry></feed>

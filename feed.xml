<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2017-12-21T16:37:54+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">Intellij에서 JDK 9과 Lombok 1.16.18을 사용하면 이상동작 해결 방법</title><link href="https://lahuman.github.io/lombok_and_jdk9_with_intellij/" rel="alternate" type="text/html" title="Intellij에서 JDK 9과 Lombok 1.16.18을  사용하면 이상동작 해결 방법" /><published>2017-12-21T00:00:00+09:00</published><updated>2017-12-21T00:00:00+09:00</updated><id>https://lahuman.github.io/lombok_and_jdk9_with_intellij</id><content type="html" xml:base="https://lahuman.github.io/lombok_and_jdk9_with_intellij/">&lt;h1 id=&quot;intellij에서-jdk-9과-lombok-11618을--사용하면-이상동작-해결-방법&quot;&gt;Intellij에서 JDK 9과 Lombok 1.16.18을  사용하면 이상동작 해결 방법&lt;/h1&gt;

&lt;p&gt;오늘 나의 시간을 가장 많이 빼앗어간 어이 없는 Lombok 오류였다.&lt;/p&gt;

&lt;p&gt;Lombok을 JDK 9와 문제 없이 이용하려면 일반 버젼의 Lombok을 설치 하면안되고 &lt;a href=&quot;https://projectlombok.org/download-edge&quot;&gt;Lombok Edge&lt;/a&gt; 을 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://lahuman.jabsiri.co.kr/124&quot;&gt;Lombok의 기본적인 설치 및 사용법&lt;/a&gt;은 블로그 글을 보면된다.&lt;/p&gt;

&lt;p&gt;오늘은 정말 최신 기술을 한번 써보겠다고 고생하였다.&lt;/p&gt;

&lt;h3 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rzwitserloot/lombok/issues/1472#issuecomment-339578781&quot;&gt;Java 9 Annotation Processing Broken &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://projectlombok.org/download-edge&quot;&gt;Lombok Edge Version Download&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="jdk9" /><category term="lombok" /><category term="intellij" /><summary type="html">최신버젼은 해롭다. 정신건강에...</summary></entry><entry><title type="html">한달만에 자바 웹 개발</title><link href="https://lahuman.github.io/20171220-phase/" rel="alternate" type="text/html" title="한달만에 자바 웹 개발" /><published>2017-12-20T00:00:00+09:00</published><updated>2017-12-20T00:00:00+09:00</updated><id>https://lahuman.github.io/20171220-phase</id><content type="html" xml:base="https://lahuman.github.io/20171220-phase/">&lt;h1 id=&quot;수집된-데이터-표출은-자바로&quot;&gt;수집된 데이터 표출은 자바로&lt;/h1&gt;

&lt;p&gt;한동안 파이썬을 이용하여 데이터 수집을 구현 하였다.&lt;/p&gt;

&lt;p&gt;다른 언어를 사용한는 재미도 있고, 생각보다 많은 시간이 투자 되었다.&lt;/p&gt;

&lt;p&gt;오늘부터는 10년 넘게 해오던 자바로 웹 개발을 한다.&lt;/p&gt;

&lt;h2 id=&quot;어떤-기술을-써볼까나&quot;&gt;어떤 기술을 써볼까나?&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">한달동안 파이썬 맛좀 봤다.</summary></entry><entry><title type="html">VMWARE를 이용한 보안 프로그램 회피 방법</title><link href="https://lahuman.github.io/avoid_security_program/" rel="alternate" type="text/html" title="VMWARE를 이용한 보안 프로그램 회피 방법" /><published>2017-12-15T00:00:00+09:00</published><updated>2017-12-15T00:00:00+09:00</updated><id>https://lahuman.github.io/avoid_security_program</id><content type="html" xml:base="https://lahuman.github.io/avoid_security_program/">&lt;h1 id=&quot;vmware를-이용한-보안-프로그램-회피-방법&quot;&gt;VMWARE를 이용한 보안 프로그램 회피 방법&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;대부분으 보안 프로그램은 Agent를 설치 하고 해당 프로그램으로 감시를 한다.
Agent 프로그램을 VMWARE에 설치 하고 속이는 방법을 사용해보자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;VMWARE 가상환경에 WINDOWS OS와 보안 Agent 프로그램을 설치 한다.&lt;/li&gt;
  &lt;li&gt;가상 환경의 MAC ADDRESS를 호스트 OS와 동일하게 설정 한다.&lt;a href=&quot;https://pubs.vmware.com/workstation-9/index.jsp?topic=%2Fcom.vmware.ws.using.doc%2FGUID-5C55C285-79B0-404F-95A5-87F64C41E3DC.html&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;가상 환경의 IP를 호스트 OS와 동일 하게 설정 한다.&lt;/li&gt;
  &lt;li&gt;가상 환경의 네트워크 설정을 Bridged Adapters 로 설정한다.&lt;a href=&quot;https://www.vmware.com/support/ws5/doc/ws_net_configurations_changing_bridged_windows.html&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 하면 외부에서 들어오는 보안 Agent 통신이 가상환경으로 넘어간다.
호스트는 가상환경만 켜두면 감시 없이 인터넷이 된다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://pubs.vmware.com/workstation-9/index.jsp?topic=%2Fcom.vmware.ws.using.doc%2FGUID-5C55C285-79B0-404F-95A5-87F64C41E3DC.html&quot;&gt;Change the MAC Address for a Virtual Machine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.vmware.com/support/ws5/doc/ws_net_configurations_changing_bridged_windows.html&quot;&gt; Configuring Bridged Networking Options on a Windows Host &lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="security" /><category term="avoid" /><summary type="html">자세한 이미지는 생략한다.</summary></entry><entry><title type="html">Python 에서 멀티 스레드를 사용하기 보다 멀티 프로세스를 사용하자.</title><link href="https://lahuman.github.io/python_thread_process/" rel="alternate" type="text/html" title="Python 에서 멀티 스레드를 사용하기 보다 멀티 프로세스를 사용하자." /><published>2017-12-14T00:00:00+09:00</published><updated>2017-12-14T00:00:00+09:00</updated><id>https://lahuman.github.io/python_thread_process</id><content type="html" xml:base="https://lahuman.github.io/python_thread_process/">&lt;h1 id=&quot;파이선의-스레드에는-약간의-제약이-있다&quot;&gt;파이선의 스레드에는 약간의 제약이 있다.&lt;/h1&gt;

&lt;p&gt;파이썬은 내부적으로 전역 인터프리터 록(Global Interpreter Lock, GIL)을 사용한다. 이것은 시스템 하나에서 스레드 하나만 실행되도록 제한한다.&lt;/p&gt;

&lt;p&gt;따라서 파이썬 쓰래드는 여러개의 코어를 활용하지 못하고 하나의 코어에서만 실행된다.&lt;/p&gt;

&lt;p&gt;대신에 여러개의 코어를 활용할 수 있는 multiprocessing 모듈을 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단 프로세스 객체를 생성하고 실행하는 코드는 반드시 __main__ 만 실행하는 코드 안에 적어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;자-지금까지-한거-고치자&quot;&gt;자 지금까지 한거 고치자..&lt;/h2&gt;</content><author><name></name></author><category term="Python" /><category term="Thread" /><summary type="html">Global Interpreter Lock, GIL 로 인한 제한</summary></entry><entry><title type="html">졸리다 넘나</title><link href="https://lahuman.github.io/20171213-phase/" rel="alternate" type="text/html" title="졸리다 넘나" /><published>2017-12-13T00:00:00+09:00</published><updated>2017-12-13T00:00:00+09:00</updated><id>https://lahuman.github.io/20171213-phase</id><content type="html" xml:base="https://lahuman.github.io/20171213-phase/">&lt;h1 id=&quot;새벽-3시까지-뒤척거리며-잠을-잘-못잤다&quot;&gt;새벽 3시까지 뒤척거리며 잠을 잘 못잤다.&lt;/h1&gt;

&lt;p&gt;논문도 써야 하고 회사 일도 이번달까지 Prototype 작성해야 하고…&lt;/p&gt;

&lt;p&gt;뭔가 할 일이 많다.&lt;/p&gt;

&lt;h2 id=&quot;졸리다-넘나&quot;&gt;졸리다 넘나..&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">잠을 잘 못잠</summary></entry><entry><title type="html">tor, phantomJS를 Ubuntu에 설치</title><link href="https://lahuman.github.io/tor_phantomjs_install_on_ubuntu/" rel="alternate" type="text/html" title="tor, phantomJS를 Ubuntu에 설치" /><published>2017-12-12T00:00:00+09:00</published><updated>2017-12-12T00:00:00+09:00</updated><id>https://lahuman.github.io/tor_phantomjs_install_on_ubuntu</id><content type="html" xml:base="https://lahuman.github.io/tor_phantomjs_install_on_ubuntu/">&lt;h1 id=&quot;tor-phantomjs를-ubuntu에-설치&quot;&gt;tor, phantomJS를 Ubuntu에 설치&lt;/h1&gt;

&lt;h2 id=&quot;tor-설치--서비스-기동&quot;&gt;tor 설치 &amp;amp; 서비스 기동&lt;/h2&gt;

&lt;p&gt;tor 설치는 간단하게 apt-get을 이용하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# tor 설치
sudo apt-get install tor
# tor service 기동
sudo service tor start
# 기동 확인 9050 포트가 LISTEN되는지 확인
netstat -anop | grep 9050
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;phantomjs-설치&quot;&gt;phantomJS 설치&lt;/h2&gt;
&lt;p&gt;phantomJS는 pip로 설치가 되지 않는다.&lt;/p&gt;

&lt;p&gt;우선 시스템에서 필요한 프로그램을 다음과 같이 설치 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 먼저 시스템을 최신 상태로 업데이트 한다.
sudo apt-get update
sudo apt-get install build-essential chrpath libssl-dev libxft-dev

# PhantomJS 관련 필수 프로그램 설치
sudo apt-get install libfreetype6 libfreetype6-dev
sudo apt-get install libfontconfig1 libfontconfig1-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후, PhantomJS를 설치 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 특정 버젼 다운로드 &amp;amp; 압축 해제
cd ~
export PHANTOM_JS=&quot;phantomjs-2.1.1-linux-x86_64&quot;
wget https://bitbucket.org/ariya/phantomjs/downloads/$PHANTOM_JS.tar.bz2
sudo tar xvjf $PHANTOM_JS.tar.bz2

# /usr/local/share 이하로 옮기고 실행 가능하도록 symlink 설정
sudo mv $PHANTOM_JS /usr/local/share
sudo ln -sf /usr/local/share/$PHANTOM_JS/bin/phantomjs /usr/local/bin

# 확인
phantomjs --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/julionc/7476620&quot;&gt;How to install PhantomJS on Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="tor" /><category term="phantomJS" /><summary type="html">apt-get 과 함께면 참 쉽다!</summary></entry><entry><title type="html">Selenium 과 PhantomJS를 사용하는 환경에서 Close는 중요 하다.</title><link href="https://lahuman.github.io/20171208-phase/" rel="alternate" type="text/html" title="Selenium 과 PhantomJS를 사용하는 환경에서 Close는 중요 하다." /><published>2017-12-08T00:00:00+09:00</published><updated>2017-12-08T00:00:00+09:00</updated><id>https://lahuman.github.io/20171208-phase</id><content type="html" xml:base="https://lahuman.github.io/20171208-phase/">&lt;h1 id=&quot;selenium-과-phantomjs를-사용하는-환경에서-webdriverclose는-중요-하다&quot;&gt;Selenium 과 PhantomJS를 사용하는 환경에서 webdriver.close()는 중요 하다.&lt;/h1&gt;

&lt;p&gt;오류가 발생하면서 종료 되었을때도 PhantomJS 프로세스는 종료 되지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 꼭 finally 처리로 닫아 줘야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;driver = webdriver.PhantomJS()
try:
  driver.get(URL)
  # doing something
finally:
  driver.close()
  try:
    # 오류가 발생해도 넘어가기
    driver.quit()
  except Exception:
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;시작했다고-늘-함께-하진-않는구나&quot;&gt;시작했다고 늘 함께 하진 않는구나…&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">Python에서 만난 OOM</summary></entry><entry><title type="html">Python 에서 DB Pool 사용하기</title><link href="https://lahuman.github.io/python_use_db_pool/" rel="alternate" type="text/html" title="Python 에서 DB Pool 사용하기" /><published>2017-12-07T00:00:00+09:00</published><updated>2017-12-07T00:00:00+09:00</updated><id>https://lahuman.github.io/python_use_db_pool</id><content type="html" xml:base="https://lahuman.github.io/python_use_db_pool/">&lt;h1 id=&quot;python-에서-db-pool-사용하기&quot;&gt;Python 에서 DB Pool 사용하기&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터베이스와 애플리케이션을 효율적으로 연결하는 커넥션 플 라이브러리는 애플리케이션에서 필수 요소 입니다.
일반적인 프로그램에서 데이터베이스에 연결(Connection 객체를 얻는 작업)은 많은 시간이 소요 됩니다.
따라서 Connection을 미리 생성시켜 저장소에 저장 했다가 프로그램에서 요청이 있으면 저장소에서 꺼내 제공하면 시간과 리소스를 절약 할 수 있습니다. 이러한 기법을 Connection Pool이라 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Python 에서 사용할수 있는 MariaDB Connection Pool은 몇가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Oracle Mysql Pool(mysql 5.5 이상 설치시 사용 가능)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/LuciferJack/python-mysql-pool&quot;&gt;python-mysql-pool&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이중 Oracle 에서 제공되는 Pool을 테스트 진행시 Pool 개수 이상을 요구 시, 대기 없이 다음과 같은 오류가 발생한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql.connector.errors.PoolError: Failed getting connection; pool exhausted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;때문에 SQLAlchemy는 Python에 대한 SQL 툴킷과 객체 관계 매퍼를 사용하여 구현 하였다.&lt;/p&gt;

&lt;p&gt;우선 JAVA 7의 try-with-resources과 같은 기능이 Python의 &lt;strong&gt;with&lt;/strong&gt; 로 있다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;strong&gt;with&lt;/strong&gt; 를 이용해서 처리 할수 있는 DB에 대한 connection을 얻고 닫는 것을 다음처럼 자동화 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# _Session
with _Session(config['MARIADB']['MARIADB_CONNECT_INFO']) as s:
    onion_count = s.query(OnionsInfo).count()
return onion_count

#Connection
with Connector(config['MARIADB']['MARIADB_CONNECT_INFO']) as con:
    onion_count = con.execute(&quot;select count(*) from onions_info&quot;).fetchall()[0]
return onion_count
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;session 의 경우 SQLAlchemy와 곂치기 때문에 _를 이용함&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;with 절을 이용해 with 절이 시작 할때 &lt;strong&gt;enter&lt;/strong&gt; 가 호출 되고, 종료 될때 &lt;strong&gt;exit&lt;/strong&gt; 가 호출 되어 connection을 시작 하고 종료 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class _Session(Singleton):
    session = None

    def __init__(self, connect_info=None):
        global engine
        if engine is None:
            engine = sqlalchemy.create_engine(
                connect_info, pool_size=5,
                max_overflow=5, pool_recycle=500)
            Session.configure(bind=engine)

    def __enter__(self):
        self.session = Session()
        print &quot;enter = &quot; + str(self.session)
        return self.session

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            self.session.rollback()
            print &quot;rollback()&quot; + str(self.session)
        else:
            self.session.commit()

        print &quot;close() : &quot; + str(self.session)
        self.session.close_all()


class Connector(Singleton):
    con = None

    def __init__(self, connect_info=None):
        global engine
        if engine is None:
            engine = sqlalchemy.create_engine(
                connect_info, pool_size=5,
                max_overflow=5, pool_recycle=500)

    def __enter__(self):
        self.conn = engine.connect()
        return self.conn

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.conn.close();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.haruair.com/blog/1682&quot;&gt;SQLAlchemy 시작하기 – Part 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://preshing.com/20110920/the-python-with-statement-by-example/&quot;&gt;The Python “with” Statement by Example&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="SQLAlchemy" /><category term="db pool" /><summary type="html">SQLAlchemy의 DB Pool 이용</summary></entry><entry><title type="html">Python을 이용하여 원격 서버에 로그 전송</title><link href="https://lahuman.github.io/syslog_write_python/" rel="alternate" type="text/html" title="Python을 이용하여 원격 서버에 로그 전송  " /><published>2017-12-02T00:00:00+09:00</published><updated>2017-12-02T00:00:00+09:00</updated><id>https://lahuman.github.io/syslog_write_python</id><content type="html" xml:base="https://lahuman.github.io/syslog_write_python/">&lt;h1 id=&quot;원격지-로그-전송&quot;&gt;원격지 로그 전송&lt;/h1&gt;

&lt;p&gt;Python으로 특정 원격지 서버에 로그 전송이 가능하다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 rsyslog에서 해당 통신이 가능하도록 설정을 변경 해야 한다.
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim /etc/rsyslog.conf

# UDP 514 포트로 통신 가능하도록 다음 2 LINE 주석 제거
$ModLoad imudp
$UDPServerRun 514

# 로그타입과 저장 위치 설정
local3.*        /var/log/my-logfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 rsyslog에 대한 서비스를 재기동 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service rsyslog restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 Python 소스는 다음과 같다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
import logging
import logging.handlers

logger = logging.getLogger('myLogger')
logger.setLevel(logging.INFO)

#add handler to the logger
handler = logging.handlers.SysLogHandler(address = ('SERVER_IP',514), facility=logging.handlers.SysLogHandler.LOG_LOCAL3)

#add formatter to the handler
formatter = logging.Formatter('Python: { &quot;loggerName&quot;:&quot;%(name)s&quot;, &quot;asciTime&quot;:&quot;%(asctime)s&quot;, &quot;pathName&quot;:&quot;%(pathname)s&quot;, &quot;logRecordCreationTime&quot;:&quot;%(created)f&quot;, &quot;functionName&quot;:&quot;%(funcName)s&quot;, &quot;levelNo&quot;:&quot;%(levelno)s&quot;, &quot;lineNo&quot;:&quot;%(lineno)d&quot;, &quot;time&quot;:&quot;%(msecs)d&quot;, &quot;levelName&quot;:&quot;%(levelname)s&quot;, &quot;message&quot;:&quot;%(message)s&quot;}')

handler.formatter = formatter
logger.addHandler(handler)

logger.info(&quot;Test Message&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 소스를 실행하면 /var/log/my-logfile 파일에 로그가 쌓이는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3968669/how-to-configure-logging-to-syslog-in-python&quot;&gt;How to configure logging to syslog in Python?&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="python" /><category term="log" /><summary type="html">원격 서버로 로그 전송</summary></entry><entry><title type="html">Elasticdump 를 이용한 데이터 백업과 리스토어</title><link href="https://lahuman.github.io/elastic_dump/" rel="alternate" type="text/html" title="Elasticdump 를 이용한 데이터 백업과 리스토어 " /><published>2017-12-01T00:00:00+09:00</published><updated>2017-12-01T00:00:00+09:00</updated><id>https://lahuman.github.io/elastic_dump</id><content type="html" xml:base="https://lahuman.github.io/elastic_dump/">&lt;h1 id=&quot;elasticdump를-이용한-데이터-백업과-리스토어&quot;&gt;Elasticdump를 이용한 데이터 백업과 리스토어&lt;/h1&gt;

&lt;p&gt;elasticsearch의 데이터를 다른 곳으로 이관 하는 작업을 해야 한다.
&lt;br /&gt;
이때 사용 가능한 프로그램이 &lt;a href=&quot;https://github.com/taskrabbit/elasticsearch-dump&quot;&gt;elasticdump&lt;/a&gt; 이다.
&lt;br /&gt;
elasticdump는 현재 3.3.1 버젼으로 Elasticsearch 5.x 버젼을 지원하고 있다.
&lt;br /&gt;
지금 사용하는 elasticsearch 버젼이 2.x여서 해당 버젼을 지원하는 elsticdump 2.4.2를 설치 해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;설치&quot;&gt;설치&lt;/h2&gt;

&lt;p&gt;설치는 가이드에 나온 것과 같이 npm 을 설치 하고 elasticdump 모듈을 설치 해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# npm은 설치 되어 있다고 가정 한다.
npm install elasticdump

# git 에서 코드 download
git clone https://github.com/taskrabbit/elasticsearch-dump.git
cd elasticsearch-dump
# v2.4.2 으로 변경
git checkout tags/v2.4.2
# 버전 확인
./bin/elasticdump --version
2.4.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-백업&quot;&gt;데이터 백업&lt;/h2&gt;

&lt;p&gt;백업되는 데이터 타입은 크게 3가지로 나누어 진다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;analyzer&lt;/li&gt;
  &lt;li&gt;mapping&lt;/li&gt;
  &lt;li&gt;data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기본적으로 데이터를 넣기 위해서는 최소한의 데이터 맵핑이 있어야 한다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;elasticdump 는 Elasticsearch to Ealsticsearch 를 지원하며, File 로 저장 리스토어도 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Copy an index from production to staging with analyzer and mapping:
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=http://staging.es.com:9200/my_index \
  --type=analyzer
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=http://staging.es.com:9200/my_index \
  --type=mapping
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=http://staging.es.com:9200/my_index \
  --type=data

# Backup index data to a file:
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=/data/my_index_mapping.json \
  --type=mapping
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=/data/my_index.json \
  --type=data

# Backup and index to a gzip using stdout:
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=$ \
  | gzip &amp;gt; /data/my_index.json.gz

# Backup the results of a query to a file
elasticdump \
  --input=http://production.es.com:9200/my_index \
  --output=query.json \
  --searchBody '{&quot;query&quot;:{&quot;term&quot;:{&quot;username&quot;: &quot;admin&quot;}}}'

# Copy a single shard data:
elasticdump \
  --input=http://es.com:9200/api \
  --output=http://es.com:9200/api2 \
  --params='{&quot;preference&quot; : &quot;_shards:0&quot;}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;searchBody를 이용하면 원하는 목록 가져올 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;20171207-테스트-결과-추가&quot;&gt;2017.12.07 테스트 결과 추가&lt;/h2&gt;

&lt;h2 id=&quot;원본데이터를-파일로-저장&quot;&gt;원본데이터를 파일로 저장&lt;/h2&gt;

&lt;h3 id=&quot;1-원본-데이터-매핑-저장&quot;&gt;1. 원본 데이터 매핑 저장&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=http://10.10.10.202:9200 \
--input-index=elastic_data/elastic_data \
--output=elastic_data_mapping.json \
--type=mapping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-원본-데이터-백업&quot;&gt;2. 원본 데이터 백업&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;sample로 searchBody를 이용하여 1분 동안의 데이터만 가져오도록 함&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=http://10.10.10.202:9200 \
--input-index=elastic_data/elastic_data \
--output=elastic_data.json \
--type=data \
--searchBody '{
  &quot;query&quot;:{
      &quot;range&quot;:{
      &quot;log_dttm&quot;:{
          &quot;gte&quot;:&quot;2017-11-01T00:00:00&quot;,
            &quot;lte&quot;:&quot;2017-11-01T00:00:59&quot;
        }
        }
    }
}'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;파일로-저장된-데이터를-서버에-저장&quot;&gt;파일로 저장된 데이터를 서버에 저장&lt;/h2&gt;

&lt;h3 id=&quot;1-인덱스-추가--데이터-형식-저장&quot;&gt;1. 인덱스 추가 &amp;amp; 데이터 형식 저장&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=elastic_data_mapping.json \
--output=http://10.10.10.180:9201/elastic_data \
--type=mapping
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-데이터-import-처리&quot;&gt;2. 데이터 import 처리&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이미 등록된 데이터를 다시 등록 할 경우 _version 의 값이 +1 처리 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./elasticdump \
--input=elastic_data.json \
--output=http://10.10.10.180:9201/elastic_data \
--type=data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/taskrabbit/elasticsearch-dump&quot;&gt;elasticdump&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="elasticsearch" /><category term="elasticdump" /><summary type="html">Elasticsearch 백업 &amp; 리스토어</summary></entry></feed>
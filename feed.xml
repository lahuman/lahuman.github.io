<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2020-02-21T21:26:24+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">보안프로그램을 피해서 WSL 설치하기!</title><link href="https://lahuman.github.io/wsl_install_using_command/" rel="alternate" type="text/html" title="보안프로그램을 피해서 WSL 설치하기!" /><published>2020-02-21T00:00:00+09:00</published><updated>2020-02-21T00:00:00+09:00</updated><id>https://lahuman.github.io/wsl_install_using_command</id><content type="html" xml:base="https://lahuman.github.io/wsl_install_using_command/">&lt;h1 id=&quot;windows에서-개발을-편하게-하기-위한-wsl-설치-가이드&quot;&gt;Windows에서 개발을 편하게 하기 위한 WSL 설치 가이드&lt;/h1&gt;

&lt;p&gt;기본 설치 방법은 보안프로그램에 의해서 진행이 안될 수 있습니다.
하지만 PowerShell을 이용한 설치는 보안프로그램에 대하여 우회가 가능합니다.&lt;/p&gt;

&lt;p&gt;뭔가 엄청 특별한 방법이 있는것은 아니고, &lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/wsl/install-manual&quot;&gt;수동 설치 지침&lt;/a&gt;을 참조 하여 설치 하면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;strong&gt;Linux용 Windows하위 시스템 기능&lt;/strong&gt;을 사용하도록 설정해야 합니다.&lt;/p&gt;

&lt;p&gt;관리자 권한으로 PowerShell을 열어 다음 명령어를 실행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치를 하고 나면 재부팅을 해줘야 한다.&lt;/p&gt;

&lt;p&gt;재부팅이후, 설치를 원하는 Linux 배포판을 명령줄을 이용해서 다운로드 받습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;아래 명령어는 Ubuntu 18.04 버전으로 진행한 명령어 입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.appx -UseBasicParsing
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 끝나면 다음 명령어로 설치 할수 있다고 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Add-AppxPackage .\Ubuntu.appx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;하지만-설치-이후-실행을-하면-file-system-error-12030가-발생합니다&quot;&gt;하지만!!! 설치 이후 실행을 하면 “File system Error (12030)”가 발생합니다.&lt;/h1&gt;

&lt;p&gt;이럴 경우 우선 기존에 설치된 배포판 버젼을 삭제 하세요.&lt;/p&gt;

&lt;p&gt;그리고 다운로드 받았던 앱 파일 &lt;strong&gt;Ubuntu.appx&lt;/strong&gt;의 파일 확장자를 .zip로 변경하세요.&lt;/p&gt;

&lt;p&gt;압축을 풀고 해당 디렉토리에서 &lt;strong&gt;ubuntu1804.exe&lt;/strong&gt; 파일을 실행하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/wsl/install-win10&quot;&gt;Windows 10에 Linux용 Windows 하위 시스템 설치 가이드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="wsl" /><category term="certificate" /><summary type="html">Windows 10에서 제공하는 WSL</summary></entry><entry><title type="html">프로그램에서 통신시 ssl certificate_verify_failed 오류 발생</title><link href="https://lahuman.github.io/ssl_certificate_verify_failed/" rel="alternate" type="text/html" title="프로그램에서 통신시 ssl certificate_verify_failed 오류 발생" /><published>2020-02-20T00:00:00+09:00</published><updated>2020-02-20T00:00:00+09:00</updated><id>https://lahuman.github.io/ssl_certificate_verify_failed</id><content type="html" xml:base="https://lahuman.github.io/ssl_certificate_verify_failed/">&lt;h1 id=&quot;특정-도메인의-api를-사용시-발생하는-ssl-certificate_verify_failed-오류&quot;&gt;특정 도메인의 API를 사용시 발생하는 ssl certificate_verify_failed 오류&lt;/h1&gt;

&lt;p&gt;https 통신시 발생을 합니다.&lt;/p&gt;

&lt;p&gt;도메인이나 다른 문제가 없어 보이는테 이상하게 httpclient, axios로 통신을 시도하면 발생하는 문제입니다.&lt;/p&gt;

&lt;p&gt;언어별로 해별방법이 비슷합니다.&lt;/p&gt;

&lt;h2 id=&quot;python에서-해결-방법&quot;&gt;python에서 해결 방법&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import urllib.request
import ssl

def callApi(requst):
	context = ssl._create_unverified_context() 
    r = urllib.request.urlopen('https://lahuman.github.com', context = context)    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;java에서-해결-방법&quot;&gt;java에서 해결 방법&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;httpclient 4.4 이상을 사용하면 다음과 같이 쉽게 해결이 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void contextLoads() throws IOException {
		CloseableHttpClient httpClient = HttpClients.custom().setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE).build();
		HttpPost httpPost = new HttpPost(&quot;https://lahuman.github.com&quot;);
    httpPost.addHeader(&quot;API-KEY&quot;,&quot;adsfasdfasdfasdfasdfasdf&quot; );
		httpPost.addHeader(&quot;Content-Type&quot;,&quot;application/json&quot; );
		httpPost.setEntity(new ByteArrayEntity(String.format(&quot;{\&quot;ABC\&quot;:123}&quot;).getBytes()));

		try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
			System.out.println(response.getStatusLine());
			HttpEntity entity = response.getEntity();
			String text = null;
			try (Scanner scanner = new Scanner(entity.getContent(), StandardCharsets.UTF_8.name())) {
				text = scanner.useDelimiter(&quot;\\A&quot;).next();
			}
			System.out.println(text);
			EntityUtils.consume(entity);

		} catch (IOException e) {
			e.printStackTrace();
		}

	}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;nodejs에서-해결-방법&quot;&gt;nodejs에서 해결 방법&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const https = require('https');
const axios = require('axios');

const instance = axios.create({
  baseURL: 'https://lahuman.github.com',
  timeout: 120000,
  httpsAgent: new https.Agent({
    rejectUnauthorized: false
  })
});

const response = await instance.post('/api', { abc:123 });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;결국 https의 Verifier를 사용하지 않는 옵션을 추가 한다.&lt;/p&gt;</content><category term="ssl" /><category term="certificate" /><summary type="html">특정 도메인에서 종종 발생하는 문제입니다.</summary></entry><entry><title type="html">AWS LAMBDA 사용 중 발생한 이상현상</title><link href="https://lahuman.github.io/aws_lambda_tip/" rel="alternate" type="text/html" title="AWS LAMBDA 사용 중 발생한 이상현상" /><published>2020-02-19T00:00:00+09:00</published><updated>2020-02-19T00:00:00+09:00</updated><id>https://lahuman.github.io/aws_lambda_tip</id><content type="html" xml:base="https://lahuman.github.io/aws_lambda_tip/">&lt;h1 id=&quot;gitlab에서-jenkins의-webhook을-직접-호출할-수-없는-경우가-생겼다&quot;&gt;Gitlab에서 jenkins의 webhook을 직접 호출할 수 없는 경우가 생겼다.&lt;/h1&gt;

&lt;p&gt;기본적으로 호출되는 구조는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/git2lambda2jenkins_call.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 호출 하는 이유는 Lambda를 통해서 내부 API Gateway를 호출하고 해당 API Gateway를 통해 Jenkins를 호출하기 때문이다.&lt;/p&gt;

&lt;p&gt;기본적으로 gitlab과 직접 통신이 안되는 경우이다.&lt;/p&gt;

&lt;p&gt;구현은 쉽게 하였고, AWS의 API GATEWAY를 이용해서 trigger를 생성하였다.&lt;/p&gt;

&lt;p&gt;여기서 POST call만을 작성하였는데, lambda의 event에 아무것도 리턴이 되지 않았다.&lt;/p&gt;

&lt;p&gt;몇번을 테스트해보다 Any로 설정하고 테스트 하니 parameter/header/body 등이 잘 넘어갔다.&lt;/p&gt;

&lt;p&gt;마지막으로 팀원이 보여달라고 해서 안되는걸 보여주기 위해서 똑같이 구축 하였는데…. 잘되었다!!!???&lt;/p&gt;

&lt;p&gt;시간은 시간대로 버리고, 이상한 사람이 된 하루였다.&lt;/p&gt;

&lt;h1 id=&quot;아오빡쵸&quot;&gt;아오빡쵸&lt;/h1&gt;</content><category term="lambda" /><category term="aws" /><summary type="html">Lambda를 사용하는데 안되던게 되기도 하네요.</summary></entry><entry><title type="html">굿바이 블랙독</title><link href="https://lahuman.github.io/20200209/" rel="alternate" type="text/html" title="굿바이 블랙독" /><published>2020-02-09T00:00:00+09:00</published><updated>2020-02-09T00:00:00+09:00</updated><id>https://lahuman.github.io/20200209</id><content type="html" xml:base="https://lahuman.github.io/20200209/">&lt;h1 id=&quot;책에서는-우울증을-블랙독이라는-이름으로-부른다&quot;&gt;책에서는 우울증을 블랙독이라는 이름으로 부른다.&lt;/h1&gt;

&lt;p&gt;블랙독은 누구나 가지고 있으며 혼자서는 이겨낼수 없는 존재이다.&lt;/p&gt;

&lt;p&gt;작가도 블랙독에게 무릅을 꿇고 나서야 전문가를 찾아 가게 되었다.&lt;/p&gt;

&lt;p&gt;전문가가 추천하는 것은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;운동하기&lt;/li&gt;
  &lt;li&gt;기분 기록표 작성하기&lt;/li&gt;
  &lt;li&gt;나 자신을 믿고 사랑하기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;블랙독은 누구나 가지고 있다. 어떻게 괸리할지가 중요하다.&lt;/p&gt;

&lt;p&gt;블랙독을 우을증으로 바꿔서 읽으면 좋다.&lt;/p&gt;</content><category term="단상" /><summary type="html">내안의 우울과 이별하기를 읽고</summary></entry><entry><title type="html">자택 근무는 처음이야…</title><link href="https://lahuman.github.io/20200206/" rel="alternate" type="text/html" title="자택 근무는 처음이야..." /><published>2020-02-06T00:00:00+09:00</published><updated>2020-02-06T00:00:00+09:00</updated><id>https://lahuman.github.io/20200206</id><content type="html" xml:base="https://lahuman.github.io/20200206/">&lt;h1 id=&quot;자택-근무를-한다&quot;&gt;자택 근무를 한다.&lt;/h1&gt;

&lt;p&gt;생애 첫 자택 근무이다.&lt;/p&gt;

&lt;p&gt;하지만, 아이들과 함께하니 너무 힘들다.&lt;/p&gt;

&lt;p&gt;아이들은 내가 논다고 생각한다.&lt;/p&gt;

&lt;p&gt;집밖은 위험해서 나갈 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게든-넘겨보자&quot;&gt;어떻게든 넘겨보자!&lt;/h2&gt;</content><category term="단상" /><summary type="html">어머! 자택 근무라니?</summary></entry><entry><title type="html">부족한 내 능력에 화가 많이 나는 하루이다.</title><link href="https://lahuman.github.io/20200204/" rel="alternate" type="text/html" title="부족한 내 능력에 화가 많이 나는 하루이다." /><published>2020-02-04T00:00:00+09:00</published><updated>2020-02-04T00:00:00+09:00</updated><id>https://lahuman.github.io/20200204</id><content type="html" xml:base="https://lahuman.github.io/20200204/">&lt;h1 id=&quot;풀-스택이라-쓰고-잡부라-부른다&quot;&gt;풀 스택이라 쓰고 잡부라 부른다.&lt;/h1&gt;

&lt;p&gt;나는 풀 스택 개발자이다.&lt;/p&gt;

&lt;p&gt;뭐 좋게 들을 때는 모든지 다 하는 것이고, 나쁘게 이야기해서는 제대로 하는 것이 없는 것이다.&lt;/p&gt;

&lt;p&gt;오늘 프로젝트 리더와 의견 충돌이 있었다.&lt;/p&gt;

&lt;p&gt;프로젝트 리더의 의견은 알고 있으니, 사실 내 능력이 안 되는 업무라서 좀 답답했었다.&lt;/p&gt;

&lt;p&gt;내가 가진 프런트 개발 능력은 뛰어나지 않다.&lt;/p&gt;

&lt;p&gt;적당한 UI를 만드는 건 할 수 있지만 프로젝트 리더가 원하는 고급진 UI를 만드는 능력이 부족했다.&lt;/p&gt;

&lt;p&gt;오늘 문제가 되었던 것은 애플 산돌 고딕체를 디자이너가 제시한 크기로 css를 작성하였는데, 다르게 표출되었다.&lt;/p&gt;

&lt;p&gt;실제 퍼블리셔에게 문의하여보니, 애플 산돌 고딕체는 앱과 웹에서 다르게 보인다는 답변을 받았다.&lt;/p&gt;

&lt;p&gt;결국 내가 찾지 못한 버그로 거의 하루를 날리고 나니 정신이 털려서 다 귀찮아졌다.&lt;/p&gt;

&lt;p&gt;결국 프로젝트 리더에게 내 능력이 부족해서 못하겠다고 하고 말았다.&lt;/p&gt;

&lt;p&gt;내일은 더 잘 할 방법을 고민하는 하루를 보내야겠다.&lt;/p&gt;

&lt;h1 id=&quot;우울한-하루의-끝&quot;&gt;우울한 하루의 끝&lt;/h1&gt;</content><category term="단상" /><summary type="html">시간 부족으로 늘 대충 마무리 하고 있다.</summary></entry><entry><title type="html">두려움 없는 조직을 읽고</title><link href="https://lahuman.github.io/20200129/" rel="alternate" type="text/html" title="두려움 없는 조직을 읽고" /><published>2020-01-29T00:00:00+09:00</published><updated>2020-01-29T00:00:00+09:00</updated><id>https://lahuman.github.io/20200129</id><content type="html" xml:base="https://lahuman.github.io/20200129/">&lt;h1 id=&quot;에이미-에드먼슨의-두려움-없는-조직을-읽고&quot;&gt;에이미 에드먼슨의 두려움 없는 조직을 읽고…&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;“두려움 없는 조직”&lt;/strong&gt;이라는 책을 2번째 읽고 있다.
나는 침묵하기보다는 문제 제기를 많이 하는 편이다.&lt;/p&gt;

&lt;p&gt;이런 성격 때문에 평소에 오지랖도 넓고, 많은 일을 하는 편이다.&lt;/p&gt;

&lt;p&gt;하지만 내뱉은 말들이 나를 아프게 하는 경우도 종종 있고, 누군가에게 미움을 받은 적도 있다.&lt;/p&gt;

&lt;p&gt;대부분 문제 제기로 인해 상사에게 모난 돌이 되어서 정을 맞기도 하고, 문제의 해결을 위해서 더 많은 일을 해야 할 때도 많았다.&lt;/p&gt;

&lt;p&gt;왜냐면 문제 제기를 함으로써 가장 많이 듣는 소리는 
&lt;strong&gt;“말만 하지 말고 해 보고 이야기해봐요.”&lt;/strong&gt;라는 말이다.&lt;/p&gt;

&lt;p&gt;문제 해결을 위해 여러 시도를 해보고 잘 되었을 때는 큰 이득이 없지만, 
못할 때에는 &lt;strong&gt;“말은 누구나 다 할 수 있어요.”&lt;/strong&gt;라는 핀잔을 듣고는 한다.&lt;/p&gt;

&lt;p&gt;어려운 문제를 해결해가는 과정에서 &lt;strong&gt;“내가 왜 이 말을 해서 이 짓을 하고 있을까?”&lt;/strong&gt; 후회도 하고, 
때로는 너무 재미있어서 아무 생각 없이 열심히 하기도 하였다.&lt;/p&gt;

&lt;p&gt;전자의 경우는 &lt;strong&gt;까칠한(?) 동료&lt;/strong&gt;와 일하는 경우였고, 후자의 경우는 &lt;strong&gt;심리적 안정감을 주는 동료&lt;/strong&gt;와 일할 경우이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다행히 지금 동료들과는 침묵하기보다 의견을 나누고, 문제가 있다고 생각되면 함께 해결책을 찾기 위해 많은 노력을 아끼지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;내일도-즐겁게-시작해보자&quot;&gt;내일도 즐겁게 시작해보자!&lt;/h1&gt;</content><category term="단상" /><summary type="html">조직 내에서 두려움 없이 자신의 생각을 이야기 하는게 쉽지만은 않다.</summary></entry><entry><title type="html">windows에 wsl 설치하고 설정하기</title><link href="https://lahuman.github.io/windows-wsl-setting/" rel="alternate" type="text/html" title="windows에 wsl 설치하고 설정하기" /><published>2020-01-26T00:00:00+09:00</published><updated>2020-01-26T00:00:00+09:00</updated><id>https://lahuman.github.io/windows-wsl-setting</id><content type="html" xml:base="https://lahuman.github.io/windows-wsl-setting/">&lt;h1 id=&quot;windows에-wsl-설치하고-설정하기&quot;&gt;windows에 wsl 설치하고 설정하기&lt;/h1&gt;

&lt;p&gt;일반적으로 windows OS에서 linux 환경을 사용하기 위해서는 vmware를 이용해 OS를 설치하고 활용했다.
장단점이 있지만, 기본적으로 OS 설치 비용 + 디스크, 메모리 등을 쉐어 하기 때문에 호스트 OS에도 부담이 되는 방식이다.&lt;/p&gt;

&lt;p&gt;2년전쯤 WSL을 설치하려고 시도하다가 업데이트가 잘 안되서 실패 했었다.&lt;/p&gt;

&lt;p&gt;요즘은 쉽게 설치가 된다고 하여 다시 재도전을 해보았다.&lt;/p&gt;

&lt;h2 id=&quot;제어판에서-linux용-windows-하위-시스템-사용-설정&quot;&gt;제어판에서 &lt;strong&gt;Linux용 Windows 하위 시스템&lt;/strong&gt; 사용 설정&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;제어판을 연다.&lt;/li&gt;
  &lt;li&gt;프로그램을 선택한다.&lt;/li&gt;
  &lt;li&gt;Windows 기능 켜기/끄기 선택&lt;/li&gt;
  &lt;li&gt;Linux용 Windows 하위 시스템 켜기&lt;/li&gt;
  &lt;li&gt;재부팅 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_setting.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ubuntu-1804-설치&quot;&gt;Ubuntu 18.04 설치&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Microsoft Store에서 Linux를 검색한다.&lt;/li&gt;
  &lt;li&gt;Ubuntu 18.04 LTS를 선택한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;처음에 Ubuntu를 설치했더니, &lt;strong&gt;yum update&lt;/strong&gt; 부터 오류가 발생했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_msstore_ubuntu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치가 끝나면 실행을 한다.&lt;/p&gt;

&lt;p&gt;실행을 하면 사용자 ID와 Password를 입력하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_ubuntu18.04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nvm-설치-하기&quot;&gt;nvm 설치 하기&lt;/h2&gt;

&lt;p&gt;현재(2020.01.26)기준 최신 버젼은 0.35.2이다. 다음 명령어를 이용해서 설치 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 13527  100 13527    0     0  13888      0 --:--:-- --:--:-- --:--:-- 13873
=&amp;gt; Downloading nvm from git to '/home/lahuman/.nvm'
=&amp;gt; Cloning into '/home/lahuman/.nvm'...
remote: Enumerating objects: 288, done.
remote: Counting objects: 100% (288/288), done.
remote: Compressing objects: 100% (258/258), done.
remote: Total 288 (delta 35), reused 95 (delta 18), pack-reused 0
Receiving objects: 100% (288/288), 146.70 KiB | 408.00 KiB/s, done.
Resolving deltas: 100% (35/35), done.
=&amp;gt; Compressing and cleaning up git repository

=&amp;gt; Appending nvm source string to /home/lahuman/.bashrc
=&amp;gt; Appending bash_completion source string to /home/lahuman/.bashrc
: not foundram Files/nodejs/npm: 3: /mnt/c/Program Files/nodejs/npm:
: not foundram Files/nodejs/npm: 5: /mnt/c/Program Files/nodejs/npm:
/mnt/c/Program Files/nodejs/npm: 6: /mnt/c/Program Files/nodejs/npm: Syntax error: word unexpected (expecting &quot;in&quot;)
=&amp;gt; Close and reopen your terminal to start using nvm or run the following to use it now:

export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm
[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 끝나면 마지막 3줄을 복사해서 붙이면 설치는 마무리 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export NVM_DIR=&quot;$HOME/.nvm&quot;
$ [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/nvm.sh&quot; 
$ [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;amp;&amp;amp; \. &quot;$NVM_DIR/bash_completion&quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;nvm list&lt;/strong&gt;명령어를 이용해서 현재 설치된 것을 확인하면, 다음과 같이 아무것도 설치 되어 있지 않다는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nvm list
            N/A
iojs -&amp;gt; N/A (default)
node -&amp;gt; stable (-&amp;gt; N/A) (default)
unstable -&amp;gt; N/A (default)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;nvm install node&lt;/strong&gt; 명령어를 이용해서 node를 설치 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nvm install node
Downloading and installing node v13.7.0...
Downloading https://nodejs.org/dist/v13.7.0/node-v13.7.0-linux-x64.tar.xz...
################################################################################################################# 100.0%
Computing checksum with sha256sum
Checksums matched!
Now using node v13.7.0 (npm v6.13.6)
Creating default alias: default -&amp;gt; node (-&amp;gt; v13.7.0)
$ node -v
v13.7.0
$ npm -v
6.13.6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치 버젼을 확인하여, 설치가 잘된 것을 확인한다.&lt;/p&gt;

&lt;h2 id=&quot;docker-설치-하기&quot;&gt;docker 설치 하기&lt;/h2&gt;

&lt;p&gt;기본적으로 WSL은 docker 데몬을 지원 하지 않는다.&lt;/p&gt;

&lt;p&gt;하지만! WSL2 라면 지원을 한다.&lt;/p&gt;

&lt;h3 id=&quot;wsl2설치&quot;&gt;WSL2설치&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;WSL2란, 최신의 가상화 기술을 사용하여 경량 유틸리티 VM(가상 머신) 내에서 Linux 커널을 실행합니다. 기존 VM과 다르게, WSL1과 동일한 사용자 환경을 유지 하면서 백그라운드에서 관리되고 실행됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선 Hyper-v를 사용하도록 설정 해야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BIOS 설정
&lt;img src=&quot;https://i2.wp.com/www.nextofwindows.com/wp-content/uploads/2015/05/6116.HVW8a.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Hyper-V 설정
&lt;img src=&quot;/assets/img/post_img/w_w_hyper-v.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;wsl2 설치&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;WSL 2는 Windows 10 빌드 18917 이상에서만 사용할 수 있음 
Windows 참가자 프로그램을 참가하여야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_update.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 업데이트(인터넷 속도에 따라 2시간 정도 걸림)를 모두 하면, 빌드 버젼이 2020.01.27기준 10.0.19041.21이다.
버전을 확인하는 방법은 cmd 명령창에서 &lt;strong&gt;ver&lt;/strong&gt; 명령어로 확인이 가능합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ver

Microsoft Windows [Version 10.0.19041.21]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 가상 컴퓨터 플랫폼을 사용하도록 powserShell에서 다음 명령어를 입력한다. 주의 할것은 powserShell을 관리자 권한으로 실행해야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
# dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 powserShell에서 wsl의 배포판 모드를 변경한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# wsl --set-version &amp;lt;Distro&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_wsl2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이제 docker를 사용할 준비가 완료 되었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;docker-설치&quot;&gt;docker 설치&lt;/h2&gt;

&lt;p&gt;docker container를 설치해보자, 설치는 다음의 명령어를 이용해서 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo apt-key fingerprint 0EBFCD88
$ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;
$ sudo apt-get update
$ sudo apt-get install docker-ce
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 완료 되었으면, docker service를 root 권한으로 실행하여야 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo service docker start
 * Starting Docker: docker                                                                                       [ OK ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본적으로 docker는 root 권한으로만 실행할 수 있다. docker 명령어를 이용할 때마다, sudo를 붙이는게 귀찮다면, 다음과 같이 사용자를 docker그룹에 추가하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo usermod -aG docker $(whoami)
# 터미널 종료후 다시 열어야 한다.
$ exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;샘플 docker 실행 테스트&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -d --name react-app -p 80:80 lahuman/test-react-app
Unable to find image 'lahuman/test-react-app:latest' locally
latest: Pulling from lahuman/test-react-app
e7c96db7181b: Pull complete
8985e402e050: Pull complete
41c1b09855ea: Pull complete
Digest: sha256:bb4d447b8a51845510671f731d68a4b944e681fe856bef670102bb97f904895d
Status: Downloaded newer image for lahuman/test-react-app:latest
5e0cd323d4c97682e4ecb3103555ff9c9ff9d10ffd2bc30fe9591a8b8157fad1

$ docker ps
CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                NAMES
5e0cd323d4c9        lahuman/test-react-app   &quot;nginx -g 'daemon of…&quot;   5 seconds ago       Up 3 seconds        0.0.0.0:80-&amp;gt;80/tcp   react-app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vscode-와-연동-하기&quot;&gt;VSCODE 와 연동 하기&lt;/h2&gt;

&lt;p&gt;vscode에서 Remote-WSL plugin을 설치 한다.&lt;/p&gt;

&lt;p&gt;이후 F1을 눌러 &lt;strong&gt;Remote-WSL: new Windows&lt;/strong&gt;를 입력 후 클릭한다.&lt;/p&gt;

&lt;p&gt;새창이 뜨고, 뜬 새창에서 터미널이나, 파일 exporler를 열면 wsl 안의 내용을 확인 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;ubuntu-삭제-하기&quot;&gt;ubuntu 삭제 하기&lt;/h2&gt;

&lt;p&gt;설치된 wsl의 OS를 삭제하기 위해서는 &lt;strong&gt;앱 및 기능&lt;/strong&gt;으로 이동해서 ms store에서 설치했던, Ubuntu를 찾아서 제거 하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/w_w_ubuntu_remove.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.windowscentral.com/install-windows-subsystem-linux-windows-10&quot;&gt;How to install Windows Subsystem for Linux (WSL) on Windows 10&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/wsl/wsl2-install?fbclid=IwAR29NZ7vEdgWpYbvtXn0PhTCrD2udghu9H3r-9mtc64tDRAna7QOELDvMPk&quot;&gt;WSL 2의 설치 지침&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://subhankarsarkar.com/wsl2-for-containerised-dot-net-core-development-using-docker/?fbclid=IwAR3QFlL-sgSbWDk4wYGgsaTJ5-st4VgxvNMuuaRYrGQ4EMneAznuMyjPBsk&quot;&gt;Build Containerised .NET Core Application using Docker on Windows Subsystem for Linux (WSL) 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/windows/nodejs/setup-on-wsl2?fbclid=IwAR0E6rXQNJRPIt5Ki4tD49bkNvTBCRn-Wk7BpkTd-jYdY-aoT240lfr5SbY&quot;&gt;WSL 2를 사용 하 여 node.js 개발 환경 설정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/virtualization/hyper-v-on-windows/quick-start/quick-create-virtual-machine?fbclid=IwAR0W7qMdgawtOTZzJ-qruiceGyfrB7aKN-hJj8cd00OQkozebeXL6dg5mSs&quot;&gt;Hyper-V를 사용하여 가상 컴퓨터 만들기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="windows" /><category term="wsl" /><category term="vscode" /><summary type="html">vscode의 remote WSL까지 연결하면 신세계가 열린다.</summary></entry><entry><title type="html">kubernetes Persistent Volumes 설정하여 사용하기</title><link href="https://lahuman.github.io/kubernetes-persistent-volumes/" rel="alternate" type="text/html" title="kubernetes Persistent Volumes 설정하여 사용하기" /><published>2020-01-23T00:00:00+09:00</published><updated>2020-01-23T00:00:00+09:00</updated><id>https://lahuman.github.io/kubernetes-persistent-volumes</id><content type="html" xml:base="https://lahuman.github.io/kubernetes-persistent-volumes/">&lt;h1 id=&quot;kubernetes-persistent-volumes-사용하기&quot;&gt;Kubernetes Persistent Volumes 사용하기&lt;/h1&gt;

&lt;h2 id=&quot;준비-작업&quot;&gt;준비 작업&lt;/h2&gt;

&lt;p&gt;가장 쉽게 돈 안들이고 구성하기 위해서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%ED%8C%8C%EC%9D%BC_%EC%8B%9C%EC%8A%A4%ED%85%9C&quot;&gt;Network file system(NFS)&lt;/a&gt;을 설치하여 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;centos에-nfs-설치--구성&quot;&gt;CentOS에 NFS 설치 &amp;amp; 구성&lt;/h3&gt;

&lt;p&gt;우선 설치는 다음과 같이 쉽게 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install nfs-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치가 끝났면, nfs 데몬을 시작하고 재부팅시 자동으로 실행 될수 있도록 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# nfs 서버 기동
$ systemctl start nfs-server
# 서버 재기동시 nfs 서버 기동
$ systemctl enable nfs-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 exports 할 디렉토리를 생성하고 exports에 해당 위치를 설정 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir /nfs
$ vi /etc/exports
/nfs *(rw,root-squash,sync)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;수정이 다 되었다면, 다음 명령으로 변경된 내역을 반영합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ exportfs -r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 해당 서비스를 다른 서버에서 사용하기 위해 방화벽을 허용해야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ firewall-cmd --permanent --add-service=nfs
$ firewall-cmd --reload
$ firewall-cmd --list-all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 NFS 공유가 잘되었는지 확인합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ showmount -e
Export list for server:
/nfs *

$ sudo exportfs -v
/nfs          	&amp;lt;world&amp;gt;(sync,wdelay,hide,no_subtree_check,sec=sys,rw,secure,root_squash,all_squash)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;추가-정보-etcexports-설정-정보&quot;&gt;추가 정보 /etc/exports 설정 정보&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;옵션&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ro&lt;/td&gt;
      &lt;td&gt;파일 시스템을 읽기전용으로 마운트&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rw&lt;/td&gt;
      &lt;td&gt;파일시스템을 읽기/쓰기 로 마운트&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;root_squash&lt;/td&gt;
      &lt;td&gt;클라이언트에서 루트를 서버상에 nobody 사용자로 매핑&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;no_root_squash&lt;/td&gt;
      &lt;td&gt;서버와 클라이언트 모두 같은 root를 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;secure&lt;/td&gt;
      &lt;td&gt;클라이언트 마운트 요청시 포트를 1024 이하로 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anonuid&lt;/td&gt;
      &lt;td&gt;익명 사용자를 위한 사용자 ID를 지정하실 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;anongid&lt;/td&gt;
      &lt;td&gt;익명 사용자를 위한 그룹 ID를 지정하실 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;insecure&lt;/td&gt;
      &lt;td&gt;인증되지 않은 액세스도 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;noaccess&lt;/td&gt;
      &lt;td&gt;액세스 거부&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;link_relative&lt;/td&gt;
      &lt;td&gt;서버에 있는 루트와의 링크를 포함하는 디렉토리에서 얻는 “../” 만큼 링크 앞에 두어 절대 심볼릭 링크를 상대 심볼릭 링크로 바꿀때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sync&lt;/td&gt;
      &lt;td&gt;파일 시스템이 변경되면 즉시 동기화합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;async&lt;/td&gt;
      &lt;td&gt;sync 옵션을 사용하지 않는 경우에 해당 하며, 서버는 데이터가 저장소에 안전히 저장됐는지를 확인하지 않음 클라이언트의 데이터 쓰기 요청이 들어오면 바로 응답을 보냄 데이터 curruption이 발생할 수 있지만 성능 향상을 기대할 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;no_subtree_check&lt;/td&gt;
      &lt;td&gt;파일 시스템의 전체 디렉토리가 아닌 하부 디렉토리가 내보내진 경우, 서버는 내보낸 하부 디렉토리에 요청된 파일이 존재하는지를 검사 함 이러한 검사 과정을 하부구조 검사라고 부르는데, 이 옵션을 선택하시면 하부구조 검사를 사용하지 않음 전체 파일 시스템이 내보내진 경우에 이 옵션을 선택하면 하부구조 검사를 하지 않음으로서 전송률을 높일 수 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;all_squash&lt;/td&gt;
      &lt;td&gt;root를 제외하고 서버와 클라이언트의 사용자를 동일한 권한으로 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;no_all_squash&lt;/td&gt;
      &lt;td&gt;root를 제외하고 서버와 클라이언트의 사용자들을 하나의 권한을 가지도록 설정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;nfs-exporting-설정-예&quot;&gt;NFS Exporting 설정 예&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
/home/redhat  디렉토리를 one.linux.co.kr과 two.linux.co.kr 
두 개의 클라이언트 컴퓨터들이 마운트할 수 있으며, 
one 클라이언트 컴퓨터는 오직 읽기로만 마운트되고, 
two 클라이언트 컴퓨터에는 읽기/쓰기로 마운트 된다.
*/

/home/redhat   one.linux.co.kr  (ro)  two.linux.co.kr  (rw)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# linux.co.kr 도메인 내에 있는 모든 컴퓨터들이 /usr/local/bin 파일 시스템을 읽기 전용으로 마운트된다.
/usr/local/bin    *.linux.co.kr    (ro)
# /pub 디렉토리에 대해서 읽기로만 마운트할 수 있고, 사용자 인증이 없이 액세스가 가능하며, 이 데렉토리 파일 시스템에 액세스 하는 모든 컴퓨터의 루트를 서버에서 nobody 사용자로 액세스할 수 있게 한다는 의미이다.
/pub                                        (ro, insecure,root_square)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;클라이언트-설치-테스트&quot;&gt;클라이언트 설치 테스트&lt;/h3&gt;

&lt;p&gt;우선 nfs 패키지를 설치 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install nfs-utils
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;export 위치를 확인한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 192.168.0.1 서버 IP
$ showmount -e 192.168.0.1
Export list for server:
/nfs *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NFS 디렉토리와 마운트 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;마운트할 디렉토리 생성
$ mkdir /test/nfs
# 마운트
$ mount -t nfs -o sync 192.168.0.1:/nfs /test/nfs
# 확인
$ df -h | grep nfs
192.168.0.1:/nfs  228G  9.8G  218G   5% /test/nfs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 리부팅시 자동으로 마운트 하기를 원한다면 다음과 같이 설정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim /etc/fstab
192.168.0.1:/nfs     /test/nfs       nfs     sync    0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mount를 끊기를 원한다면 다음과 같이 하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ umount -f -l /test/nfs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;오류-발생-linux-clnt_create-rpc-program-not-registered-를-확인하면&quot;&gt;오류 발생 &lt;a href=&quot;https://unix.stackexchange.com/questions/82290/linux-clnt-create-rpc-program-not-registered&quot;&gt;Linux: clnt_create: RPC: Program not registered&lt;/a&gt; 를 확인하면,&lt;/h3&gt;

&lt;p&gt;nfs service가 제대로 기동 되지 않은 것이다. 다시 시작하자!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ service nfs status
rpc.svcgssd is stopped
rpc.mountd is stopped
nfsd is stopped
rpc.rquotad is stopped

$ service nfs start
Starting NFS services:                                     [  OK  ]
Starting NFS quotas:                                       [  OK  ]
Starting NFS daemon:                                       [  OK  ]
Starting NFS mountd:                                       [  OK  ]

$ chkconfig nfs on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;persistent-volumes-추가&quot;&gt;Persistent Volumes 추가&lt;/h2&gt;

&lt;p&gt;kuberctl로 추가 하는 방법도 있고, 지금 사용하는 Rancher UI에서 처리 하는 방법도 있다.&lt;/p&gt;

&lt;p&gt;간단하게 Rancher UI에서 설정하는 방식은 우선 아래 메뉴로 이동 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kpv_menu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 &lt;strong&gt;Add Volumes&lt;/strong&gt; 버튼을 클릭해서 Volume을 설정을 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/add_volume.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설정을 저장하면 다음과 같이 추가된 내역을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kpv_menu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;claim-설정&quot;&gt;Claim 설정&lt;/h2&gt;

&lt;p&gt;Available 된 Persistent Volumes을 pod와 연동을 위해서 Claim과 연결 해야 한다.&lt;/p&gt;

&lt;p&gt;다음 메뉴로 이동 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/ku_claim_menu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Add Volumn&lt;/strong&gt; 버튼을 클릭하고, 아래와 같이 설정 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/add_claim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저장을 하고 나면, Bound 된 상태 확인이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/claim_bound.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용해보기&quot;&gt;사용해보기&lt;/h2&gt;

&lt;p&gt;이제 설정이 다 되었으면 다음과 같이 사용 하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: elasticsearch
  namespace: devops-tool
  labels:
    app: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: elasticsearch:latest
        ports:
        - containerPort: 9200
        imagePullPolicy: Always
        volumeMounts:
        - mountPath: /usr/share/elasticsearch/data
          name: elasticsearchdata
      volumes:
      - name: elasticsearchdata
        persistentVolumeClaim:
          claimName: mongodb-claim
---
apiVersion: v1
kind: Service
metadata:
  namespace: devops-tool
  name: elasticsearch
spec:
  ports:
    - port: 9200
      targetPort: 9200
      protocol: TCP
      name: http
      nodePort: 30560
  selector:
    app: elasticsearch
  type: LoadBalancer
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;중간에 내용을 보면,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        volumeMounts:
        - mountPath: /usr/share/elasticsearch/data
          name: elasticsearchdata
      volumes:
      - name: elasticsearchdata
        persistentVolumeClaim:
          claimName: mongodb-claim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기를 잘 보면 된다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://waspro.tistory.com/580&quot;&gt;Kubernetes Persistent Volume 생성하기 - PV, PVC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yangnoon.tistory.com/38&quot;&gt;[LINUX][RHEL7] 리눅스 NFS서버 NFS클라이언트 설정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://unix.stackexchange.com/questions/82290/linux-clnt-create-rpc-program-not-registered&quot;&gt;Linux: clnt_create: RPC: Program not registered&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://server-talk.tistory.com/117&quot;&gt;NFS 설정하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="kubernetes" /><category term="persistent" /><category term="volumes" /><category term="nfs" /><summary type="html">pod의 저장소를 쓰면 pod가 삭제될때 함께 삭제되어 피똥 쌀 수 있다.</summary></entry><entry><title type="html">kubernetes Logging 처리를 해보자!</title><link href="https://lahuman.github.io/kubernetes-logging/" rel="alternate" type="text/html" title="kubernetes Logging 처리를 해보자!" /><published>2020-01-17T00:00:00+09:00</published><updated>2020-01-17T00:00:00+09:00</updated><id>https://lahuman.github.io/kubernetes-logging</id><content type="html" xml:base="https://lahuman.github.io/kubernetes-logging/">&lt;h1 id=&quot;fluentd를-활용해-kubernetes-로그를-elasticsearch에-저장하고-kibana로-표출-해보자&quot;&gt;fluentd를 활용해 kubernetes 로그를 elasticsearch에 저장하고 kibana로 표출 해보자!&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;kubernetes를 셋팅을 하고 다음으로 해야 할일은 모니터링이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그 작업의 기초가 되는일이 바로 로깅을 쌓는 일이다.&lt;/p&gt;

&lt;p&gt;모든 컨테이너의 로그들을 모아서 한 곳에서 확인할 수 있도록 구성했다.&lt;/p&gt;

&lt;p&gt;각 컨테이너에서 로그를 가져오는 것은 &lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt;를 이용했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt;에서 &lt;a href=&quot;https://www.elastic.co/kr/what-is/elasticsearch&quot;&gt;elasticsearch&lt;/a&gt;로 데이터를 적재 하도록 설정하였고, &lt;a href=&quot;https://www.elastic.co/kr/products/kibana&quot;&gt;kibana&lt;/a&gt;를 통해서 해당 데이터를 표출했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubernetes &amp;lt;-로그수집- fluentd -데이터 적재-&amp;gt; elasticsearch &amp;lt;-표출- kibana
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;구축-순서&quot;&gt;구축 순서&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.elastic.co/kr/what-is/elasticsearch&quot;&gt;elasticsearch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.elastic.co/kr/products/kibana&quot;&gt;kibana&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;elasticsearch-구성&quot;&gt;&lt;a href=&quot;https://www.elastic.co/kr/what-is/elasticsearch&quot;&gt;elasticsearch&lt;/a&gt; 구성&lt;/h3&gt;

&lt;p&gt;kubernetes의 오브젝트를 생성하기 위한 yaml 파일을 다음과 같이 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# elastic.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: elasticsearch
  labels:
    app: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: elastic/elasticsearch:6.8.6
        env:
        - name: discovery.type
          value: &quot;single-node&quot;
        ports:
        - containerPort: 9200
        - containerPort: 9300
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: elasticsearch
  name: elasticsearch-svc
  namespace: default
spec:
  ports:
  - name: elasticsearch-rest
    nodePort: 30482
    port: 9200
    protocol: TCP
    targetPort: 9200
  - name: elasticsearch-nodecom
    nodePort: 30930
    port: 9300
    protocol: TCP
    targetPort: 9300
  selector:
    app: elasticsearch
  type: NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; 명령어를 이용해서 오브젝트를 kubernetes에 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kbuectl apply -f elastic.yml
deployment.apps/elasticsearch created
service/elasticsearch-svc created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정된 노드포트를 통해서 서비스를 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://${kubernetes_host}:30842/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/elastic_service_check.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kibana-구성&quot;&gt;&lt;a href=&quot;https://www.elastic.co/kr/products/kibana&quot;&gt;kibana&lt;/a&gt; 구성&lt;/h3&gt;

&lt;p&gt;kubernetes의 오브젝트를 생성하기 위한 yaml 파일을 다음과 같이 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# kibana.yml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
  labels:
    app: kibana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      containers:
      - name: kibana
        image: elastic/kibana:6.8.6
        env:
        - name: SERVER_NAME
          value: &quot;kibana.kubenetes.example.com&quot;
        - name: ELASTICSEARCH_URL
          value: &quot;http://elasticsearch-svc.default.svc.cluster.local:9200&quot;
        ports:
        - containerPort: 5601
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: kibana
  name: kibana-svc
  namespace: default
spec:
  ports:
  - nodePort: 30920
    port: 5601
    protocol: TCP
    targetPort: 5601
  selector:
    app: kibana
  type: NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;연결하는 elasticsearch 주소는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://elasticsearch-svc.default.svc.cluster.local:9200&lt;/code&gt;이다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; 명령어를 이용해서 오브젝트를 kubernetes에 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kbuectl apply -f kibana.yml
deployment.apps/kibana created
service/kibana-svc created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설정된 노드포트를 통해서 서비스를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kibana_service_check.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fluentd-구성&quot;&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset&quot;&gt;fluentd&lt;/a&gt; 구성&lt;/h3&gt;

&lt;p&gt;kubernetes의 오브젝트를 생성하기 위한 yaml 파일을 다음과 같이 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# fluentd.yml

apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    k8s-app: fluentd
  name: fluentd
  namespace: kube-system

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: fluentd
rules:
  - apiGroups:
      - &quot;&quot;
    resources:
      - &quot;namespaces&quot;
      - &quot;pods&quot;
    verbs:
      - &quot;list&quot;
      - &quot;get&quot;
      - &quot;watch&quot;

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: fluentd
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: fluentd
subjects:
- kind: ServiceAccount
  name: fluentd
  namespace: kube-system

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
  namespace: kube-system
  labels:
    k8s-app: fluentd-logging
    version: v1
    kubernetes.io/cluster-service: &quot;true&quot;
spec:
  selector:
    matchLabels:
      k8s-app: fluentd-logging
  template:
    metadata:
      labels:
        k8s-app: fluentd-logging
        version: v1
        kubernetes.io/cluster-service: &quot;true&quot;
    spec:
      serviceAccount: fluentd
      serviceAccountName: fluentd
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: fluentd
        image: fluent/fluentd-kubernetes-daemonset:v1.4.2-debian-elasticsearch-1.1
        env:
          - name:  FLUENT_ELASTICSEARCH_HOST
            value: &quot;elasticsearch-svc.default.svc.cluster.local&quot;
          - name:  FLUENT_ELASTICSEARCH_PORT
            value: &quot;9200&quot;
          - name: FLUENT_ELASTICSEARCH_SCHEME
            value: &quot;http&quot;
          - name: FLUENTD_SYSTEMD_CONF
            value: &quot;disable&quot;
          - name: FLUENT_UID
            value: &quot;0&quot;
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 설정에서 보면 /var/log를 모두 로그를 가져오며 가져온 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://elasticsearch-svc.default.svc.cluster.local:9200&lt;/code&gt;에 적재 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; 명령어를 이용해서 오브젝트를 kubernetes에 생성한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kbuectl apply -f fluentd.yml
serviceaccount/fluentd created
clusterrole.rbac.authorization.k8s.io/fluentd created
clusterrolebinding.rbac.authorization.k8s.io/fluentd created
daemonset.apps/fluentd created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;설치시-오류-발생에-따른-해결책&quot;&gt;설치시 오류 발생에 따른 해결책&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/58252254/unable-to-recognize-filebeat-kubernetes-yaml-no-matches-for-kind-daemonset&quot;&gt;unable to recognize “filebeat-kubernetes.yaml”: no matches for kind “DaemonSet” in version “extensions/v1beta1”&lt;/a&gt; 과 같은 오류가 발생한 이유는 &lt;code class=&quot;highlighter-rouge&quot;&gt;apiVersion&lt;/code&gt;이 extensions/v1beta1을 사용하지 말고 apps/v1을 사용하도록 되어 있다.&lt;/p&gt;

&lt;p&gt;다음과 같은 오류가 발생할 경우,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2018-11-26 23:19:44 +0000 [warn]: suppressed same stacktrace
2018-11-26 23:19:50 +0000 [info]: stats - namespace_cache_size: 3, pod_cache_size: 6, namespace_cache_api_updates: 15, pod_cache_api_updates: 15, id_cache_miss: 15
2018-11-26 23:20:14 +0000 [warn]: temporarily failed to flush the buffer. next_retry=2018-11-26 23:20:44 +0000 error_class=&quot;MultiJson::AdapterError&quot; error=&quot;Did not recognize your adapter specification (cannot load such file -- bigdecimal).&quot; plugin_id=&quot;out_es&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;debian 계열의 이미지를 사용하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;containers:
- name: fluentd
image: fluent/fluentd-kubernetes-daemonset:v1.4.2-debian-elasticsearch-1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset/issues/230&quot;&gt;Did not recognize your adapter specification #230&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료되고 나면, 각 worker node에서 기동하는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;kibana-설정&quot;&gt;kibana 설정&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Management =&amp;gt; kibana =&amp;gt; Index Patterns =&amp;gt; Create Index Pattern =&amp;gt; &quot;logstash-*&quot; 추가
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kibana_setting.png&quot; alt=&quot;설정화면&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 처리 하면 다음과 같은 결과를 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post_img/kibana_result_sample.png&quot; alt=&quot;설정화면&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;한땀 한땀 설치 kubernetes의 오부젝트에 대하여 더 많이 이해하게 되었다.&lt;/p&gt;

&lt;p&gt;데이터 적재의 형태나, node의 error 로그 적재 등은 좀더 확인해봐야겠다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/cluster-administration/logging/&quot;&gt;https://kubernetes.io/docs/concepts/cluster-administration/logging/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arisu1000.tistory.com/27852&quot;&gt;쿠버네티스 로깅(kubernetes logging)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/58252254/unable-to-recognize-filebeat-kubernetes-yaml-no-matches-for-kind-daemonset&quot;&gt;unable to recognize “filebeat-kubernetes.yaml”: no matches for kind “DaemonSet” in version “extensions/v1beta1”&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fluent/fluentd-kubernetes-daemonset/issues/230&quot;&gt;Did not recognize your adapter specification #230&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="kubernetes" /><category term="fluentd" /><category term="elasticsearch" /><category term="kibana" /><summary type="html">fluentd를 활용해 kubernetes 로그를 elasticsearch에 저장하고 kibana로 표출 해보자!</summary></entry></feed>

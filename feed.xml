<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2018-04-02T11:07:56+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">SHELL] 디렉토리 구조 출력</title><link href="https://lahuman.github.io/shell_show_directory_structure/" rel="alternate" type="text/html" title="SHELL] 디렉토리 구조 출력" /><published>2018-04-02T00:00:00+09:00</published><updated>2018-04-02T00:00:00+09:00</updated><id>https://lahuman.github.io/shell_show_directory_structure</id><content type="html" xml:base="https://lahuman.github.io/shell_show_directory_structure/">&lt;h1 id=&quot;특정-디렉토리에서-구조를-출력-하는-방법&quot;&gt;특정 디렉토리에서 구조를 출력 하는 방법&lt;/h1&gt;

&lt;p&gt;디렉토리의 구조를 출력 하는 방법은 2가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.computerhope.com/unix/tree.htm&quot;&gt;Tree&lt;/a&gt; 모듈을 설치 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tree 명령어는 많은 옵션을 제공하고 널리 사용되는 모듈이다.&lt;/p&gt;

&lt;p&gt;다만 쉬운 설치를 위해서 인터넷이 되어야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Command 를 이용한 출력&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type d | sed -e &quot;s/[^-][^\/]*\//  |/g&quot; -e &quot;s/|\([^ ]\)/|-\1/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;설치가 필요 없고 단순하게 철력이 가능하다. 
다만, 옵션이 없기 때문에 COMMAND를 조합 해야 한다.
예를 들어 abc 디렉토리를 제외 하고 싶다면 다음과 같은 명령어를 실행 해야 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type d | grep -v abc | sed -e &quot;s/[^-][^\/]*\//  |/g&quot; -e &quot;s/|\([^ ]\)/|-\1/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일회성으로 쓰기 좋다!&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.computerhope.com/unix/tree.htm&quot;&gt;Tree Command&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/431251/how-to-print-the-directory-tree-in-terminal&quot;&gt;How to print the directory tree in terminal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><category term="unzip" /><category term="rename" /><summary type="html">show directory structure</summary></entry><entry><title type="html">SHELL] 디렉토리 구조 출력</title><link href="https://lahuman.github.io/bash_tree/" rel="alternate" type="text/html" title="SHELL] 디렉토리 구조 출력" /><published>2018-04-02T00:00:00+09:00</published><updated>2018-04-02T00:00:00+09:00</updated><id>https://lahuman.github.io/bash_tree</id><content type="html" xml:base="https://lahuman.github.io/bash_tree/">&lt;h1 id=&quot;특정-디렉토리에서-구조를-출력-하는-방법&quot;&gt;특정 디렉토리에서 구조를 출력 하는 방법&lt;/h1&gt;

&lt;p&gt;디렉토리의 구조를 출력 하는 방법은 2가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.computerhope.com/unix/tree.htm&quot;&gt;Tree&lt;/a&gt; 모듈을 설치 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;tree 명령어는 많은 옵션을 제공하고 널리 사용되는 모듈이다.&lt;/p&gt;

&lt;p&gt;다만 쉬운 설치를 위해서 인터넷이 되어야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Command 를 이용한 출력&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type d | sed -e &quot;s/[^-][^\/]*\//  |/g&quot; -e &quot;s/|\([^ ]\)/|-\1/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;설치가 필요 없고 단순하게 철력이 가능하다. 
다만, 옵션이 없기 때문에 COMMAND를 조합 해야 한다.
예를 들어 abc 디렉토리를 제외 하고 싶다면 다음과 같은 명령어를 실행 해야 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -type d | grep -v abc | sed -e &quot;s/[^-][^\/]*\//  |/g&quot; -e &quot;s/|\([^ ]\)/|-\1/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일회성으로 쓰기 좋다!&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.computerhope.com/unix/tree.htm&quot;&gt;Tree Command&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/431251/how-to-print-the-directory-tree-in-terminal&quot;&gt;How to print the directory tree in terminal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><category term="unzip" /><category term="rename" /><summary type="html">show directory structure</summary></entry><entry><title type="html">Python] unzip with file rename</title><link href="https://lahuman.github.io/python_unzip_with_rename/" rel="alternate" type="text/html" title="Python] unzip with file rename" /><published>2018-03-30T00:00:00+09:00</published><updated>2018-03-30T00:00:00+09:00</updated><id>https://lahuman.github.io/python_unzip_with_rename</id><content type="html" xml:base="https://lahuman.github.io/python_unzip_with_rename/">&lt;h1 id=&quot;파이썬을-이용한-압축-해제와-동시에-파일-이름-변경&quot;&gt;파이썬을 이용한 압축 해제와 동시에 파일 이름 변경&lt;/h1&gt;

&lt;p&gt;특정 사이트에서 대량의 압축된 파일을 받아 하나의 디렉터리에 풀어야 하는 미션이 떨어졌다.&lt;/p&gt;

&lt;p&gt;문제는 같은 파일 명이 중복으로 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;이에 대한 해결책으로 다음 2개의 방법으로 고민했다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파일 압축 해제 후 MV 명령어로 이름 변경&lt;/li&gt;
  &lt;li&gt;압축을 해제할 때 PATH를 줄 수 있는가?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1번의 방법은 누구나 쉽게 할 수 있을 것 같았다.&lt;/p&gt;

&lt;p&gt;2번의 경우 가능 한지 조차 몰라서 Python에서 압축 관련 모듈인 &lt;a href=&quot;https://docs.python.org/2/library/zipfile.html&quot;&gt;ZipFile&lt;/a&gt;을 살펴보았다.&lt;/p&gt;

&lt;p&gt;내용을 확인 결과 압축 파일에서 하나의 파일을 읽을 수 있는 read리는 function이 있다.&lt;/p&gt;

&lt;p&gt;이를 이용해 다음과 같이 처리하였다&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with ZipFile(&quot;filename.zip&quot;) as zf:
    
    file_list = map(lambda x: &quot;/&quot; + str(uuid.uuid4()), zf.filelist) # 파일 개수만큼 uuid를 생성
    idx = 0
    for zip_file in zf.namelist():  # 루프를 돌며 하나의 파일을 가져옴
        target_path = zip_save_path + file_list[idx]  # 저장되는 파일 위치
        with open(target_path, &quot;wb&quot;) as f:  # 저장되는 파일을 쓰기 모드로 오픈
            f.write(zf.read(zip_file, pwd=self.password))  # 압축된 파일을 읽어서 타깃 파일로 저장

        idx += 1 # 다음 uuid 선택
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파일은 내가 원하는 위치에 uuid 값으로 저장된다.&lt;/p&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/library/zipfile.html&quot;&gt;ZipFile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="python" /><category term="unzip" /><category term="rename" /><summary type="html">압축을 해제 하면서 원하는 파일 이름으로 해제 하자</summary></entry><entry><title type="html">글을 쓴다는게 쉽지 않구나…</title><link href="https://lahuman.github.io/20180329-phase/" rel="alternate" type="text/html" title="글을 쓴다는게 쉽지 않구나..." /><published>2018-03-29T00:00:00+09:00</published><updated>2018-03-29T00:00:00+09:00</updated><id>https://lahuman.github.io/20180329-phase</id><content type="html" xml:base="https://lahuman.github.io/20180329-phase/">&lt;h1 id=&quot;글을-잘-쓰는-사람은-대단하다&quot;&gt;글을 잘 쓰는 사람은 대단하다.&lt;/h1&gt;

&lt;p&gt;남에게 설명을 할수 있는것도 정확히 알아야 한다.&lt;/p&gt;

&lt;p&gt;하지만 내가 잘 안다고 해서 그것을 글로 표현하는건 별게의 문제 같다.&lt;/p&gt;

&lt;p&gt;대화로는 상대가 이해를 못했으면 다른 방향으로 설명을 하지만 글은 단방향이기 때문에 누구나 알아 보기 쉽게 써야 한다.&lt;/p&gt;

&lt;p&gt;##어렵다 어려워…&lt;/p&gt;</content><author><name></name></author><category term="단상" /><summary type="html">내가 쓴글인데 뭔소린지 모르겠다.</summary></entry><entry><title type="html">요즘 내가 하는 일은…</title><link href="https://lahuman.github.io/20180326-phase/" rel="alternate" type="text/html" title="요즘 내가 하는 일은..." /><published>2018-03-26T00:00:00+09:00</published><updated>2018-03-26T00:00:00+09:00</updated><id>https://lahuman.github.io/20180326-phase</id><content type="html" xml:base="https://lahuman.github.io/20180326-phase/">&lt;h1 id=&quot;요즘-나는-해야-하는-일을-하고-있다&quot;&gt;요즘 나는 해야 하는 일을 하고 있다.&lt;/h1&gt;

&lt;p&gt;처음 접해보는 언어와 플랫폼을 가지고 4월 말까지 개발을 완료 해야 한다.&lt;/p&gt;

&lt;p&gt;자신이 없지만, 해야 하는 일이다. 
일을 시작하던 20대 중반에는 늘 이런 일뿐이었는데 경험이 많아지니 안하던 일은 하고 싶어 하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스트레스를 받을 때, 사람은 성장할 수 있는 기회를 얻은 것&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;이것을-발판-삼아-성장하자&quot;&gt;이것을 발판 삼아 성장하자!&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">잘하는 일, 할 수 있는 일, 해야 하는 일</summary></entry><entry><title type="html">오늘을 즐겁게 살자</title><link href="https://lahuman.github.io/20180319-phase/" rel="alternate" type="text/html" title="오늘을 즐겁게 살자" /><published>2018-03-19T00:00:00+09:00</published><updated>2018-03-19T00:00:00+09:00</updated><id>https://lahuman.github.io/20180319-phase</id><content type="html" xml:base="https://lahuman.github.io/20180319-phase/">&lt;h1 id=&quot;명확하게-내가-해야-할-일을-하자&quot;&gt;명확하게 내가 해야 할 일을 하자&lt;/h1&gt;

&lt;p&gt;지금 내가 해야 하는 하나의 일에 집중하자.&lt;/p&gt;

&lt;p&gt;아이와 함께라면 &lt;strong&gt;즐겁게 아이와 놀자.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아내와 함께라면 &lt;strong&gt;아내와 많이 이야기 하고 행복하자.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;회사 동료와 함께라면 &lt;strong&gt;열심히 일하자!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;오늘도-열심히&quot;&gt;오늘도 열심히!!&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">내가 지금 무엇을 해야 하는지 가끔씩 길을 잃을때가 있다.</summary></entry><entry><title type="html">모든 것을 색인하는 _all option</title><link href="https://lahuman.github.io/elastic_events_all_option/" rel="alternate" type="text/html" title="모든 것을 색인하는 _all option" /><published>2018-03-13T00:00:00+09:00</published><updated>2018-03-13T00:00:00+09:00</updated><id>https://lahuman.github.io/elastic_events_all_option</id><content type="html" xml:base="https://lahuman.github.io/elastic_events_all_option/">&lt;h1 id=&quot;색인-전체-크기를-줄이고-더-빠르게-색인을-생성하기-위해-_all-option을-꺼두자&quot;&gt;색인 전체 크기를 줄이고 더 빠르게 색인을 생성하기 위해 _all option을 꺼두자&lt;/h1&gt;

&lt;p&gt;_source는 모든 것을 저장하고, _all은 모든 것을 색인한다.&lt;/p&gt;

&lt;p&gt;따라서 필드 이름 없이 검색을 하면 _all로 설정된 필드를 검색하여 반환한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT my_index/user/1 
{
  &quot;first_name&quot;:    &quot;John&quot;,
  &quot;last_name&quot;:     &quot;Smith&quot;,
  &quot;date_of_birth&quot;: &quot;1970-10-24&quot;
}

GET my_index/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;_all&quot;: &quot;john smith 1970&quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 값을 넣고 검색을 하면 결과로 넣었던 데이터가 출력 된다.&lt;/p&gt;

&lt;p&gt;만약 항상 특정 필드만 검색하려면 _all의 옵션을 false로 설정할수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;type_1&quot;: { 
      &quot;properties&quot;: {...}
    },
    &quot;type_2&quot;: { 
      &quot;_all&quot;: {
        &quot;enabled&quot;: false
      },
      &quot;properties&quot;: {...}
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 type_2에 _all enabled를 false로 준다면 특정 필드에 설정 할 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 색인 전체 크기가 줄어 들고, 더 빠르게 색인을 생성한다.&lt;/p&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/2.4/mapping-all-field.html&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="elastic" /><category term="sense" /><summary type="html">elastic에서 기본적으로 모든 것을 색인한다.</summary></entry><entry><title type="html">Elastic Query 작성 툴 추천</title><link href="https://lahuman.github.io/elastic_query/" rel="alternate" type="text/html" title="Elastic Query 작성 툴 추천" /><published>2018-03-12T00:00:00+09:00</published><updated>2018-03-12T00:00:00+09:00</updated><id>https://lahuman.github.io/elastic_query</id><content type="html" xml:base="https://lahuman.github.io/elastic_query/">&lt;h1 id=&quot;mac에서-elastic-query작성-툴-추천&quot;&gt;Mac에서 Elastic Query작성 툴 추천&lt;/h1&gt;

&lt;p&gt;처음 사용한 툴은 &lt;a href=&quot;https://mmattozzi.github.io/cocoa-rest-client/&quot;&gt;Coco Rest Client&lt;/a&gt;이다.&lt;/p&gt;

&lt;p&gt;기본적인 기능은 Postman과 같다고 생각 하면된다. 이를 이용해서 elastic query를 작성하는것은 2% 부족하다.&lt;/p&gt;

&lt;p&gt;2%를 채워줄만한 툴이 바로 kibana의 플러그인으로 제공되는 &lt;a href=&quot;https://www.elastic.co/guide/en/sense/current/installing.html&quot;&gt;Sense&lt;/a&gt;이다.&lt;/p&gt;

&lt;p&gt;4.2 이상의 kibana가 설치 되어 있으면 다음 명령으로 설치 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$./bin/kibana plugin --install elastic/sense
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 Kibana를 시작하면 된다.&lt;/p&gt;</content><author><name></name></author><category term="elastic" /><category term="sense" /><summary type="html">kibana에 플러그인으로 제공되는 sense가 제일 좋더라</summary></entry><entry><title type="html">Python에서 class 선언시 object를 꼭 상속 받자</title><link href="https://lahuman.github.io/python_object/" rel="alternate" type="text/html" title="Python에서 class 선언시 object를 꼭 상속 받자" /><published>2018-03-07T00:00:00+09:00</published><updated>2018-03-07T00:00:00+09:00</updated><id>https://lahuman.github.io/python_object</id><content type="html" xml:base="https://lahuman.github.io/python_object/">&lt;h1 id=&quot;python에서-class-선언시-object를-꼭-상속-받자&quot;&gt;Python에서 class 선언시 object를 꼭 상속 받자&lt;/h1&gt;

&lt;p&gt;python은 전역 객체를 선언할 경우 해당 클래스를 메모리에 올리는 초기 작업에서 실행 된다.
예를 들어 다음과 같은 코드에서 # 1, # 2 순서로 실행된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import lahuman

class test(object):
	a = lahuman.A() # 1 : 

	def b(self):
		pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main python&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import test # 1

if __name__ == '__main__':
    t = test()
    t.b() # 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 test 클래스가 object를 상속 받지 않을 경우 객체 생성시 object를 상속 받지 않으면 객체생성시 &lt;strong&gt;new&lt;/strong&gt; 메소드가 호출되지 않는다.&lt;/p&gt;</content><author><name></name></author><category term="python" /><summary type="html">object를 상속 받지 않으면 __new__ 메소드 호출이 안된다.</summary></entry><entry><title type="html">아이가 크는 속도는 생각의 속도 보다 빠르다.</title><link href="https://lahuman.github.io/20180306-phase/" rel="alternate" type="text/html" title="아이가 크는 속도는 생각의 속도 보다 빠르다." /><published>2018-03-06T00:00:00+09:00</published><updated>2018-03-06T00:00:00+09:00</updated><id>https://lahuman.github.io/20180306-phase</id><content type="html" xml:base="https://lahuman.github.io/20180306-phase/">&lt;h1 id=&quot;아이가-크고-고민도-늘고&quot;&gt;아이가 크고 고민도 늘고…&lt;/h1&gt;

&lt;p&gt;아이가 크는 속도는 내가 생각하는 속도보다 많이 빠르다.&lt;/p&gt;

&lt;p&gt;엉금엉금 기어다니던 아이가 어느새 걸음마를 시작하고, 뛰고, 높은 곳으로 오르고, 말하고 훌쩍 커버렸다.&lt;/p&gt;

&lt;p&gt;아이가 크면서 아쉬운건 같이 보내는 시간이 짧다는 생각을 많이 한다.&lt;/p&gt;

&lt;p&gt;함께 무엇을 하려고 하면 시간에 쫓기여 급하게 하고 만다.&lt;/p&gt;

&lt;p&gt;같이 하루 종일 바다가에서 일광욕을 하고, 기차여행도 하고 느긋한 인생을 보여 주고 싶은데 내 욕심에 쉽지 않다.&lt;/p&gt;

&lt;p&gt;많은 것을 보여주고 경험하게 해주고 싶은 나의 욕심에 아이를 윽박지르며 억지로 끌고 다니는건 아닌지 하는 생각이 든다.&lt;/p&gt;

&lt;h2 id=&quot;사랑한다-사랑한다-사랑한다&quot;&gt;사랑한다. 사랑한다. 사랑한다.&lt;/h2&gt;</content><author><name></name></author><category term="단상" /><summary type="html">언제 이렇게 컷는지....</summary></entry></feed>
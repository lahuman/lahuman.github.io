<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://lahuman.github.io/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.8.4">Jekyll</generator><link href="https://lahuman.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lahuman.github.io/" rel="alternate" type="text/html" /><updated>2019-03-15T11:31:50+09:00</updated><id>https://lahuman.github.io/</id><title type="html">lahuman</title><subtitle>열심히 사는 아저씨</subtitle><entry><title type="html">MongoDB aggregate 사용해보기</title><link href="https://lahuman.github.io/mongodb_aggregate/" rel="alternate" type="text/html" title="MongoDB aggregate 사용해보기" /><published>2019-03-14T00:00:00+09:00</published><updated>2019-03-14T00:00:00+09:00</updated><id>https://lahuman.github.io/mongodb_aggregate</id><content type="html" xml:base="https://lahuman.github.io/mongodb_aggregate/">&lt;h1 id=&quot;mongodb-aggregate-사용&quot;&gt;MongoDB aggregate 사용&lt;/h1&gt;

&lt;p&gt;다음과 같은 형식의 여러 ROW의 데이터를 하나의 데이터로 표현 하고 싶었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# DATA
{
    &quot;_id&quot; : ObjectId(&quot;5c864b1e1cd4038eed5b5633&quot;),
    &quot;link_tag&quot; : [ 
        &quot;#핫앤쿨&quot;, 
        &quot;#마스크팩&quot;, 
        &quot;#홈케어&quot;, 
        &quot;#리뉴메디&quot;, 
        &quot;#젊줌마&quot;, 
        &quot;#예뻐지는시간&quot;
    ],
    &quot;name&quot; : &quot;홈케어&quot;,
    &quot;text&quot; : &quot;젊어지는시간\n. .\n\n#핫앤쿨 #마스크팩 #홈케어\n#리뉴메디 #젊줌마 #예뻐지는시간&quot;,
    &quot;owner&quot; : &quot;10961953345&quot;,
    &quot;shortcode&quot; : &quot;Bu3eX2iHIFG&quot;,
    &quot;display_url&quot; : &quot;https://scontent-icn1-1.cdninstagram.com/vp/c330b55401b96aca266acca202386b42/5D08D97D/t51.2885-15/e35/54446467_181108306201409_5180562059450456961_n.jpg?_nc_ht=scontent-icn1-1.cdninstagram.com&quot;,
    &quot;is_video&quot; : false,
    &quot;accessibility_caption&quot; : &quot;Image may contain: 1 person&quot;,
    &quot;writed_date&quot; : ISODate(&quot;2019-03-11T11:44:00.000Z&quot;),
    &quot;hash&quot; : &quot;086e2b6a65b823c887ef1afc19734f67&quot;,
    &quot;createdAt&quot; : ISODate(&quot;2019-03-11T11:48:46.276Z&quot;),
    &quot;updatedAt&quot; : ISODate(&quot;2019-03-11T12:22:43.532Z&quot;),
    &quot;__v&quot; : 3
}

/* 2 */
{
    &quot;_id&quot; : ObjectId(&quot;5c864b1e1cd4038eed5b5632&quot;),
    &quot;link_tag&quot; : [ 
        &quot;#토니슈어&quot;, 
        &quot;#다낭까지와서&quot;, 
        &quot;#이러고있다&quot;, 
        &quot;#간절한걸어떡함&quot;, 
        &quot;#플라즈마&quot;, 
        &quot;#갈바닉&quot;, 
        &quot;#너네둘만믿는다&quot;, 
        &quot;#동안피부&quot;, 
        &quot;#얼굴마사지기&quot;, 
        &quot;#피부개선&quot;, 
        &quot;#탄력&quot;, 
        &quot;#피부미용기기&quot;, 
        &quot;#미용&quot;, 
        &quot;#홈케어&quot;, 
        &quot;#피부미인&quot;, 
        &quot;#데일리&quot;, 
        &quot;#뷰티&quot;, 
        &quot;#살균&quot;, 
        &quot;#셀프&quot;, 
        &quot;#피부질환&quot;, 
        &quot;#플라즈마&quot;, 
        &quot;#트러블케어&quot;, 
        &quot;#피부&quot;, 
        &quot;#피부과&quot;, 
        &quot;#선물&quot;, 
        &quot;#물광피부&quot;, 
        &quot;#보습&quot;, 
        &quot;#안티에이징&quot;, 
        &quot;#led마스크&quot;, 
        &quot;#미백&quot;, 
        &quot;#콜라겐&quot;
    ],
    &quot;name&quot; : &quot;홈케어&quot;,
    &quot;text&quot; : &quot;토니느님~ 제 피부를 10년전으로 돌려주세요\n\n제발요....♡ .\n\n#토니슈어 #다낭까지와서 #이러고있다 #간절한걸어떡함 #플라즈마 #갈바닉 #너네둘만믿는다 #동안피부 가즈앙~ \n#얼굴마사지기 #피부개선 #탄력 #피부미용기기 #미용 #홈케어 #피부미인 #데일리 #뷰티 #살균 #셀프 #피부질환 #플라즈마 #트러블케어 #피부 #피부과 #선물 #물광피부 #보습 #안티에이징 #led마스크 #미백 #콜라겐&quot;,
    &quot;owner&quot; : &quot;10698447319&quot;,
    &quot;shortcode&quot; : &quot;Bu3e2n_jrrE&quot;,
    &quot;display_url&quot; : &quot;https://scontent-icn1-1.cdninstagram.com/vp/97d840dbdea55753d2a976302f90002b/5D065CE9/t51.2885-15/fr/e15/s1080x1080/53176269_319394038719034_3474616797099883761_n.jpg?_nc_ht=scontent-icn1-1.cdninstagram.com&quot;,
    &quot;is_video&quot; : false,
    &quot;accessibility_caption&quot; : &quot;Image may contain: outdoor and water&quot;,
    &quot;writed_date&quot; : ISODate(&quot;2019-03-11T11:48:12.000Z&quot;),
    &quot;hash&quot; : &quot;c9a418d8295391c1c83553f0316d1127&quot;,
    &quot;createdAt&quot; : ISODate(&quot;2019-03-11T11:48:46.266Z&quot;),
    &quot;updatedAt&quot; : ISODate(&quot;2019-03-11T12:22:43.527Z&quot;),
    &quot;__v&quot; : 3
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원하는 결과 데이터&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
	{ &quot;tag&quot; : &quot;#미백&quot;, &quot;count&quot; : 3},
	{ &quot;tag&quot; : &quot;#물광&quot;, &quot;count&quot; : 4},
	{ &quot;tag&quot; : &quot;#보습&quot;, &quot;count&quot; : 10},
	...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;구글을 검색하니 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/update/push/&quot;&gt;$push&lt;/a&gt;명령어를 찾았다.&lt;/p&gt;

&lt;p&gt;내가 처리한 Query는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.hashtag.aggregate([
    { $unwind: &quot;$link_tag&quot; },
    { $match: { $and: [{ name: &quot;테그명&quot; }, { &quot;createdAt&quot;: { $gte: (new Date()), $lt: (new Date()) } }] } },
    { $group: { _id: null, clrs: { $push: &quot;$link_tag&quot; } } },
    { $project: { _id: 0, link_tag: &quot;$clrs&quot; } }
  ]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 처리 하면 하나의 Array를 받을수 있는데 내가 원하는 결과까지의 데이터는 아니다.&lt;/p&gt;

&lt;p&gt;따라서 Backend에서 추가적으로 작업을 하였다.(시간을 더 투자 하면 방법이 있을거 같긴 한데…)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# result =&amp;gt; 데이터
    for (let i = 0; i &amp;lt; result[0].link_tag.length; i++) {
      const num = result[0].link_tag[i];
      counts[num] = counts[num] ? counts[num] + 1 : 1;
    }

    delete counts['#'+tag];
    
    const output = [];
    for (let i in counts) {
        output.push({ text: i, size: counts[i] });
    }
# output 을 사용하면 원하는 최종 값
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음은 매 시간별로 수집된 데이터를 counting 하는 query 이다.&lt;/p&gt;

&lt;p&gt;내가 원하는 결과는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
	{&quot;date&quot;: &quot;2018-03-14 10&quot;, &quot;count&quot;:30},
	{&quot;date&quot;: &quot;2018-03-14 11&quot;, &quot;count&quot;:20},
	{&quot;date&quot;: &quot;2018-03-14 12&quot;, &quot;count&quot;:33},
	{&quot;date&quot;: &quot;2018-03-14 13&quot;, &quot;count&quot;:34}
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다행이 이번 QUERY는 한방에 처리 하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;db.hashtag.aggregate([
    { $match: { $and: [{ name: &quot;태그명&quot; }, { &quot;createdAt&quot;: { $gte: (new Date()), $lt: (new Date()) } }] } },
    {
      $group:
      {
        _id:
        {
          hour: { $hour: &quot;$createdAt&quot; },
          day: { $dayOfMonth: &quot;$createdAt&quot; },
          month: { $month: &quot;$createdAt&quot; },
          year: { $year: &quot;$createdAt&quot; }
        },
        value: { $sum: 1 },
        date: { $first: &quot;$createdAt&quot; },
        sortDate: { $first: &quot;$createdAt&quot; }
      }
    },
    {
      $project:
      {
        date:
        {
          $dateToString: { format: &quot;%Y-%m-%d %H&quot;, date: &quot;$date&quot; }
        },
        sortDate: 1,
        value: 1,
        _id: 0
      }
    },
    { $sort: { sortDate: 1 }}
  ])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;분명히 많은 기능을 Mongodb에서 제공해주고 있는데, 잘 쓰지 못하고 있다…&lt;/p&gt;

&lt;h2 id=&quot;노력하자&quot;&gt;노력하자.&lt;/h2&gt;

&lt;h2 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/update/push/&quot;&gt;$push&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="mongodb" /><category term="aggregate" /><summary type="html">많은걸 제공해주는데 내가 잘 모름...</summary></entry><entry><title type="html">Mongoosejs 삽질기</title><link href="https://lahuman.github.io/mongoosejs_usage/" rel="alternate" type="text/html" title="Mongoosejs 삽질기" /><published>2019-03-12T00:00:00+09:00</published><updated>2019-03-12T00:00:00+09:00</updated><id>https://lahuman.github.io/mongoosejs_usage</id><content type="html" xml:base="https://lahuman.github.io/mongoosejs_usage/">&lt;h1 id=&quot;mongoosejs-삽질기&quot;&gt;Mongoosejs 삽질기&lt;/h1&gt;

&lt;p&gt;Mongoosejs를 최근 프로젝트에서 잘 쓰고, 에러를 만나서 한참 고생을 했다.&lt;/p&gt;

&lt;p&gt;기억에 1g도 안나서 삽질을 많이 했다.&lt;/p&gt;

&lt;p&gt;Model에서 async와 await를 사용했더니, 에러가 많이 발생하였다.&lt;/p&gt;

&lt;h2 id=&quot;model에서는-비동기-처리로-남겨-두어야-큰-문제-없이-동작한다&quot;&gt;Model에서는 비동기 처리로 남겨 두어야 큰 문제 없이 동작한다.&lt;/h2&gt;

&lt;p&gt;잊지말자!&lt;/p&gt;

&lt;p&gt;오늘 삽질일기…&lt;/p&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md&quot;&gt;puppeteer troubleshooting&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/issues/404&quot;&gt;puppeteer not working on Ubuntu 16.04 but works on 14.04&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="mongoosejs" /><summary type="html">쉬운데 어려움...</summary></entry><entry><title type="html">puppeteer를 Ubuntu에 설치하고 기동하기</title><link href="https://lahuman.github.io/puppeteer_on_ubuntu/" rel="alternate" type="text/html" title="puppeteer를 Ubuntu에 설치하고 기동하기" /><published>2019-03-11T00:00:00+09:00</published><updated>2019-03-11T00:00:00+09:00</updated><id>https://lahuman.github.io/puppeteer_on_ubuntu</id><content type="html" xml:base="https://lahuman.github.io/puppeteer_on_ubuntu/">&lt;h1 id=&quot;puppeteer를-설치하고-구동하기&quot;&gt;puppeteer를 설치하고 구동하기&lt;/h1&gt;

&lt;p&gt;설치는 아주 간단하다. npm 을 이용해서 설치 하면 바로 되는데, 문제는 설치후 기동하면 오류가 난다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 설치
npm install --save puppeteer

# 실행
node app.js

# error 발생

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;에러 메시지에서는 &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md&quot;&gt;puppeteer troubleshooting&lt;/a&gt;를 보라고 하지만, 내게 도움되는 내역이 없었다.&lt;/p&gt;

&lt;p&gt;구글의 도움을 받아 찾은 &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/issues/404&quot;&gt;puppeteer not working on Ubuntu 16.04 but works on 14.04&lt;/a&gt;에서 다음 라이브러리를 설치하라는 메시지를 확인하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install libpangocairo-1.0-0 libx11-xcb1 libxcomposite1 libxcursor1 libxdamage1 libxi6 libxtst6 libnss3 libcups2 libxss1 libxrandr2 libgconf2-4 libasound2 libatk1.0-0 libgtk-3-0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;설치를 하고 나서 실행하면 문제 없이 잘된다.&lt;/p&gt;

&lt;h2 id=&quot;그러하다&quot;&gt;그러하다~&lt;/h2&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md&quot;&gt;puppeteer troubleshooting&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/issues/404&quot;&gt;puppeteer not working on Ubuntu 16.04 but works on 14.04&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="puppeteer" /><summary type="html">설치는 쉬운데, 필요한 라이브러리가 있음!</summary></entry><entry><title type="html">nodejs에서 sleep 구현하기</title><link href="https://lahuman.github.io/nodejs_sleep_inside_for/" rel="alternate" type="text/html" title="nodejs에서 sleep 구현하기" /><published>2019-03-09T00:00:00+09:00</published><updated>2019-03-09T00:00:00+09:00</updated><id>https://lahuman.github.io/nodejs_sleep_inside_for</id><content type="html" xml:base="https://lahuman.github.io/nodejs_sleep_inside_for/">&lt;h1 id=&quot;nodejs에서-sleep-구현하기&quot;&gt;nodejs에서 sleep 구현하기&lt;/h1&gt;

&lt;p&gt;nodejs에서 for문에 비동기 처리가 들어 있으면 해당 비동기 처리가 종료 되는 것을 기다려 주지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 Sleep 같은 처리를 하려면 많은 신경을 써야 한다.&lt;/p&gt;

&lt;p&gt;참고 자료를 기반으로 처리해보니 잘된다.&lt;/p&gt;

&lt;p&gt;내가 하려는데도 문제 없이 반영되는지 월요일에 확인해봐야겠다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const init = async () =&amp;gt; {
    for (let i=0; i&amp;lt;5; i++){
        console.log(1);
        await sleep(1000);
        console.log(2);
    }
 }
 const sleep = (ms) =&amp;gt; {
     return new Promise(resolve=&amp;gt;{
         setTimeout(resolve,ms)
     })
 }

init();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;쉬운게없다&quot;&gt;쉬운게없다&lt;/h2&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14249506/how-can-i-wait-in-node-js-javascript-l-need-to-pause-for-a-period-of-time&quot;&gt;How Can I Wait In Node.js (Javascript), l need to pause for a period of time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="nodejs" /><category term="sleep" /><summary type="html">nodejs는 for 문이 기본적으로 비동기로 동작하니 주의 할 것!</summary></entry><entry><title type="html">인증서버 구축기 - 3</title><link href="https://lahuman.github.io/auth_server_3/" rel="alternate" type="text/html" title="인증서버 구축기 - 3" /><published>2019-03-04T00:00:00+09:00</published><updated>2019-03-04T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_3</id><content type="html" xml:base="https://lahuman.github.io/auth_server_3/">&lt;h1 id=&quot;로그인-성공시-jwt를-이용하여-token-전송&quot;&gt;로그인 성공시 JWT를 이용하여 Token 전송&lt;/h1&gt;

&lt;h2 id=&quot;jwt&quot;&gt;&lt;a href=&quot;https://jwt.io&quot;&gt;JWT&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;jwt-설명-내용&quot;&gt;JWT 설명 내용&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JSON Web Token(JWT)는 JSON 객체로 당사자간에 안전하게 정보를 전송할수 있는 작고 독립적인 방법을 정의하는 공개 표준(&lt;a href=&quot;https://tools.ietf.org/html/rfc7519&quot;&gt;RFC 7519&lt;/a&gt;)입니다. 이 정보는 디지털 서명되기 때문에 검증되고 신뢰할 수 있습니다. JWT는 RSA/ECDSA를 이용한 공개키/개인키 또는 암호화(HMAC 알고리즘)를 이용하여 서명할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;jwt-사용-예시&quot;&gt;JWT 사용 예시&lt;/h3&gt;

&lt;h4 id=&quot;로그인-후속-처리&quot;&gt;로그인 후속 처리&lt;/h4&gt;

&lt;p&gt;가장 많이 사용되는 방법으로 사용자가 로그인 하면 후속 요청에 JWT가 포함되어 사용자가 해당 토큰으로 허용되는 경로, 서비스 및 리소스 액세스 할 수 있게 한다. 또한 JWT를 이용한 SSO(Single Sign On)은 오버헤드가 적고 다른 도메인에서 쉽게 사용할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;정보-교환&quot;&gt;정보 교환&lt;/h4&gt;

&lt;p&gt;JSON 웹 토큰은 당사자간에 정보를 안전하게 전송하는 좋은 방법이다. JWT는 서명을 할 수 있기 때문에 발신자에 대한 확인과 내용의 변조 여부를 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;json-구조&quot;&gt;JSON 구조&lt;/h3&gt;

&lt;p&gt;JSON은 dots(.)을 기준으로 3가지로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Header&lt;/li&gt;
  &lt;li&gt;Payload&lt;/li&gt;
  &lt;li&gt;Signature&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음과 같은 형태로 되어 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aaaaaa.zzzzzz.yyyyyy
______.______.______
Header.Payload.Signature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Header는 타입과 알고리즘 두가지 정보를 가지고 있다.&lt;/p&gt;

&lt;p&gt;Payload는 클레임(claim)이라고 명칭되는 name/value 한쌍으로 이루어 져 있다.&lt;/p&gt;

&lt;p&gt;클레임은 세 분류로 나눈다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;등록된(registred) 클레임 : iss(발급자), exp(만료시간), sub(주제), aud(잠재고객) 등이다.&lt;/li&gt;
  &lt;li&gt;공개(public) 클레임 : 자유롭게 정의할수 있다. 충돌을 방지하기 위해 URI 형식을 권장한다.&lt;/li&gt;
  &lt;li&gt;비공개(private) 클레임: 보통 클라이언트와 서버간 협의하에 사용되는 클레임 이름이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;JWT의 등록된 클레임 이름의 길이는 3자이다. 또한 서명된 토큰의 경우 변조되지 않도록 보호는 되지만 모든 사람이 읽을 수 있다. 암호화되지 않은 JWT의 페이로드 또는 헤더 요소에 비밀 정보를 넣으면 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Signature는 Header와 Payload의 인코딩 값을 합친후 주어진 비밀키로 해쉬를 생성 한다.&lt;/p&gt;

&lt;h2 id=&quot;jwt-구현-하기&quot;&gt;JWT 구현 하기&lt;/h2&gt;

&lt;p&gt;기존 프로젝트 코드에서 jsonwebtoken을 설치한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; npm install --save jsonwebtoken
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 router/index.js파일에서 해당 모듈을 이용해서 로그인 성공시 Token을 전달하고, isAdmin 토큰을 검증하고 ROLE_TEST1을 가지고 있을 경우만 통과 하도록 수정한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...모듈 추가...
const jwt = require('jsonwebtoken');

...로그인 성공시...
const token = jwt.sign(userInfo, secretKey, { expiresIn: '5m' });
res.json({ status: 'success', token });

...isAdmin...
const isAdmin = (req, res, next) =&amp;gt; {
  try {
    const decoded = jwt.verify(req.header('X-token'), secretKey);
    if (decoded.role.includes(roleAdmin)) {
      next();
    }
    else {
      res.json({ status: 403, message: 'Login failed' });
    }
  }
  catch (error) {
    res.json({ status: 500, message: `token Error: ${error.message}` });
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음시간에는 사용자 암호에 대한 해쉬알고리즘을 이용한 암호화 처리를 진행하자.&lt;/p&gt;

&lt;h3 id=&quot;금방끝나네&quot;&gt;금방끝나네!&lt;/h3&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;참고자료&quot;&gt;참고자료&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io&quot;&gt;JWT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="node" /><category term="auth" /><summary type="html">JWT를 이용하여 로그인 성공시 Token 전송</summary></entry><entry><title type="html">인증서버 구축기 - 2</title><link href="https://lahuman.github.io/auth_server_2/" rel="alternate" type="text/html" title="인증서버 구축기 - 2 " /><published>2019-03-02T00:00:00+09:00</published><updated>2019-03-02T00:00:00+09:00</updated><id>https://lahuman.github.io/auth_server_2</id><content type="html" xml:base="https://lahuman.github.io/auth_server_2/">&lt;h1 id=&quot;간단하게-dbms-구현과-로그인-처리&quot;&gt;간단하게 DBMS 구현과 로그인 처리&lt;/h1&gt;

&lt;p&gt;인증서버 구현에 대한 설계만 하고 손도 안되고 생각만 하고 있었다.&lt;/p&gt;

&lt;p&gt;DBMS는 다음 그림과 같은 형태로 구현했다.&lt;/p&gt;

&lt;figure&gt;
	&lt;a href=&quot;/assets/img/post_img/auth_erd.png&quot;&gt;&lt;img src=&quot;/assets/img/post_img/auth_erd.png&quot; /&gt;&lt;/a&gt;
	&lt;figcaption&gt;AUTH server ERD&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;이번 시간에는 Login API를 구현하고 테스트까지 진행한다.&lt;/p&gt;

&lt;h2 id=&quot;모델-구현&quot;&gt;모델 구현&lt;/h2&gt;

&lt;p&gt;모델을 구현하기 위하여 &lt;a href=&quot;https://github.com/sequelize/express-example&quot;&gt;Sequelize Express Example&lt;/a&gt;를 참조 하였다.&lt;/p&gt;

&lt;p&gt;DBMS를 참고 하여 각 모델을 다음과 같이 작성 하였다.&lt;/p&gt;

&lt;h3 id=&quot;users&quot;&gt;Users&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var User = sequelize.define('Users', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    user_id: { type: DataTypes.STRING(50), allowNull: false, unique: true },
    password: { type: DataTypes.STRING(100), allowNull: false },
    description: { type: DataTypes.STRING(1000), allowNull: true }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: true
  });


  User.associate = (models) =&amp;gt; {
    models.Users.belongsToMany(models.Roles, { through: 'UserRoles', foreignKey: 'u_id' });
  };

  return User;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;roles&quot;&gt;Roles&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var Roles = sequelize.define('Roles', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    role_name: { type: DataTypes.STRING(20), allowNull: false, unique: true },
    description: { type: DataTypes.STRING(1000), allowNull: true }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true,
    paranoid: true
  });

  Roles.associate = (models) =&amp;gt; {
    models.Roles.belongsToMany(models.Users, { through: 'UserRoles', foreignKey: 'r_id' });
  };

  return Roles;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;userroles&quot;&gt;UserRoles&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.exports = (sequelize, DataTypes) =&amp;gt; {
  var UserRole = sequelize.define('UserRoles', {
    id: {
      type: DataTypes.INTEGER,
      autoIncrement: true,
      primaryKey: true
    },
    r_id: {
      type: DataTypes.INTEGER
    },
    u_id: {
      type: DataTypes.INTEGER
    }
  }, {
    freezeTableName: true,
    underscored: true,
    timestamps: true
  });
  return UserRole;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가적으로 LoginHistory를 구현하였고 최근 10분간 로그인이 5회 실패시 잠시 후 시도하도록 했다.&lt;/p&gt;

&lt;h3 id=&quot;loginhistorys&quot;&gt;LoginHistorys&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
module.exports = (sequelize, DataTypes) =&amp;gt; {
    var LoginHistory = sequelize.define('LoginHistorys', {
      id: {
        type: DataTypes.INTEGER,
        autoIncrement: true,
        primaryKey: true
      },
      user_id: { type: DataTypes.STRING(50), allowNull: false },
      login_success: { type: DataTypes.STRING(1), allowNull: false, defaultValue:'Y' }
    }, {
      freezeTableName: true,
      underscored: true,
      timestamps: true,
      paranoid: true
    });
  
    return LoginHistory;
  };
  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;로그인-구현&quot;&gt;로그인 구현&lt;/h2&gt;

&lt;p&gt;로그인은 간단하게 routers/index.js 에 구현하였다. 추가로 다른 기능이 생긴다면 디렉토리를 추가하여 처리 할 예정이다.&lt;/p&gt;

&lt;h3 id=&quot;login-process&quot;&gt;Login Process&lt;/h3&gt;

&lt;p&gt;10분동안 5회 이상의 로그인 실패가 있을 경우 잠시후 시도하라는 메시지가 표출되며, 로그인 실패/성공은 LoginHistory에 저장된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.post('/login', (req, res, next) =&amp;gt; {
  const loginInfo = req.body;
  if (!Object.prototype.hasOwnProperty.call(loginInfo, 'user_id')
    || !Object.prototype.hasOwnProperty.call(loginInfo, 'password')) {
    res.json({ status: 'error', message: 'Invalid Prameter' });
  }
  else {
    models.LoginHistorys.count({ where: { user_id: loginInfo.user_id, login_success: 'N', created_at: { [models.Sequelize.Op.gt]: moment().subtract(20, 'minutes').toDate() } } }).then((c) =&amp;gt; {
      if (c &amp;gt; 5) {
        res.json({ status: 'error', message: 'Login failed several times. Please try again in 10 minutes.' });
      }
      else {
        models.Users.findOne({
          where: { user_id: loginInfo.user_id, password: loginInfo.password },
          include: [models.Roles]
        }).then((u) =&amp;gt; {
          if (u) {
            const userInfo = {
              user_id: u.user_id,
              password: u.password,
              desc: u.description,
              role: u.Roles.map(r =&amp;gt; r.role_name)
            };
            res.json({ status: 'success', userInfo });
            loginInfo.login_success = 'Y';
          }
          else {
            res.json({ status: 'error', message: 'check ID or PW' });
            loginInfo.login_success = 'N';
          }
          models.LoginHistorys.create(loginInfo);
        });
      }
    });
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;todo-진행-예정&quot;&gt;TODO 진행 예정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io/&quot;&gt;JWT&lt;/a&gt;를 이용하여 로그인 성공시 전송되는 내용을 토큰 처리&lt;/li&gt;
  &lt;li&gt;토큰 validate API 제공&lt;/li&gt;
  &lt;li&gt;사용자 PASSWORD hash 암호화 처리(&lt;a href=&quot;https://epthffh.tistory.com/entry/SHA256-%EC%9D%B8%EC%BD%94%EB%94%A9-%EC%86%8C%EC%8A%A4&quot;&gt;SHA-256&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;나머지도-하나씩-처리-하자&quot;&gt;나머지도 하나씩 처리 하자!&lt;/h3&gt;

&lt;h2 id=&quot;프로젝트-저장소&quot;&gt;&lt;a href=&quot;https://github.com/lahuman/AuthServer&quot;&gt;프로젝트 저장소&lt;/a&gt;&lt;/h2&gt;</content><category term="node" /><category term="auth" /><summary type="html">로그인 처리와 HISTORY 기록</summary></entry><entry><title type="html">상상 하기</title><link href="https://lahuman.github.io/20190302/" rel="alternate" type="text/html" title="상상 하기" /><published>2019-03-02T00:00:00+09:00</published><updated>2019-03-02T00:00:00+09:00</updated><id>https://lahuman.github.io/20190302</id><content type="html" xml:base="https://lahuman.github.io/20190302/">&lt;h1 id=&quot;상상력은-정말-끊없다&quot;&gt;상상력은 정말 끊없다.&lt;/h1&gt;

&lt;p&gt;나는 소설책(무협지, 판타지, 만화 등)을 좋아한다. 현실 세계에 있을 수는 없지만 작가의 시점에서 주인공을 따라 새로운 세상을 함께 여행하는 일은 정말 즐겁다.&lt;/p&gt;

&lt;p&gt;가끔 작가가 만든 틀에서 벗어나 내 마음 가는대로 이야기를 상상하기도 한다.&lt;/p&gt;

&lt;p&gt;그러다 재미있는 상상을 했다.&lt;/p&gt;

&lt;h2 id=&quot;상상의-세계&quot;&gt;상상의 세계&lt;/h2&gt;

&lt;h3 id=&quot;법칙&quot;&gt;법칙&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;사람들이 생각하는 세상은 다른 차원의 세상이 된다.&lt;/li&gt;
  &lt;li&gt;사람들의 상상은 다른 차원의 세계를 구성하는 힘이 된다.&lt;/li&gt;
  &lt;li&gt;많은 사람들이 함께 상상 할 수록 더욱 강력하고 튼튼한 세상이 만들어 진다.&lt;/li&gt;
  &lt;li&gt;튼튼하지 못한 세상은 사람들에게서 잊혀지고, 곧 멸망하게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;법칙을-넘어서&quot;&gt;법칙을 넘어서&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;상상의 세계는 기본적으로 사람들의 상상이 기본이 되지만, 많은 사람들이 특정 인물에 대하여 상상을 하게 되면 그 상상의 인물은 다른 사람의 가튼 상상으로 연결된다. 연결된 상상은 자아를 가지게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;많은 사람들이 함께 상상하는 세상은 튼튼함을 넘어 자아를 가지게 된다. 자아를 가진 상상의 세계는 연결된 사람들에게 이야기를 전할 수도 있다. 이러한 상상의 세계는 현재 세상의 종교가 된다.&lt;/p&gt;

&lt;h3 id=&quot;멸망하는-상상의-세계&quot;&gt;멸망하는 상상의 세계&lt;/h3&gt;

&lt;p&gt;사람들이 상상의 세상을 잊게 되면 해당 상상의 세계는 점점 작아지고 결국 멸망하게 된다. 멸망을 한 상상의 세계는 회색빛으로 변하고 시간과 공간이 멈춰진다. 상상의 세계의 멸망이 끝을 나타내지는 않는다. 누군가가 다시 상상을 하면 상상하는 부분부터 조금씩 다시 시작 되게 된다.&lt;/p&gt;

&lt;h3 id=&quot;이런-저런-잡생각을-해본다&quot;&gt;이런 저런 잡생각을 해본다&lt;/h3&gt;

&lt;h2 id=&quot;기타&quot;&gt;기타&lt;/h2&gt;

&lt;p&gt;요즘 논증의 탄생이라는 책을 보고 있다. 논문을 쓰면서 교수님이 지도해주신 많은 내용과 동일한 내용을 담고 있었다.&lt;/p&gt;

&lt;p&gt;글(논문)쓰기를 하면서 내 주장을 어떻게 표현 해야 하는지 남의 글을 어떻게 인용해야 하는지에 알려준다.&lt;/p&gt;

&lt;p&gt;그 책을 보고 있으니 내가 상상하는 세상을 글로 써보고 싶다.&lt;/p&gt;</content><category term="단상" /><summary type="html">많은 상상을 해보고 있음</summary></entry><entry><title type="html">AWS ec2 key 생성 &amp;amp; 로그인</title><link href="https://lahuman.github.io/aws_login_user_key/" rel="alternate" type="text/html" title="AWS ec2 key 생성 &amp; 로그인" /><published>2019-02-28T00:00:00+09:00</published><updated>2019-02-28T00:00:00+09:00</updated><id>https://lahuman.github.io/aws_login_user_key</id><content type="html" xml:base="https://lahuman.github.io/aws_login_user_key/">&lt;h1 id=&quot;aws에서-ec2-로그인-계정-생성-처리-방법&quot;&gt;AWS에서 EC2 로그인 계정 생성 처리 방법&lt;/h1&gt;

&lt;p&gt;현재 설정은 AWS에서 EC2 인스턴스(ubunt 기반)를 생성 후 접속은 pem 파일을 이용하도록 되어있다.&lt;/p&gt;

&lt;p&gt;하나의 pem 파일을 이용하는 것은 보안에도 좋지 않고, 초기 계정은 Root 권한을 가질 수 있는 계정이기에 위험하다. 따라서 EC2에 접근 가능한 추가 계정을 생성하는 것을 알아보자.&lt;/p&gt;

&lt;p&gt;AWS의 EC2 서버에서 먼저 계정을 생성 한다. 현재 계정은 root 권한을 가진 ubuntu(기본)이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 계정 생성
$&amp;gt; sudo useradd lahuman
# 생성된 계정으로 계정 변경
$&amp;gt; sudo su - lahuman
# .ssh 디렉토리 생성 &amp;amp; authorized_keys 파일 생성
$&amp;gt; mkdir .ssh
$&amp;gt; chmod 700 .ssh
$&amp;gt; cd .ssh
$&amp;gt; touch authorized_keys
$&amp;gt; chmod 600 authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;계정 생성이 완료 되었으면 &lt;kbd&gt;EC2&lt;/kbd&gt; &amp;gt; &lt;kbd&gt;네트워크 및 보안&lt;/kbd&gt; &amp;gt; &lt;kbd&gt;키 페어&lt;/kbd&gt; 메뉴로 이동을 하여 &lt;kbd&gt;키 페어 생성&lt;/kbd&gt; 버튼을 클릭한다.&lt;/p&gt;

&lt;p&gt;키 페어 명을 넣고 생성을 하면 &lt;kbd&gt;pem 파일&lt;/kbd&gt;이 자동으로 down 된다. 이 pem 파일은 무척 중요하다!&lt;/p&gt;

&lt;p&gt;이 pem 파일을 EC2 서버의 아까 생성한 계정 밑으로 복사 한다.&lt;/p&gt;

&lt;p&gt;이후 다음 명령어를 이용하여 public Key를 생성하고 해당 키 값을 authorized_keys에 저장한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# upload 된 pem 의 권한을 600 으로 수정한다.
$&amp;gt; chmod 500 lahuman.pem
# public key 생성
$&amp;gt; ssh-keygen -y
Enter file in which the key is (/home/lahuman/.ssh/id_rsa): /home/lahuman/lahuman.pem
ssh-rsa ABCDEF........key......

# ssh-rsa 이후 키 값을 복사하여 authorized_keys 에 추가한다.
$&amp;gt; vi .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 내 자리에서 pem 파일을 이용해서 로그인을 시도 하면 잘 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$&amp;gt; ssh -i &quot;lahuman.pem&quot; lahuman@IP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;쉬운-듯-어려운-설정&quot;&gt;쉬운 듯 어려운 설정&lt;/h2&gt;</content><category term="pem" /><category term="cert" /><summary type="html">AWS에서 key(pem)을 생성하고 로그인까지 해보기</summary></entry><entry><title type="html">crt, key 인증서 파일 pem으로 변환</title><link href="https://lahuman.github.io/cet_key_to_pem/" rel="alternate" type="text/html" title="crt, key 인증서 파일 pem으로 변환" /><published>2019-02-27T00:00:00+09:00</published><updated>2019-02-27T00:00:00+09:00</updated><id>https://lahuman.github.io/cet_key_to_pem</id><content type="html" xml:base="https://lahuman.github.io/cet_key_to_pem/">&lt;h1 id=&quot;cert-key-파일을-pem-파일로-변환-하기&quot;&gt;cert, key 파일을 pem 파일로 변환 하기&lt;/h1&gt;

&lt;p&gt;nginx에서 사용하던 인증서를 nodejs에서 바로 사용을 하기 위해 pem 파일 형식으로 변경 해야하는 일이 생겨서 검색을 해보았다.
파일 형석의 변환은 다음과 같이 쉽게 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# key 변경
openssl rsa -in server.key -text &amp;gt; private.pem
# crt 변경
openssl x509 -inform PEM -in server.crt &amp;gt; public.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;추가-팁-nodejs-에서-https-설정&quot;&gt;추가 팁] nodejs 에서 https 설정&lt;/h2&gt;
&lt;p&gt;nodejs에서 https 사용을 위해서는 https 모듈을 추가로 설치 해야 한다.&lt;/p&gt;

&lt;p&gt;이후 소스내에 다음과 같이 인증서를 &lt;strong&gt;options&lt;/strong&gt;을 추가 하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const https = require('https');
const fs = require('fs');
const options = {
  ca: fs.readFileSync('인증서경로/ca-bundle.pem')
  key: fs.readFileSync('인증서경로/domain_xxxxx.key.pem')
  cert: fs.readFileSync('인증서경로/domain_xxxxx.crt.pem')
};
https.createServer(options, (req, res) =&amp;gt; {
  res.writeHead(200);
  res.end('hello world\n');
}).listen(443);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;참-쉽죠&quot;&gt;참 쉽죠?&lt;/h3&gt;

&lt;h1 id=&quot;참고-주소&quot;&gt;참고 주소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/991758/how-to-get-pem-file-from-key-and-crt-files&quot;&gt;How to get .pem file from .key and .crt files?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.securesign.kr/guides/Node-js-SSL-Certificates-Install&quot;&gt;Node.js SSL 인증서 설치/적용 가이드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="pem" /><category term="cert" /><summary type="html">인증서 파일 형식 변경 처리 &amp; node 에서 https 사용설정</summary></entry><entry><title type="html">요즘 진행된 일들을 정리를 못하고 있다.</title><link href="https://lahuman.github.io/20190227/" rel="alternate" type="text/html" title="요즘 진행된 일들을 정리를 못하고 있다." /><published>2019-02-27T00:00:00+09:00</published><updated>2019-02-27T00:00:00+09:00</updated><id>https://lahuman.github.io/20190227</id><content type="html" xml:base="https://lahuman.github.io/20190227/">&lt;h1 id=&quot;요즘-많은-새로운-것을-익히기도-하고-기존에-해-보았던-것도-다시-해보고-있다&quot;&gt;요즘 많은 새로운 것을 익히기도 하고, 기존에 해 보았던 것도 다시 해보고 있다.&lt;/h1&gt;

&lt;p&gt;이직을 하고 3개월이 흘렀다. 
월급을 3번 받아 보았고, 제대로된 급여는 2번 받아 보았다.&lt;/p&gt;

&lt;p&gt;이직하고 달라진 점드를 뽑으면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용하는 언어가 달라 졌다.
    &lt;ul&gt;
      &lt;li&gt;10여년간 사용하던 JAVA에서 Python을 거쳐 Nodejs를 사용하고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;바쁘게 일한다.
    &lt;ul&gt;
      &lt;li&gt;20대 후반에 하는 방식으로 일하고 있다.&lt;/li&gt;
      &lt;li&gt;변화를 두려워 하지 않고 일단 해본다.&lt;/li&gt;
      &lt;li&gt;안되면 동료에게 물어본다.&lt;/li&gt;
      &lt;li&gt;새로운 도전을 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이젠 시니어다.
    &lt;ul&gt;
      &lt;li&gt;주니어 개발자와 함께 일하며, 주니어 개발자가 발전 할 수 있는 조언을 주어야 한다.&lt;/li&gt;
      &lt;li&gt;꼰대 같은 생각이 든다.&lt;/li&gt;
      &lt;li&gt;나도 모르게 “내 생각이 옳다고만 생각 한다.”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장점도 있고 단점도 있지만 이직 자체는 성공적이다.&lt;/p&gt;

&lt;p&gt;기존 회사보다 일도 많아지고 책임도 커졌지만, 무엇보다 즐겁다.&lt;/p&gt;

&lt;h3 id=&quot;반성해-하는-점&quot;&gt;반성해 하는 점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;또 오지랍을 부리고 있다.
    &lt;ul&gt;
      &lt;li&gt;내 일이나 잘하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;은근 슬쩍 잘하는 사람에게 일을 미룬다.
    &lt;ul&gt;
      &lt;li&gt;함께 하는 동료중에 잘하는 분이 계신데 너무 믿고 있는건지 내일도 슬쩍 미룬다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;잘난척 한다.
    &lt;ul&gt;
      &lt;li&gt;이건 대 반성 하자…&lt;/li&gt;
      &lt;li&gt;좀 조용하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;반성-하면-변화하는-내가-되자&quot;&gt;반성 하면 변화하는 내가 되자&lt;/h3&gt;</content><category term="단상" /><summary type="html">바쁘다는 핑계로 정리를 못하고 있다.</summary></entry></feed>
